diff --git a/lib/tsc.js b/lib/tsc.js
index 202882d588..74412be9cb 100644
--- a/lib/tsc.js
+++ b/lib/tsc.js
@@ -2990,7 +2990,21 @@ var ts;
             }
             function realpath(path) {
                 try {
-                    return _fs.realpathSync(path);
+                    var regexp = /\.([^\/]+?)$/;
+                    var match = path.match(regexp);
+                    var rpath = _fs.realpathSync(path);
+                    if (match !== null) {
+                        var ext = match[1];
+                        var rmatch = rpath.match(regexp);
+                        if (rmatch !== null) {
+                            var rext = rmatch[1];
+                            if (ext !== rext) {
+                                return rpath.replace(new RegExp(rext + "$"), ext);
+                            }
+                            return rpath;
+                        }
+                    }
+                    return rpath;
                 }
                 catch (_a) {
                     return path;
@@ -9428,7 +9442,7 @@ var ts;
         return symbol && ts.length(symbol.declarations) > 0 && hasModifier(symbol.declarations[0], 512);
     }
     function tryExtractTSExtension(fileName) {
-        return ts.find(ts.supportedTSExtensionsForExtractExtension, function (extension) { return ts.fileExtensionIs(fileName, extension); });
+        return ts.find(ts.supportedTSExtensions, function (extension) { return ts.fileExtensionIs(fileName, extension); });
     }
     ts.tryExtractTSExtension = tryExtractTSExtension;
     function getExpandedCharCodes(input) {
@@ -12808,13 +12822,55 @@ var ts;
         }
     }
     ts.getScriptKindFromFileName = getScriptKindFromFileName;
-    ts.supportedTSExtensions = [".ts", ".tsx", ".d.ts"];
-    ts.supportedTSExtensionsWithJson = [".ts", ".tsx", ".d.ts", ".json"];
-    ts.supportedTSExtensionsForExtractExtension = [".d.ts", ".ts", ".tsx"];
-    ts.supportedJSExtensions = [".js", ".jsx"];
-    ts.supportedJSAndJsonExtensions = [".js", ".jsx", ".json"];
+    ts.supportedJsonExtensions = [
+        ".node.json",
+        ".web.json",
+        ".native.json",
+        ".ios.json",
+        ".android.json",
+        ".json"
+    ];
+    ts.supportedTSExtensions = [
+        ".node.ts",
+        ".node.tsx",
+        ".web.ts",
+        ".web.tsx",
+        ".native.ts",
+        ".native.tsx",
+        ".ios.ts",
+        ".ios.tsx",
+        ".android.ts",
+        ".android.tsx",
+        ".d.ts",
+        ".ts",
+        ".tsx"
+    ];
+    ts.supportedTSExtensionsWithJson = ts.supportedTSExtensions.concat(ts.supportedJsonExtensions);
+    ts.supportedJSExtensions = [
+        ".node.js",
+        ".node.jsx",
+        ".web.js",
+        ".web.jsx",
+        ".native.js",
+        ".native.jsx",
+        ".ios.js",
+        ".ios.jsx",
+        ".android.js",
+        ".android.jsx",
+        ".js",
+        ".jsx"
+    ];
+    ts.supportedJSAndJsonExtensions = ts.supportedJSExtensions.concat(ts.supportedJsonExtensions);
     var allSupportedExtensions = ts.supportedTSExtensions.concat(ts.supportedJSExtensions);
-    var allSupportedExtensionsWithJson = ts.supportedTSExtensions.concat(ts.supportedJSExtensions, [".json"]);
+    var allSupportedExtensionsWithJson = ts.supportedTSExtensions.concat(ts.supportedJSExtensions, ts.supportedJsonExtensions);
+    function getAllSupportedExtensions() {
+        return allSupportedExtensions;
+    }
+    ts.getAllSupportedExtensions = getAllSupportedExtensions;
+    function getAllSupportedExtensionsWithJson() {
+        return allSupportedExtensionsWithJson;
+    }
+    ts.getAllSupportedExtensionsWithJson = getAllSupportedExtensionsWithJson;
     function getSupportedExtensions(options, extraFileExtensions) {
         var needJsExtensions = options && options.allowJs;
         if (!extraFileExtensions || extraFileExtensions.length === 0) {
@@ -12962,7 +13018,7 @@ var ts;
     }
     ts.positionIsSynthesized = positionIsSynthesized;
     function extensionIsTS(ext) {
-        return ext === ".ts" || ext === ".tsx" || ext === ".d.ts";
+        return ts.supportedTSExtensions.indexOf(ext) !== -1;
     }
     ts.extensionIsTS = extensionIsTS;
     function resolutionExtensionIsTSOrJson(ext) {
@@ -12979,7 +13035,7 @@ var ts;
     }
     ts.isAnySupportedFileExtension = isAnySupportedFileExtension;
     function tryGetExtensionFromPath(path) {
-        return ts.find(extensionsToRemove, function (e) { return ts.fileExtensionIs(path, e); });
+        return ts.find(allSupportedExtensionsWithJson, function (e) { return ts.fileExtensionIs(path, e); });
     }
     ts.tryGetExtensionFromPath = tryGetExtensionFromPath;
     function getAnyExtensionFromPathWorker(path, extensions, stringEqualityComparer) {
@@ -13018,6 +13074,19 @@ var ts;
         files: ts.emptyArray,
         directories: ts.emptyArray
     };
+    function getFileExtension(filepath) {
+        if (typeof filepath === "undefined") {
+            return ".ts";
+        }
+        for (var _i = 0, allSupportedExtensionsWithJson_1 = allSupportedExtensionsWithJson; _i < allSupportedExtensionsWithJson_1.length; _i++) {
+            var ext = allSupportedExtensionsWithJson_1[_i];
+            if (ts.endsWith(filepath, ext)) {
+                return ext;
+            }
+        }
+        return ".ts";
+    }
+    ts.getFileExtension = getFileExtension;
     function matchPatternOrExact(patternStrings, candidate) {
         var patterns = [];
         for (var _i = 0, patternStrings_1 = patternStrings; _i < patternStrings_1.length; _i++) {
@@ -20837,7 +20906,7 @@ var ts;
             }
             return extendedConfigPath;
         }
-        var resolved = ts.nodeModuleNameResolver(extendedConfig, ts.combinePaths(basePath, "tsconfig.json"), { moduleResolution: ts.ModuleResolutionKind.NodeJs }, host, undefined, undefined, true);
+        var resolved = ts.nodeModuleNameResolver(".ts", extendedConfig, ts.combinePaths(basePath, "tsconfig.json"), { moduleResolution: ts.ModuleResolutionKind.NodeJs }, host, undefined, undefined, true);
         if (resolved.resolvedModule) {
             return resolved.resolvedModule.resolvedFileName;
         }
@@ -21271,6 +21340,12 @@ var ts;
     function readPackageJsonMainField(jsonContent, baseDirectory, state) {
         return readPackageJsonPathField(jsonContent, "main", baseDirectory, state);
     }
+    function readPackageJsonReactNativeField(jsonContent, baseDirectory, state) {
+        return readPackageJsonPathField(jsonContent, "react-native", baseDirectory, state);
+    }
+    function readPackageJsonBrowserField(jsonContent, baseDirectory, state) {
+        return readPackageJsonPathField(jsonContent, "browser", baseDirectory, state);
+    }
     function readPackageJsonTypesVersionsField(jsonContent, state) {
         var typesVersions = readPackageJsonField(jsonContent, "typesVersions", "object", state);
         if (typesVersions === undefined)
@@ -21412,7 +21487,7 @@ var ts;
                     if (!directoryExists && traceEnabled) {
                         trace(host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, candidateDirectory);
                     }
-                    return resolvedTypeScriptOnly(loadNodeModuleFromDirectory(Extensions.DtsOnly, candidate, !directoryExists, moduleResolutionState));
+                    return resolvedTypeScriptOnly(loadNodeModuleFromDirectory(".ts", Extensions.DtsOnly, candidate, !directoryExists, moduleResolutionState));
                 });
             }
             else {
@@ -21429,12 +21504,12 @@ var ts;
                 }
                 var result = void 0;
                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {
-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);
+                    var searchResult = loadModuleFromNearestNodeModulesDirectory(".ts", Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);
                     result = searchResult && searchResult.value;
                 }
                 else {
                     var candidate = ts.normalizePathAndParts(ts.combinePaths(initialLocationForSecondaryLookup, typeReferenceDirectiveName)).path;
-                    result = nodeLoadModuleByRelativeName(Extensions.DtsOnly, candidate, false, moduleResolutionState, true);
+                    result = nodeLoadModuleByRelativeName(".ts", Extensions.DtsOnly, candidate, false, moduleResolutionState, true);
                 }
                 var resolvedFile = resolvedTypeScriptOnly(result);
                 if (!resolvedFile && traceEnabled) {
@@ -21580,8 +21655,9 @@ var ts;
     ts.createModuleResolutionCacheWithMaps = createModuleResolutionCacheWithMaps;
     function resolveModuleNameFromCache(moduleName, containingFile, cache) {
         var containingDirectory = ts.getDirectoryPath(containingFile);
+        var parentFileExtension = ts.getFileExtension(containingFile);
         var perFolderCache = cache && cache.getOrCreateCacheForDirectory(containingDirectory);
-        return perFolderCache && perFolderCache.get(moduleName);
+        return perFolderCache && perFolderCache.get(moduleName + "|" + parentFileExtension);
     }
     ts.resolveModuleNameFromCache = resolveModuleNameFromCache;
     function resolveModuleName(moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
@@ -21596,8 +21672,10 @@ var ts;
             }
         }
         var containingDirectory = ts.getDirectoryPath(containingFile);
+        var parentFileExtension = ts.getFileExtension(containingFile);
+        var moduleNameKey = moduleName + "|" + parentFileExtension;
         var perFolderCache = cache && cache.getOrCreateCacheForDirectory(containingDirectory, redirectedReference);
-        var result = perFolderCache && perFolderCache.get(moduleName);
+        var result = perFolderCache && perFolderCache.get(moduleNameKey);
         if (result) {
             if (traceEnabled) {
                 trace(host, ts.Diagnostics.Resolution_for_module_0_was_found_in_cache_from_location_1, moduleName, containingDirectory);
@@ -21618,18 +21696,18 @@ var ts;
             }
             switch (moduleResolution) {
                 case ts.ModuleResolutionKind.NodeJs:
-                    result = nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
+                    result = nodeModuleNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
                     break;
                 case ts.ModuleResolutionKind.Classic:
-                    result = classicNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
+                    result = classicNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
                     break;
                 default:
                     return ts.Debug.fail("Unexpected moduleResolution: " + moduleResolution);
             }
             if (perFolderCache) {
-                perFolderCache.set(moduleName, result);
+                perFolderCache.set(moduleNameKey, result);
                 if (!ts.isExternalModuleNameRelative(moduleName)) {
-                    cache.getOrCreateCacheForModuleName(moduleName, redirectedReference).set(containingDirectory, result);
+                    cache.getOrCreateCacheForModuleName(moduleNameKey, redirectedReference).set(containingDirectory, result);
                 }
             }
         }
@@ -21644,28 +21722,28 @@ var ts;
         return result;
     }
     ts.resolveModuleName = resolveModuleName;
-    function tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loader, state) {
-        var resolved = tryLoadModuleUsingPathsIfEligible(extensions, moduleName, loader, state);
+    function tryLoadModuleUsingOptionalResolutionSettings(parentFileExtension, extensions, moduleName, containingDirectory, loader, state) {
+        var resolved = tryLoadModuleUsingPathsIfEligible(parentFileExtension, extensions, moduleName, loader, state);
         if (resolved)
             return resolved.value;
         if (!ts.isExternalModuleNameRelative(moduleName)) {
-            return tryLoadModuleUsingBaseUrl(extensions, moduleName, loader, state);
+            return tryLoadModuleUsingBaseUrl(parentFileExtension, extensions, moduleName, loader, state);
         }
         else {
-            return tryLoadModuleUsingRootDirs(extensions, moduleName, containingDirectory, loader, state);
+            return tryLoadModuleUsingRootDirs(parentFileExtension, extensions, moduleName, containingDirectory, loader, state);
         }
     }
-    function tryLoadModuleUsingPathsIfEligible(extensions, moduleName, loader, state) {
+    function tryLoadModuleUsingPathsIfEligible(parentFileExtension, extensions, moduleName, loader, state) {
         var _a = state.compilerOptions, baseUrl = _a.baseUrl, paths = _a.paths;
         if (baseUrl && paths && !ts.pathIsRelative(moduleName)) {
             if (state.traceEnabled) {
                 trace(state.host, ts.Diagnostics.baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1, baseUrl, moduleName);
                 trace(state.host, ts.Diagnostics.paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0, moduleName);
             }
-            return tryLoadModuleUsingPaths(extensions, moduleName, baseUrl, paths, loader, false, state);
+            return tryLoadModuleUsingPaths(parentFileExtension, extensions, moduleName, baseUrl, paths, loader, false, state);
         }
     }
-    function tryLoadModuleUsingRootDirs(extensions, moduleName, containingDirectory, loader, state) {
+    function tryLoadModuleUsingRootDirs(parentFileExtension, extensions, moduleName, containingDirectory, loader, state) {
         if (!state.compilerOptions.rootDirs) {
             return undefined;
         }
@@ -21699,7 +21777,7 @@ var ts;
             if (state.traceEnabled) {
                 trace(state.host, ts.Diagnostics.Loading_0_from_the_root_dir_1_candidate_location_2, suffix, matchedNormalizedPrefix, candidate);
             }
-            var resolvedFileName = loader(extensions, candidate, !ts.directoryProbablyExists(containingDirectory, state.host), state);
+            var resolvedFileName = loader(parentFileExtension, extensions, candidate, !ts.directoryProbablyExists(containingDirectory, state.host), state);
             if (resolvedFileName) {
                 return resolvedFileName;
             }
@@ -21716,7 +21794,7 @@ var ts;
                     trace(state.host, ts.Diagnostics.Loading_0_from_the_root_dir_1_candidate_location_2, suffix, rootDir, candidate_1);
                 }
                 var baseDirectory = ts.getDirectoryPath(candidate_1);
-                var resolvedFileName_1 = loader(extensions, candidate_1, !ts.directoryProbablyExists(baseDirectory, state.host), state);
+                var resolvedFileName_1 = loader(parentFileExtension, extensions, candidate_1, !ts.directoryProbablyExists(baseDirectory, state.host), state);
                 if (resolvedFileName_1) {
                     return resolvedFileName_1;
                 }
@@ -21727,7 +21805,7 @@ var ts;
         }
         return undefined;
     }
-    function tryLoadModuleUsingBaseUrl(extensions, moduleName, loader, state) {
+    function tryLoadModuleUsingBaseUrl(parentFileExtension, extensions, moduleName, loader, state) {
         var baseUrl = state.compilerOptions.baseUrl;
         if (!baseUrl) {
             return undefined;
@@ -21739,10 +21817,10 @@ var ts;
         if (state.traceEnabled) {
             trace(state.host, ts.Diagnostics.Resolving_module_name_0_relative_to_base_url_1_2, moduleName, baseUrl, candidate);
         }
-        return loader(extensions, candidate, !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
+        return loader(parentFileExtension, extensions, candidate, !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
     }
     function resolveJSModule(moduleName, initialDir, host) {
-        var _a = tryResolveJSModuleWorker(moduleName, initialDir, host), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
+        var _a = tryResolveJSModuleWorker(".ts", moduleName, initialDir, host), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
         if (!resolvedModule) {
             throw new Error("Could not resolve JS module '" + moduleName + "' starting at '" + initialDir + "'. Looked in: " + failedLookupLocations.join(", "));
         }
@@ -21750,7 +21828,7 @@ var ts;
     }
     ts.resolveJSModule = resolveJSModule;
     function tryResolveJSModule(moduleName, initialDir, host) {
-        var resolvedModule = tryResolveJSModuleWorker(moduleName, initialDir, host).resolvedModule;
+        var resolvedModule = tryResolveJSModuleWorker(".ts", moduleName, initialDir, host).resolvedModule;
         return resolvedModule && resolvedModule.resolvedFileName;
     }
     ts.tryResolveJSModule = tryResolveJSModule;
@@ -21758,14 +21836,14 @@ var ts;
     var tsExtensions = [Extensions.TypeScript, Extensions.JavaScript];
     var tsPlusJsonExtensions = tsExtensions.concat([Extensions.Json]);
     var tsconfigExtensions = [Extensions.TSConfig];
-    function tryResolveJSModuleWorker(moduleName, initialDir, host) {
-        return nodeModuleNameResolverWorker(moduleName, initialDir, { moduleResolution: ts.ModuleResolutionKind.NodeJs, allowJs: true }, host, undefined, jsOnlyExtensions, undefined);
+    function tryResolveJSModuleWorker(parentFileExtension, moduleName, initialDir, host) {
+        return nodeModuleNameResolverWorker(parentFileExtension, moduleName, initialDir, { moduleResolution: ts.ModuleResolutionKind.NodeJs, allowJs: true }, host, undefined, jsOnlyExtensions, undefined);
     }
-    function nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference, lookupConfig) {
-        return nodeModuleNameResolverWorker(moduleName, ts.getDirectoryPath(containingFile), compilerOptions, host, cache, lookupConfig ? tsconfigExtensions : (compilerOptions.resolveJsonModule ? tsPlusJsonExtensions : tsExtensions), redirectedReference);
+    function nodeModuleNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference, lookupConfig) {
+        return nodeModuleNameResolverWorker(parentFileExtension, moduleName, ts.getDirectoryPath(containingFile), compilerOptions, host, cache, lookupConfig ? tsconfigExtensions : (compilerOptions.resolveJsonModule ? tsPlusJsonExtensions : tsExtensions), redirectedReference);
     }
     ts.nodeModuleNameResolver = nodeModuleNameResolver;
-    function nodeModuleNameResolverWorker(moduleName, containingDirectory, compilerOptions, host, cache, extensions, redirectedReference) {
+    function nodeModuleNameResolverWorker(parentFileExtension, moduleName, containingDirectory, compilerOptions, host, cache, extensions, redirectedReference) {
         var traceEnabled = isTraceEnabled(compilerOptions, host);
         var failedLookupLocations = [];
         var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations };
@@ -21776,8 +21854,8 @@ var ts;
         }
         return { resolvedModule: undefined, failedLookupLocations: failedLookupLocations };
         function tryResolve(extensions) {
-            var loader = function (extensions, candidate, onlyRecordFailures, state) { return nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, true); };
-            var resolved = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loader, state);
+            var loader = function (parentFileExtension, extensions, candidate, onlyRecordFailures, state) { return nodeLoadModuleByRelativeName(parentFileExtension, extensions, candidate, onlyRecordFailures, state, true); };
+            var resolved = tryLoadModuleUsingOptionalResolutionSettings(parentFileExtension, extensions, moduleName, containingDirectory, loader, state);
             if (resolved) {
                 return toSearchResult({ resolved: resolved, isExternalLibraryImport: pathContainsNodeModules(resolved.path) });
             }
@@ -21785,7 +21863,7 @@ var ts;
                 if (traceEnabled) {
                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);
                 }
-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
+                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(parentFileExtension, extensions, moduleName, containingDirectory, state, cache, redirectedReference);
                 if (!resolved_1)
                     return undefined;
                 var resolvedValue = resolved_1.value;
@@ -21798,7 +21876,7 @@ var ts;
             }
             else {
                 var _a = ts.normalizePathAndParts(ts.combinePaths(containingDirectory, moduleName)), candidate = _a.path, parts = _a.parts;
-                var resolved_2 = nodeLoadModuleByRelativeName(extensions, candidate, false, state, true);
+                var resolved_2 = nodeLoadModuleByRelativeName(parentFileExtension, extensions, candidate, false, state, true);
                 return resolved_2 && toSearchResult({ resolved: resolved_2, isExternalLibraryImport: ts.contains(parts, "node_modules") });
             }
         }
@@ -21814,7 +21892,7 @@ var ts;
         ts.Debug.assert(host.fileExists(real), path + " linked to nonexistent file " + real);
         return real;
     }
-    function nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
+    function nodeLoadModuleByRelativeName(parentFileExtension, extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
         if (state.traceEnabled) {
             trace(state.host, ts.Diagnostics.Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1, candidate, Extensions[extensions]);
         }
@@ -21828,10 +21906,10 @@ var ts;
                     onlyRecordFailures = true;
                 }
             }
-            var resolvedFromFile = loadModuleFromFile(extensions, candidate, onlyRecordFailures, state);
+            var resolvedFromFile = loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state);
             if (resolvedFromFile) {
                 var nm = considerPackageJson ? parseNodeModuleFromPath(resolvedFromFile) : undefined;
-                var packageInfo = nm && getPackageJsonInfo(nm.packageDirectory, nm.subModuleName, false, state);
+                var packageInfo = nm && getPackageJsonInfo(parentFileExtension, nm.packageDirectory, nm.subModuleName, false, state);
                 var packageId = packageInfo && packageInfo.packageId;
                 return withPackageId(packageId, resolvedFromFile);
             }
@@ -21845,7 +21923,7 @@ var ts;
                 onlyRecordFailures = true;
             }
         }
-        return loadNodeModuleFromDirectory(extensions, candidate, onlyRecordFailures, state, considerPackageJson);
+        return loadNodeModuleFromDirectory(parentFileExtension, extensions, candidate, onlyRecordFailures, state, considerPackageJson);
     }
     ts.nodeModulesPathPart = "/node_modules/";
     function pathContainsNodeModules(path) {
@@ -21883,15 +21961,15 @@ var ts;
         }
         return path + "/index.d.ts";
     }
-    function loadModuleFromFileNoPackageId(extensions, candidate, onlyRecordFailures, state) {
-        return noPackageId(loadModuleFromFile(extensions, candidate, onlyRecordFailures, state));
+    function loadModuleFromFileNoPackageId(parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
+        return noPackageId(loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state));
     }
-    function loadModuleFromFile(extensions, candidate, onlyRecordFailures, state) {
+    function loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
         if (extensions === Extensions.Json || extensions === Extensions.TSConfig) {
             var extensionLess = ts.tryRemoveExtension(candidate, ".json");
-            return (extensionLess === undefined && extensions === Extensions.Json) ? undefined : tryAddingExtensions(extensionLess || candidate, extensions, onlyRecordFailures, state);
+            return (extensionLess === undefined && extensions === Extensions.Json) ? undefined : tryAddingExtensions(parentFileExtension, extensionLess || candidate, extensions, onlyRecordFailures, state);
         }
-        var resolvedByAddingExtension = tryAddingExtensions(candidate, extensions, onlyRecordFailures, state);
+        var resolvedByAddingExtension = tryAddingExtensions(parentFileExtension, candidate, extensions, onlyRecordFailures, state);
         if (resolvedByAddingExtension) {
             return resolvedByAddingExtension;
         }
@@ -21901,26 +21979,222 @@ var ts;
                 var extension = candidate.substring(extensionless.length);
                 trace(state.host, ts.Diagnostics.File_name_0_has_a_1_extension_stripping_it, candidate, extension);
             }
-            return tryAddingExtensions(extensionless, extensions, onlyRecordFailures, state);
+            return tryAddingExtensions(parentFileExtension, extensionless, extensions, onlyRecordFailures, state);
         }
     }
-    function tryAddingExtensions(candidate, extensions, onlyRecordFailures, state) {
+    function tryAddingExtensions(parentFileExtension, candidate, extensions, onlyRecordFailures, state) {
         if (!onlyRecordFailures) {
             var directory = ts.getDirectoryPath(candidate);
             if (directory) {
                 onlyRecordFailures = !ts.directoryProbablyExists(directory, state.host);
             }
         }
-        switch (extensions) {
-            case Extensions.DtsOnly:
-                return tryExtension(".d.ts");
-            case Extensions.TypeScript:
-                return tryExtension(".ts") || tryExtension(".tsx") || tryExtension(".d.ts");
-            case Extensions.JavaScript:
-                return tryExtension(".js") || tryExtension(".jsx");
-            case Extensions.TSConfig:
-            case Extensions.Json:
-                return tryExtension(".json");
+        switch (parentFileExtension) {
+            case ".web.ts":
+            case ".web.tsx":
+            case ".web.js":
+            case ".web.jsx": {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts");
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".web.json") ||
+                            tryExtension(".json"));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".web.js") ||
+                            tryExtension(".web.jsx") ||
+                            tryExtension(".js") ||
+                            tryExtension(".jsx"));
+                    }
+                    default: {
+                        return (tryExtension(".web.ts") ||
+                            tryExtension(".web.tsx") ||
+                            tryExtension(".ts") ||
+                            tryExtension(".tsx") ||
+                            tryExtension(".d.ts"));
+                    }
+                }
+            }
+            case ".native.js":
+            case ".native.jsx":
+            case ".native.ts":
+            case ".native.tsx": {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts");
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".json") ||
+                            tryExtension(".native.json") ||
+                            tryExtension(".ios.json") ||
+                            tryExtension(".android.json"));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".js") ||
+                            tryExtension(".jsx") ||
+                            tryExtension(".native.js") ||
+                            tryExtension(".native.jsx") ||
+                            tryExtension(".ios.js") ||
+                            tryExtension(".ios.jsx") ||
+                            tryExtension(".android.js") ||
+                            tryExtension(".android.jsx"));
+                    }
+                    default: {
+                        return (tryExtension(".native.ts") ||
+                            tryExtension(".native.tsx") ||
+                            tryExtension(".ios.ts") ||
+                            tryExtension(".ios.tsx") ||
+                            tryExtension(".android.ts") ||
+                            tryExtension(".android.tsx") ||
+                            tryExtension(".ts") ||
+                            tryExtension(".tsx") ||
+                            tryExtension(".d.ts"));
+                    }
+                }
+            }
+            case ".ios.js":
+            case ".ios.jsx":
+            case ".ios.ts":
+            case ".ios.tsx": {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts");
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".ios.json") ||
+                            tryExtension(".native.json") ||
+                            tryExtension(".json"));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".ios.js") ||
+                            tryExtension(".ios.jsx") ||
+                            tryExtension(".native.js") ||
+                            tryExtension(".native.jsx") ||
+                            tryExtension(".js") ||
+                            tryExtension(".jsx"));
+                    }
+                    default: {
+                        return (tryExtension(".ios.ts") ||
+                            tryExtension(".ios.tsx") ||
+                            tryExtension(".native.ts") ||
+                            tryExtension(".native.tsx") ||
+                            tryExtension(".ts") ||
+                            tryExtension(".tsx") ||
+                            tryExtension(".d.ts"));
+                    }
+                }
+            }
+            case ".android.js":
+            case ".android.jsx":
+            case ".android.ts":
+            case ".android.tsx": {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts");
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".android.json") ||
+                            tryExtension(".native.json") ||
+                            tryExtension(".json"));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".android.js") ||
+                            tryExtension(".android.jsx") ||
+                            tryExtension(".native.js") ||
+                            tryExtension(".native.jsx") ||
+                            tryExtension(".js") ||
+                            tryExtension(".jsx"));
+                    }
+                    default: {
+                        return (tryExtension(".android.ts") ||
+                            tryExtension(".android.tsx") ||
+                            tryExtension(".native.ts") ||
+                            tryExtension(".native.tsx") ||
+                            tryExtension(".ts") ||
+                            tryExtension(".tsx") ||
+                            tryExtension(".d.ts"));
+                    }
+                }
+            }
+            case ".node.js":
+            case ".node.jsx":
+            case ".node.ts":
+            case ".node.tsx": {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts");
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".node.json") ||
+                            tryExtension(".json"));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".node.js") ||
+                            tryExtension(".node.jsx") ||
+                            tryExtension(".js") ||
+                            tryExtension(".jsx"));
+                    }
+                    default: {
+                        return (tryExtension(".node.ts") ||
+                            tryExtension(".node.tsx") ||
+                            tryExtension(".ts") ||
+                            tryExtension(".tsx") ||
+                            tryExtension(".d.ts"));
+                    }
+                }
+            }
+            default: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts");
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".json") ||
+                            tryExtension(".node.json") ||
+                            tryExtension(".web.json") ||
+                            tryExtension(".native.json") ||
+                            tryExtension(".ios.json") ||
+                            tryExtension(".android.json"));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".js") ||
+                            tryExtension(".jsx") ||
+                            tryExtension(".node.js") ||
+                            tryExtension(".node.jsx") ||
+                            tryExtension(".web.js") ||
+                            tryExtension(".web.jsx") ||
+                            tryExtension(".native.js") ||
+                            tryExtension(".native.jsx") ||
+                            tryExtension(".ios.js") ||
+                            tryExtension(".ios.jsx") ||
+                            tryExtension(".android.js") ||
+                            tryExtension(".android.jsx"));
+                    }
+                    default: {
+                        return (tryExtension(".ts") ||
+                            tryExtension(".tsx") ||
+                            tryExtension(".d.ts") ||
+                            tryExtension(".node.ts") ||
+                            tryExtension(".node.tsx") ||
+                            tryExtension(".web.ts") ||
+                            tryExtension(".web.tsx") ||
+                            tryExtension(".native.ts") ||
+                            tryExtension(".native.tsx") ||
+                            tryExtension(".ios.ts") ||
+                            tryExtension(".ios.tsx") ||
+                            tryExtension(".android.ts") ||
+                            tryExtension(".android.tsx"));
+                    }
+                }
+            }
         }
         function tryExtension(ext) {
             var path = tryFile(candidate + ext, onlyRecordFailures, state);
@@ -21944,15 +22218,15 @@ var ts;
         state.failedLookupLocations.push(fileName);
         return undefined;
     }
-    function loadNodeModuleFromDirectory(extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
+    function loadNodeModuleFromDirectory(parentFileExtension, extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
         if (considerPackageJson === void 0) { considerPackageJson = true; }
-        var packageInfo = considerPackageJson ? getPackageJsonInfo(candidate, "", onlyRecordFailures, state) : undefined;
+        var packageInfo = considerPackageJson ? getPackageJsonInfo(parentFileExtension, candidate, "", onlyRecordFailures, state) : undefined;
         var packageId = packageInfo && packageInfo.packageId;
         var packageJsonContent = packageInfo && packageInfo.packageJsonContent;
         var versionPaths = packageJsonContent && readPackageJsonTypesVersionPaths(packageJsonContent, state);
-        return withPackageId(packageId, loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths));
+        return withPackageId(packageId, loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths));
     }
-    function getPackageJsonInfo(packageDirectory, subModuleName, onlyRecordFailures, state) {
+    function getPackageJsonInfo(parentFileExtension, packageDirectory, subModuleName, onlyRecordFailures, state) {
         var host = state.host, traceEnabled = state.traceEnabled;
         var directoryExists = !onlyRecordFailures && ts.directoryProbablyExists(packageDirectory, host);
         var packageJsonPath = ts.combinePaths(packageDirectory, "package.json");
@@ -21964,7 +22238,34 @@ var ts;
                     subModuleName = addExtensionAndIndex(path.substring(packageDirectory.length + 1));
                 }
                 else {
-                    var jsPath = readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                    var jsPath = void 0;
+                    switch (parentFileExtension) {
+                        case ".android.js":
+                        case ".ios.js":
+                        case ".native.js":
+                        case ".android.jsx":
+                        case ".ios.jsx":
+                        case ".native.jsx":
+                        case ".android.ts":
+                        case ".ios.ts":
+                        case ".native.ts":
+                        case ".android.tsx":
+                        case ".ios.tsx":
+                        case ".native.tsx": {
+                            jsPath = readPackageJsonReactNativeField(packageJsonContent, packageDirectory, state) || readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                            break;
+                        }
+                        case ".web.js":
+                        case ".web.jsx":
+                        case ".web.ts":
+                        case ".web.tsx": {
+                            jsPath = readPackageJsonBrowserField(packageJsonContent, packageDirectory, state) || readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                            break;
+                        }
+                        default: {
+                            jsPath = readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                        }
+                    }
                     if (typeof jsPath === "string" && jsPath.length > packageDirectory.length) {
                         var potentialSubModule_1 = jsPath.substring(packageDirectory.length + 1);
                         subModuleName = (ts.forEach(ts.supportedJSExtensions, function (extension) {
@@ -21981,7 +22282,7 @@ var ts;
             }
             var versionPaths = readPackageJsonTypesVersionPaths(packageJsonContent, state);
             var packageId = typeof packageJsonContent.name === "string" && typeof packageJsonContent.version === "string"
-                ? { name: packageJsonContent.name, subModuleName: subModuleName, version: packageJsonContent.version }
+                ? { name: packageJsonContent.name + "|" + parentFileExtension, subModuleName: subModuleName, version: packageJsonContent.version }
                 : undefined;
             if (traceEnabled) {
                 if (packageId) {
@@ -22000,17 +22301,78 @@ var ts;
             state.failedLookupLocations.push(packageJsonPath);
         }
     }
-    function loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, jsonContent, versionPaths) {
+    function loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, onlyRecordFailures, state, jsonContent, versionPaths) {
         var packageFile;
         if (jsonContent) {
             switch (extensions) {
                 case Extensions.JavaScript:
-                case Extensions.Json:
-                    packageFile = readPackageJsonMainField(jsonContent, candidate, state);
+                case Extensions.Json: {
+                    switch (parentFileExtension) {
+                        case ".android.js":
+                        case ".ios.js":
+                        case ".native.js":
+                        case ".android.jsx":
+                        case ".ios.jsx":
+                        case ".native.jsx":
+                        case ".android.ts":
+                        case ".ios.ts":
+                        case ".native.ts":
+                        case ".android.tsx":
+                        case ".ios.tsx":
+                        case ".native.tsx": {
+                            packageFile = readPackageJsonReactNativeField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        case ".web.js":
+                        case ".web.jsx":
+                        case ".web.ts":
+                        case ".web.tsx": {
+                            packageFile = readPackageJsonBrowserField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        default: {
+                            packageFile = readPackageJsonMainField(jsonContent, candidate, state);
+                        }
+                    }
                     break;
-                case Extensions.TypeScript:
-                    packageFile = readPackageJsonTypesFields(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                }
+                case Extensions.TypeScript: {
+                    switch (parentFileExtension) {
+                        case ".android.js":
+                        case ".ios.js":
+                        case ".native.js":
+                        case ".android.jsx":
+                        case ".ios.jsx":
+                        case ".native.jsx":
+                        case ".android.ts":
+                        case ".ios.ts":
+                        case ".native.ts":
+                        case ".android.tsx":
+                        case ".ios.tsx":
+                        case ".native.tsx": {
+                            packageFile = readPackageJsonReactNativeField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        case ".web.js":
+                        case ".web.jsx":
+                        case ".web.ts":
+                        case ".web.tsx": {
+                            packageFile = readPackageJsonBrowserField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        case ".node.js":
+                        case ".node.jsx":
+                        case ".node.ts":
+                        case ".node.tsx": {
+                            packageFile = readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        default: {
+                            packageFile = readPackageJsonTypesFields(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                        }
+                    }
                     break;
+                }
                 case Extensions.DtsOnly:
                     packageFile = readPackageJsonTypesFields(jsonContent, candidate, state);
                     break;
@@ -22021,7 +22383,7 @@ var ts;
                     return ts.Debug.assertNever(extensions);
             }
         }
-        var loader = function (extensions, candidate, onlyRecordFailures, state) {
+        var loader = function (parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
             var fromFile = tryFile(candidate, onlyRecordFailures, state);
             if (fromFile) {
                 var resolved = resolvedIfExtensionMatches(extensions, fromFile);
@@ -22033,7 +22395,7 @@ var ts;
                 }
             }
             var nextExtensions = extensions === Extensions.DtsOnly ? Extensions.TypeScript : extensions;
-            return nodeLoadModuleByRelativeName(nextExtensions, candidate, onlyRecordFailures, state, false);
+            return nodeLoadModuleByRelativeName(parentFileExtension, nextExtensions, candidate, onlyRecordFailures, state, false);
         };
         var onlyRecordFailuresForPackageFile = packageFile ? !ts.directoryProbablyExists(ts.getDirectoryPath(packageFile), state.host) : undefined;
         var onlyRecordFailuresForIndex = onlyRecordFailures || !ts.directoryProbablyExists(candidate, state.host);
@@ -22043,15 +22405,15 @@ var ts;
             if (state.traceEnabled) {
                 trace(state.host, ts.Diagnostics.package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2, versionPaths.version, ts.version, moduleName);
             }
-            var result = tryLoadModuleUsingPaths(extensions, moduleName, candidate, versionPaths.paths, loader, onlyRecordFailuresForPackageFile || onlyRecordFailuresForIndex, state);
+            var result = tryLoadModuleUsingPaths(parentFileExtension, extensions, moduleName, candidate, versionPaths.paths, loader, onlyRecordFailuresForPackageFile || onlyRecordFailuresForIndex, state);
             if (result) {
                 return removeIgnoredPackageId(result.value);
             }
         }
-        var packageFileResult = packageFile && removeIgnoredPackageId(loader(extensions, packageFile, onlyRecordFailuresForPackageFile, state));
+        var packageFileResult = packageFile && removeIgnoredPackageId(loader(parentFileExtension, extensions, packageFile, onlyRecordFailuresForPackageFile, state));
         if (packageFileResult)
             return packageFileResult;
-        return loadModuleFromFile(extensions, indexPath, onlyRecordFailuresForIndex, state);
+        return loadModuleFromFile(parentFileExtension, extensions, indexPath, onlyRecordFailuresForIndex, state);
     }
     function resolvedIfExtensionMatches(extensions, path) {
         var ext = ts.tryGetExtensionFromPath(path);
@@ -22060,12 +22422,40 @@ var ts;
     function extensionIsOk(extensions, extension) {
         switch (extensions) {
             case Extensions.JavaScript:
-                return extension === ".js" || extension === ".jsx";
+                return (extension === ".js" ||
+                    extension === ".jsx" ||
+                    extension === ".node.js" ||
+                    extension === ".node.jsx" ||
+                    extension === ".web.js" ||
+                    extension === ".web.jsx" ||
+                    extension === ".native.js" ||
+                    extension === ".native.jsx" ||
+                    extension === ".ios.js" ||
+                    extension === ".ios.jsx" ||
+                    extension === ".android.js" ||
+                    extension === ".android.jsx");
             case Extensions.TSConfig:
             case Extensions.Json:
-                return extension === ".json";
+                return (extension === ".json" ||
+                    extension === ".node.json" ||
+                    extension === ".web.json" ||
+                    extension === ".native.json" ||
+                    extension === ".ios.json" ||
+                    extension === ".android.json");
             case Extensions.TypeScript:
-                return extension === ".ts" || extension === ".tsx" || extension === ".d.ts";
+                return (extension === ".ts" ||
+                    extension === ".tsx" ||
+                    extension === ".d.ts" ||
+                    extension === ".node.ts" ||
+                    extension === ".node.tsx" ||
+                    extension === ".web.ts" ||
+                    extension === ".web.tsx" ||
+                    extension === ".native.ts" ||
+                    extension === ".native.tsx" ||
+                    extension === ".ios.ts" ||
+                    extension === ".ios.tsx" ||
+                    extension === ".android.ts" ||
+                    extension === ".android.tsx");
             case Extensions.DtsOnly:
                 return extension === ".d.ts";
         }
@@ -22078,31 +22468,32 @@ var ts;
         return idx === -1 ? { packageName: moduleName, rest: "" } : { packageName: moduleName.slice(0, idx), rest: moduleName.slice(idx + 1) };
     }
     ts.parsePackageName = parsePackageName;
-    function loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, directory, state, cache, redirectedReference) {
-        return loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName, directory, state, false, cache, redirectedReference);
+    function loadModuleFromNearestNodeModulesDirectory(parentFileExtension, extensions, moduleName, directory, state, cache, redirectedReference) {
+        return loadModuleFromNearestNodeModulesDirectoryWorker(parentFileExtension, extensions, moduleName, directory, state, false, cache, redirectedReference);
     }
     function loadModuleFromNearestNodeModulesDirectoryTypesScope(moduleName, directory, state) {
-        return loadModuleFromNearestNodeModulesDirectoryWorker(Extensions.DtsOnly, moduleName, directory, state, true, undefined, undefined);
+        return loadModuleFromNearestNodeModulesDirectoryWorker(".ts", Extensions.DtsOnly, moduleName, directory, state, true, undefined, undefined);
     }
-    function loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
-        var perModuleNameCache = cache && cache.getOrCreateCacheForModuleName(moduleName, redirectedReference);
+    function loadModuleFromNearestNodeModulesDirectoryWorker(parentFileExtension, extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
+        var moduleNameKey = moduleName + "|" + parentFileExtension;
+        var perModuleNameCache = cache && cache.getOrCreateCacheForModuleName(moduleNameKey, redirectedReference);
         return ts.forEachAncestorDirectory(ts.normalizeSlashes(directory), function (ancestorDirectory) {
             if (ts.getBaseFileName(ancestorDirectory) !== "node_modules") {
                 var resolutionFromCache = tryFindNonRelativeModuleNameInCache(perModuleNameCache, moduleName, ancestorDirectory, state);
                 if (resolutionFromCache) {
                     return resolutionFromCache;
                 }
-                return toSearchResult(loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, ancestorDirectory, state, typesScopeOnly));
+                return toSearchResult(loadModuleFromImmediateNodeModulesDirectory(parentFileExtension, extensions, moduleName, ancestorDirectory, state, typesScopeOnly));
             }
         });
     }
-    function loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, directory, state, typesScopeOnly) {
+    function loadModuleFromImmediateNodeModulesDirectory(parentFileExtension, extensions, moduleName, directory, state, typesScopeOnly) {
         var nodeModulesFolder = ts.combinePaths(directory, "node_modules");
         var nodeModulesFolderExists = ts.directoryProbablyExists(nodeModulesFolder, state.host);
         if (!nodeModulesFolderExists && state.traceEnabled) {
             trace(state.host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, nodeModulesFolder);
         }
-        var packageResult = typesScopeOnly ? undefined : loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesFolder, nodeModulesFolderExists, state);
+        var packageResult = typesScopeOnly ? undefined : loadModuleFromSpecificNodeModulesDirectory(parentFileExtension, extensions, moduleName, nodeModulesFolder, nodeModulesFolderExists, state);
         if (packageResult) {
             return packageResult;
         }
@@ -22115,33 +22506,33 @@ var ts;
                 }
                 nodeModulesAtTypesExists = false;
             }
-            return loadModuleFromSpecificNodeModulesDirectory(Extensions.DtsOnly, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes_1, nodeModulesAtTypesExists, state);
+            return loadModuleFromSpecificNodeModulesDirectory(parentFileExtension, Extensions.DtsOnly, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes_1, nodeModulesAtTypesExists, state);
         }
     }
-    function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state) {
+    function loadModuleFromSpecificNodeModulesDirectory(parentFileExtension, extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state) {
         var candidate = ts.normalizePath(ts.combinePaths(nodeModulesDirectory, moduleName));
         var packageJsonContent;
         var packageId;
         var versionPaths;
-        var packageInfo = getPackageJsonInfo(candidate, "", !nodeModulesDirectoryExists, state);
+        var packageInfo = getPackageJsonInfo(parentFileExtension, candidate, "", !nodeModulesDirectoryExists, state);
         if (packageInfo) {
             (packageJsonContent = packageInfo.packageJsonContent, packageId = packageInfo.packageId, versionPaths = packageInfo.versionPaths);
-            var fromFile = loadModuleFromFile(extensions, candidate, !nodeModulesDirectoryExists, state);
+            var fromFile = loadModuleFromFile(parentFileExtension, extensions, candidate, !nodeModulesDirectoryExists, state);
             if (fromFile) {
                 return noPackageId(fromFile);
             }
-            var fromDirectory = loadNodeModuleFromDirectoryWorker(extensions, candidate, !nodeModulesDirectoryExists, state, packageJsonContent, versionPaths);
+            var fromDirectory = loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, !nodeModulesDirectoryExists, state, packageJsonContent, versionPaths);
             return withPackageId(packageId, fromDirectory);
         }
-        var loader = function (extensions, candidate, onlyRecordFailures, state) {
-            var pathAndExtension = loadModuleFromFile(extensions, candidate, onlyRecordFailures, state) ||
-                loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths);
+        var loader = function (parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
+            var pathAndExtension = loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state) ||
+                loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths);
             return withPackageId(packageId, pathAndExtension);
         };
         var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;
         if (rest !== "") {
             var packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
-            var packageInfo_1 = getPackageJsonInfo(packageDirectory, rest, !nodeModulesDirectoryExists, state);
+            var packageInfo_1 = getPackageJsonInfo(parentFileExtension, packageDirectory, rest, !nodeModulesDirectoryExists, state);
             if (packageInfo_1)
                 (packageId = packageInfo_1.packageId, versionPaths = packageInfo_1.versionPaths);
             if (versionPaths) {
@@ -22149,15 +22540,15 @@ var ts;
                     trace(state.host, ts.Diagnostics.package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2, versionPaths.version, ts.version, rest);
                 }
                 var packageDirectoryExists = nodeModulesDirectoryExists && ts.directoryProbablyExists(packageDirectory, state.host);
-                var fromPaths = tryLoadModuleUsingPaths(extensions, rest, packageDirectory, versionPaths.paths, loader, !packageDirectoryExists, state);
+                var fromPaths = tryLoadModuleUsingPaths(parentFileExtension, extensions, rest, packageDirectory, versionPaths.paths, loader, !packageDirectoryExists, state);
                 if (fromPaths) {
                     return fromPaths.value;
                 }
             }
         }
-        return loader(extensions, candidate, !nodeModulesDirectoryExists, state);
+        return loader(parentFileExtension, extensions, candidate, !nodeModulesDirectoryExists, state);
     }
-    function tryLoadModuleUsingPaths(extensions, moduleName, baseDirectory, paths, loader, onlyRecordFailures, state) {
+    function tryLoadModuleUsingPaths(parentFileExtension, extensions, moduleName, baseDirectory, paths, loader, onlyRecordFailures, state) {
         var matchedPattern = ts.matchPatternOrExact(ts.getOwnKeys(paths), moduleName);
         if (matchedPattern) {
             var matchedStar_1 = ts.isString(matchedPattern) ? undefined : ts.matchedText(matchedPattern, moduleName);
@@ -22178,7 +22569,7 @@ var ts;
                         return noPackageId({ path: path_1, ext: extension });
                     }
                 }
-                return loader(extensions, candidate, onlyRecordFailures || !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
+                return loader(parentFileExtension, extensions, candidate, onlyRecordFailures || !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
             });
             return { value: resolved };
         }
@@ -22230,7 +22621,7 @@ var ts;
             return { value: result.resolvedModule && { path: result.resolvedModule.resolvedFileName, originalPath: result.resolvedModule.originalPath || true, extension: result.resolvedModule.extension, packageId: result.resolvedModule.packageId } };
         }
     }
-    function classicNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
+    function classicNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
         var traceEnabled = isTraceEnabled(compilerOptions, host);
         var failedLookupLocations = [];
         var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations };
@@ -22238,7 +22629,7 @@ var ts;
         var resolved = tryResolve(Extensions.TypeScript) || tryResolve(Extensions.JavaScript);
         return createResolvedModuleWithFailedLookupLocations(resolved && resolved.value, false, failedLookupLocations);
         function tryResolve(extensions) {
-            var resolvedUsingSettings = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loadModuleFromFileNoPackageId, state);
+            var resolvedUsingSettings = tryLoadModuleUsingOptionalResolutionSettings(parentFileExtension, extensions, moduleName, containingDirectory, loadModuleFromFileNoPackageId, state);
             if (resolvedUsingSettings) {
                 return { value: resolvedUsingSettings };
             }
@@ -22250,7 +22641,7 @@ var ts;
                         return resolutionFromCache;
                     }
                     var searchName = ts.normalizePath(ts.combinePaths(directory, moduleName));
-                    return toSearchResult(loadModuleFromFileNoPackageId(extensions, searchName, false, state));
+                    return toSearchResult(loadModuleFromFileNoPackageId(parentFileExtension, extensions, searchName, false, state));
                 });
                 if (resolved_3) {
                     return resolved_3;
@@ -22261,19 +22652,20 @@ var ts;
             }
             else {
                 var candidate = ts.normalizePath(ts.combinePaths(containingDirectory, moduleName));
-                return toSearchResult(loadModuleFromFileNoPackageId(extensions, candidate, false, state));
+                return toSearchResult(loadModuleFromFileNoPackageId(parentFileExtension, extensions, candidate, false, state));
             }
         }
     }
     ts.classicNameResolver = classicNameResolver;
-    function loadModuleFromGlobalCache(moduleName, projectName, compilerOptions, host, globalCache) {
+    function loadModuleFromGlobalCache(moduleName, containingFile, projectName, compilerOptions, host, globalCache) {
         var traceEnabled = isTraceEnabled(compilerOptions, host);
         if (traceEnabled) {
             trace(host, ts.Diagnostics.Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2, projectName, moduleName, globalCache);
         }
         var failedLookupLocations = [];
         var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations };
-        var resolved = loadModuleFromImmediateNodeModulesDirectory(Extensions.DtsOnly, moduleName, globalCache, state, false);
+        var parentFileContext = ts.getFileExtension(containingFile);
+        var resolved = loadModuleFromImmediateNodeModulesDirectory(parentFileContext, Extensions.DtsOnly, moduleName, globalCache, state, false);
         return createResolvedModuleWithFailedLookupLocations(resolved, true, failedLookupLocations);
     }
     ts.loadModuleFromGlobalCache = loadModuleFromGlobalCache;
@@ -74200,15 +74592,40 @@ var ts;
         var extension = _a.extension;
         switch (extension) {
             case ".ts":
+            case ".node.ts":
+            case ".web.ts":
+            case ".native.ts":
+            case ".ios.ts":
+            case ".android.ts":
             case ".d.ts":
                 return undefined;
             case ".tsx":
+            case ".node.tsx":
+            case ".web.tsx":
+            case ".native.tsx":
+            case ".ios.tsx":
+            case ".android.tsx":
                 return needJsx();
             case ".jsx":
+            case ".node.jsx":
+            case ".web.jsx":
+            case ".native.jsx":
+            case ".ios.jsx":
+            case ".android.jsx":
                 return needJsx() || needAllowJs();
             case ".js":
+            case ".node.js":
+            case ".web.js":
+            case ".native.js":
+            case ".ios.js":
+            case ".android.js":
                 return needAllowJs();
             case ".json":
+            case ".node.json":
+            case ".web.json":
+            case ".native.json":
+            case ".ios.json":
+            case ".android.json":
                 return needResolveJsonModule();
         }
         function needJsx() {
@@ -75339,7 +75756,7 @@ var ts;
             }
             var globalCache = resolutionHost.getGlobalCache();
             if (globalCache !== undefined && !ts.isExternalModuleNameRelative(moduleName) && !(primaryResult.resolvedModule && ts.extensionIsTS(primaryResult.resolvedModule.extension))) {
-                var _a = ts.loadModuleFromGlobalCache(moduleName, resolutionHost.projectName, compilerOptions, host, globalCache), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
+                var _a = ts.loadModuleFromGlobalCache(moduleName, containingFile, resolutionHost.projectName, compilerOptions, host, globalCache), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
                 if (resolvedModule) {
                     return { resolvedModule: resolvedModule, failedLookupLocations: ts.addRange(primaryResult.failedLookupLocations, failedLookupLocations) };
                 }
@@ -75348,7 +75765,9 @@ var ts;
         }
         function resolveNamesWithLocalCache(names, containingFile, redirectedReference, cache, perDirectoryCacheWithRedirects, loader, getResolutionWithResolvedFileName, shouldRetryResolution, reusedNames, logChanges) {
             var path = resolutionHost.toPath(containingFile);
-            var resolutionsInFile = cache.get(path) || cache.set(path, ts.createMap()).get(path);
+            var context = ts.getFileExtension(containingFile);
+            var pathKey = path + "|" + context;
+            var resolutionsInFile = cache.get(pathKey) || cache.set(pathKey, ts.createMap()).get(pathKey);
             var dirPath = ts.getDirectoryPath(path);
             var perDirectoryCache = perDirectoryCacheWithRedirects.getOrCreateMapOfCacheRedirects(redirectedReference);
             var perDirectoryResolution = perDirectoryCache.get(dirPath);
@@ -75367,20 +75786,21 @@ var ts;
             var seenNamesInFile = ts.createMap();
             for (var _i = 0, names_2 = names; _i < names_2.length; _i++) {
                 var name = names_2[_i];
-                var resolution = resolutionsInFile.get(name);
-                if (!seenNamesInFile.has(name) &&
+                var nameKey = name + "|" + context;
+                var resolution = resolutionsInFile.get(nameKey);
+                if (!seenNamesInFile.has(nameKey) &&
                     allFilesHaveInvalidatedResolution || unmatchedRedirects || !resolution || resolution.isInvalidated ||
                     (hasInvalidatedNonRelativeUnresolvedImport && !ts.isExternalModuleNameRelative(name) && shouldRetryResolution(resolution))) {
                     var existingResolution = resolution;
-                    var resolutionInDirectory = perDirectoryResolution.get(name);
+                    var resolutionInDirectory = perDirectoryResolution.get(nameKey);
                     if (resolutionInDirectory) {
                         resolution = resolutionInDirectory;
                     }
                     else {
                         resolution = loader(name, containingFile, compilerOptions, resolutionHost, redirectedReference);
-                        perDirectoryResolution.set(name, resolution);
+                        perDirectoryResolution.set(nameKey, resolution);
                     }
-                    resolutionsInFile.set(name, resolution);
+                    resolutionsInFile.set(nameKey, resolution);
                     watchFailedLookupLocationsOfExternalModuleResolutions(name, resolution);
                     if (existingResolution) {
                         stopWatchFailedLookupLocationOfResolution(existingResolution);
@@ -75391,13 +75811,14 @@ var ts;
                     }
                 }
                 ts.Debug.assert(resolution !== undefined && !resolution.isInvalidated);
-                seenNamesInFile.set(name, true);
+                seenNamesInFile.set(nameKey, true);
                 resolvedModules.push(getResolutionWithResolvedFileName(resolution));
             }
-            resolutionsInFile.forEach(function (resolution, name) {
-                if (!seenNamesInFile.has(name) && !ts.contains(reusedNames, name)) {
+            resolutionsInFile.forEach(function (resolution, nameKey) {
+                var name = nameKey.split('|')[0];
+                if (!seenNamesInFile.has(nameKey) && !ts.contains(reusedNames, name)) {
                     stopWatchFailedLookupLocationOfResolution(resolution);
-                    resolutionsInFile.delete(name);
+                    resolutionsInFile.delete(nameKey);
                 }
             });
             return resolvedModules;
@@ -76086,11 +76507,46 @@ var ts;
                 case ".ts":
                 case ".d.ts":
                     return ".js";
+                case ".node.ts":
+                    return ".node.js";
+                case ".web.ts":
+                    return ".web.js";
+                case ".native.ts":
+                    return ".native.js";
+                case ".ios.ts":
+                    return ".ios.js";
+                case ".android.ts":
+                    return ".android.js";
                 case ".tsx":
                     return options.jsx === 1 ? ".jsx" : ".js";
+                case ".node.tsx":
+                    return options.jsx === 1 ? ".node.jsx" : ".node.js";
+                case ".web.tsx":
+                    return options.jsx === 1 ? ".web.jsx" : ".web.js";
+                case ".native.tsx":
+                    return options.jsx === 1 ? ".native.jsx" : ".native.js";
+                case ".ios.tsx":
+                    return options.jsx === 1 ? ".ios.jsx" : ".ios.js";
+                case ".android.tsx":
+                    return options.jsx === 1 ? ".android.jsx" : ".android.js";
                 case ".js":
                 case ".jsx":
+                case ".node.js":
+                case ".node.jsx":
+                case ".web.js":
+                case ".web.jsx":
+                case ".native.js":
+                case ".native.jsx":
+                case ".ios.js":
+                case ".ios.jsx":
+                case ".android.js":
+                case ".android.jsx":
                 case ".json":
+                case ".node.json":
+                case ".web.json":
+                case ".native.json":
+                case ".ios.json":
+                case ".android.json":
                     return ext;
                 case ".tsbuildinfo":
                     return ts.Debug.fail("Extension " + ".tsbuildinfo" + " is unsupported:: FileName:: " + fileName);
diff --git a/lib/tsserver.js b/lib/tsserver.js
index 86ff8c0789..ea6dd3d4e4 100644
--- a/lib/tsserver.js
+++ b/lib/tsserver.js
@@ -3843,12 +3843,37 @@ var ts;
     var Extension;
     (function (Extension) {
         Extension["Ts"] = ".ts";
+        Extension["IosTs"] = ".ios.ts";
+        Extension["AndroidTs"] = ".android.ts";
+        Extension["NativeTs"] = ".native.ts";
+        Extension["WebTs"] = ".web.ts";
+        Extension["NodeTs"] = ".node.ts";
         Extension["Tsx"] = ".tsx";
+        Extension["IosTsx"] = ".ios.tsx";
+        Extension["AndroidTsx"] = ".android.tsx";
+        Extension["NativeTsx"] = ".native.tsx";
+        Extension["WebTsx"] = ".web.tsx";
+        Extension["NodeTsx"] = ".node.tsx";
         Extension["Dts"] = ".d.ts";
         Extension["Js"] = ".js";
+        Extension["IosJs"] = ".ios.js";
+        Extension["AndroidJs"] = ".android.js";
+        Extension["NativeJs"] = ".native.js";
+        Extension["WebJs"] = ".web.js";
+        Extension["NodeJs"] = ".node.js";
         Extension["Jsx"] = ".jsx";
         Extension["Json"] = ".json";
         Extension["TsBuildInfo"] = ".tsbuildinfo";
+        Extension["IosJsx"] = ".ios.jsx";
+        Extension["AndroidJsx"] = ".android.jsx";
+        Extension["NativeJsx"] = ".native.jsx";
+        Extension["WebJsx"] = ".web.jsx";
+        Extension["NodeJsx"] = ".node.jsx";
+        Extension["IosJson"] = ".ios.json";
+        Extension["AndroidJson"] = ".android.json";
+        Extension["NativeJson"] = ".native.json";
+        Extension["WebJson"] = ".web.json";
+        Extension["NodeJson"] = ".node.json";
     })(Extension = ts.Extension || (ts.Extension = {}));
     /* @internal */
     var TransformFlags;
@@ -5037,7 +5062,21 @@ var ts;
             }
             function realpath(path) {
                 try {
-                    return _fs.realpathSync(path);
+                    var regexp = /\.([^\/]+?)$/;
+                    var match = path.match(regexp);
+                    var rpath = _fs.realpathSync(path);
+                    if (match !== null) {
+                        var ext = match[1];
+                        var rmatch = rpath.match(regexp);
+                        if (rmatch !== null) {
+                            var rext = rmatch[1];
+                            if (ext !== rext) {
+                                return rpath.replace(new RegExp(rext + "$"), ext);
+                            }
+                            return rpath;
+                        }
+                    }
+                    return rpath;
                 }
                 catch (_a) {
                     return path;
@@ -12053,7 +12092,7 @@ var ts;
     }
     /** Return ".ts", ".d.ts", or ".tsx", if that is the extension. */
     function tryExtractTSExtension(fileName) {
-        return ts.find(ts.supportedTSExtensionsForExtractExtension, function (extension) { return ts.fileExtensionIs(fileName, extension); });
+        return ts.find(ts.supportedTSExtensions, function (extension) { return ts.fileExtensionIs(fileName, extension); });
     }
     ts.tryExtractTSExtension = tryExtractTSExtension;
     /**
@@ -16017,14 +16056,55 @@ var ts;
     /**
      *  List of supported extensions in order of file resolution precedence.
      */
-    ts.supportedTSExtensions = [".ts" /* Ts */, ".tsx" /* Tsx */, ".d.ts" /* Dts */];
-    ts.supportedTSExtensionsWithJson = [".ts" /* Ts */, ".tsx" /* Tsx */, ".d.ts" /* Dts */, ".json" /* Json */];
-    /** Must have ".d.ts" first because if ".ts" goes first, that will be detected as the extension instead of ".d.ts". */
-    ts.supportedTSExtensionsForExtractExtension = [".d.ts" /* Dts */, ".ts" /* Ts */, ".tsx" /* Tsx */];
-    ts.supportedJSExtensions = [".js" /* Js */, ".jsx" /* Jsx */];
-    ts.supportedJSAndJsonExtensions = [".js" /* Js */, ".jsx" /* Jsx */, ".json" /* Json */];
+    ts.supportedJsonExtensions = [
+        ".node.json" /* NodeJson */,
+        ".web.json" /* WebJson */,
+        ".native.json" /* NativeJson */,
+        ".ios.json" /* IosJson */,
+        ".android.json" /* AndroidJson */,
+        ".json" /* Json */
+    ];
+    ts.supportedTSExtensions = [
+        ".node.ts" /* NodeTs */,
+        ".node.tsx" /* NodeTsx */,
+        ".web.ts" /* WebTs */,
+        ".web.tsx" /* WebTsx */,
+        ".native.ts" /* NativeTs */,
+        ".native.tsx" /* NativeTsx */,
+        ".ios.ts" /* IosTs */,
+        ".ios.tsx" /* IosTsx */,
+        ".android.ts" /* AndroidTs */,
+        ".android.tsx" /* AndroidTsx */,
+        ".d.ts" /* Dts */,
+        ".ts" /* Ts */,
+        ".tsx" /* Tsx */
+    ];
+    ts.supportedTSExtensionsWithJson = ts.supportedTSExtensions.concat(ts.supportedJsonExtensions);
+    ts.supportedJSExtensions = [
+        ".node.js" /* NodeJs */,
+        ".node.jsx" /* NodeJsx */,
+        ".web.js" /* WebJs */,
+        ".web.jsx" /* WebJsx */,
+        ".native.js" /* NativeJs */,
+        ".native.jsx" /* NativeJsx */,
+        ".ios.js" /* IosJs */,
+        ".ios.jsx" /* IosJsx */,
+        ".android.js" /* AndroidJs */,
+        ".android.jsx" /* AndroidJsx */,
+        ".js" /* Js */,
+        ".jsx" /* Jsx */
+    ];
+    ts.supportedJSAndJsonExtensions = ts.supportedJSExtensions.concat(ts.supportedJsonExtensions);
     var allSupportedExtensions = ts.supportedTSExtensions.concat(ts.supportedJSExtensions);
-    var allSupportedExtensionsWithJson = ts.supportedTSExtensions.concat(ts.supportedJSExtensions, [".json" /* Json */]);
+    var allSupportedExtensionsWithJson = ts.supportedTSExtensions.concat(ts.supportedJSExtensions, ts.supportedJsonExtensions);
+    function getAllSupportedExtensions() {
+        return allSupportedExtensions;
+    }
+    ts.getAllSupportedExtensions = getAllSupportedExtensions;
+    function getAllSupportedExtensionsWithJson() {
+        return allSupportedExtensionsWithJson;
+    }
+    ts.getAllSupportedExtensionsWithJson = getAllSupportedExtensionsWithJson;
     function getSupportedExtensions(options, extraFileExtensions) {
         var needJsExtensions = options && options.allowJs;
         if (!extraFileExtensions || extraFileExtensions.length === 0) {
@@ -16196,7 +16276,7 @@ var ts;
     ts.positionIsSynthesized = positionIsSynthesized;
     /** True if an extension is one of the supported TypeScript extensions. */
     function extensionIsTS(ext) {
-        return ext === ".ts" /* Ts */ || ext === ".tsx" /* Tsx */ || ext === ".d.ts" /* Dts */;
+        return ts.supportedTSExtensions.indexOf(ext) !== -1;
     }
     ts.extensionIsTS = extensionIsTS;
     function resolutionExtensionIsTSOrJson(ext) {
@@ -16217,7 +16297,7 @@ var ts;
     }
     ts.isAnySupportedFileExtension = isAnySupportedFileExtension;
     function tryGetExtensionFromPath(path) {
-        return ts.find(extensionsToRemove, function (e) { return ts.fileExtensionIs(path, e); });
+        return ts.find(allSupportedExtensionsWithJson, function (e) { return ts.fileExtensionIs(path, e); });
     }
     ts.tryGetExtensionFromPath = tryGetExtensionFromPath;
     function getAnyExtensionFromPathWorker(path, extensions, stringEqualityComparer) {
@@ -16258,6 +16338,19 @@ var ts;
         files: ts.emptyArray,
         directories: ts.emptyArray
     };
+    function getFileExtension(filepath) {
+        if (typeof filepath === "undefined") {
+            return ".ts" /* Ts */;
+        }
+        for (var _i = 0, allSupportedExtensionsWithJson_1 = allSupportedExtensionsWithJson; _i < allSupportedExtensionsWithJson_1.length; _i++) {
+            var ext = allSupportedExtensionsWithJson_1[_i];
+            if (ts.endsWith(filepath, ext)) {
+                return ext;
+            }
+        }
+        return ".ts" /* Ts */;
+    }
+    ts.getFileExtension = getFileExtension;
     /**
      * patternStrings contains both pattern strings (containing "*") and regular strings.
      * Return an exact match if possible, or a pattern match, or undefined.
@@ -25621,7 +25714,7 @@ var ts;
             return extendedConfigPath;
         }
         // If the path isn't a rooted or relative path, resolve like a module
-        var resolved = ts.nodeModuleNameResolver(extendedConfig, ts.combinePaths(basePath, "tsconfig.json"), { moduleResolution: ts.ModuleResolutionKind.NodeJs }, host, /*cache*/ undefined, /*projectRefs*/ undefined, /*lookupConfig*/ true);
+        var resolved = ts.nodeModuleNameResolver(".ts" /* Ts */, extendedConfig, ts.combinePaths(basePath, "tsconfig.json"), { moduleResolution: ts.ModuleResolutionKind.NodeJs }, host, /*cache*/ undefined, /*projectRefs*/ undefined, /*lookupConfig*/ true);
         if (resolved.resolvedModule) {
             return resolved.resolvedModule.resolvedFileName;
         }
@@ -26200,6 +26293,12 @@ var ts;
     function readPackageJsonMainField(jsonContent, baseDirectory, state) {
         return readPackageJsonPathField(jsonContent, "main", baseDirectory, state);
     }
+    function readPackageJsonReactNativeField(jsonContent, baseDirectory, state) {
+        return readPackageJsonPathField(jsonContent, "react-native", baseDirectory, state);
+    }
+    function readPackageJsonBrowserField(jsonContent, baseDirectory, state) {
+        return readPackageJsonPathField(jsonContent, "browser", baseDirectory, state);
+    }
     function readPackageJsonTypesVersionsField(jsonContent, state) {
         var typesVersions = readPackageJsonField(jsonContent, "typesVersions", "object", state);
         if (typesVersions === undefined)
@@ -26354,7 +26453,7 @@ var ts;
                     if (!directoryExists && traceEnabled) {
                         trace(host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, candidateDirectory);
                     }
-                    return resolvedTypeScriptOnly(loadNodeModuleFromDirectory(Extensions.DtsOnly, candidate, !directoryExists, moduleResolutionState));
+                    return resolvedTypeScriptOnly(loadNodeModuleFromDirectory(".ts" /* Ts */, Extensions.DtsOnly, candidate, !directoryExists, moduleResolutionState));
                 });
             }
             else {
@@ -26372,12 +26471,12 @@ var ts;
                 }
                 var result = void 0;
                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {
-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
+                    var searchResult = loadModuleFromNearestNodeModulesDirectory(".ts" /* Ts */, Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
                     result = searchResult && searchResult.value;
                 }
                 else {
                     var candidate = ts.normalizePathAndParts(ts.combinePaths(initialLocationForSecondaryLookup, typeReferenceDirectiveName)).path;
-                    result = nodeLoadModuleByRelativeName(Extensions.DtsOnly, candidate, /*onlyRecordFailures*/ false, moduleResolutionState, /*considerPackageJson*/ true);
+                    result = nodeLoadModuleByRelativeName(".ts" /* Ts */, Extensions.DtsOnly, candidate, /*onlyRecordFailures*/ false, moduleResolutionState, /*considerPackageJson*/ true);
                 }
                 var resolvedFile = resolvedTypeScriptOnly(result);
                 if (!resolvedFile && traceEnabled) {
@@ -26559,8 +26658,9 @@ var ts;
     ts.createModuleResolutionCacheWithMaps = createModuleResolutionCacheWithMaps;
     function resolveModuleNameFromCache(moduleName, containingFile, cache) {
         var containingDirectory = ts.getDirectoryPath(containingFile);
+        var parentFileExtension = ts.getFileExtension(containingFile);
         var perFolderCache = cache && cache.getOrCreateCacheForDirectory(containingDirectory);
-        return perFolderCache && perFolderCache.get(moduleName);
+        return perFolderCache && perFolderCache.get(moduleName + "|" + parentFileExtension);
     }
     ts.resolveModuleNameFromCache = resolveModuleNameFromCache;
     function resolveModuleName(moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
@@ -26575,8 +26675,10 @@ var ts;
             }
         }
         var containingDirectory = ts.getDirectoryPath(containingFile);
+        var parentFileExtension = ts.getFileExtension(containingFile);
+        var moduleNameKey = moduleName + "|" + parentFileExtension;
         var perFolderCache = cache && cache.getOrCreateCacheForDirectory(containingDirectory, redirectedReference);
-        var result = perFolderCache && perFolderCache.get(moduleName);
+        var result = perFolderCache && perFolderCache.get(moduleNameKey);
         if (result) {
             if (traceEnabled) {
                 trace(host, ts.Diagnostics.Resolution_for_module_0_was_found_in_cache_from_location_1, moduleName, containingDirectory);
@@ -26597,19 +26699,19 @@ var ts;
             }
             switch (moduleResolution) {
                 case ts.ModuleResolutionKind.NodeJs:
-                    result = nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
+                    result = nodeModuleNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
                     break;
                 case ts.ModuleResolutionKind.Classic:
-                    result = classicNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
+                    result = classicNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
                     break;
                 default:
                     return ts.Debug.fail("Unexpected moduleResolution: " + moduleResolution);
             }
             if (perFolderCache) {
-                perFolderCache.set(moduleName, result);
+                perFolderCache.set(moduleNameKey, result);
                 if (!ts.isExternalModuleNameRelative(moduleName)) {
                     // put result in per-module name cache
-                    cache.getOrCreateCacheForModuleName(moduleName, redirectedReference).set(containingDirectory, result);
+                    cache.getOrCreateCacheForModuleName(moduleNameKey, redirectedReference).set(containingDirectory, result);
                 }
             }
         }
@@ -26684,28 +26786,28 @@ var ts;
      * be converted to a path relative to found rootDir entry './content/protocols/file2' (*). As a last step compiler will check all remaining
      * entries in 'rootDirs', use them to build absolute path out of (*) and try to resolve module from this location.
      */
-    function tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loader, state) {
-        var resolved = tryLoadModuleUsingPathsIfEligible(extensions, moduleName, loader, state);
+    function tryLoadModuleUsingOptionalResolutionSettings(parentFileExtension, extensions, moduleName, containingDirectory, loader, state) {
+        var resolved = tryLoadModuleUsingPathsIfEligible(parentFileExtension, extensions, moduleName, loader, state);
         if (resolved)
             return resolved.value;
         if (!ts.isExternalModuleNameRelative(moduleName)) {
-            return tryLoadModuleUsingBaseUrl(extensions, moduleName, loader, state);
+            return tryLoadModuleUsingBaseUrl(parentFileExtension, extensions, moduleName, loader, state);
         }
         else {
-            return tryLoadModuleUsingRootDirs(extensions, moduleName, containingDirectory, loader, state);
+            return tryLoadModuleUsingRootDirs(parentFileExtension, extensions, moduleName, containingDirectory, loader, state);
         }
     }
-    function tryLoadModuleUsingPathsIfEligible(extensions, moduleName, loader, state) {
+    function tryLoadModuleUsingPathsIfEligible(parentFileExtension, extensions, moduleName, loader, state) {
         var _a = state.compilerOptions, baseUrl = _a.baseUrl, paths = _a.paths;
         if (baseUrl && paths && !ts.pathIsRelative(moduleName)) {
             if (state.traceEnabled) {
                 trace(state.host, ts.Diagnostics.baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1, baseUrl, moduleName);
                 trace(state.host, ts.Diagnostics.paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0, moduleName);
             }
-            return tryLoadModuleUsingPaths(extensions, moduleName, baseUrl, paths, loader, /*onlyRecordFailures*/ false, state);
+            return tryLoadModuleUsingPaths(parentFileExtension, extensions, moduleName, baseUrl, paths, loader, /*onlyRecordFailures*/ false, state);
         }
     }
-    function tryLoadModuleUsingRootDirs(extensions, moduleName, containingDirectory, loader, state) {
+    function tryLoadModuleUsingRootDirs(parentFileExtension, extensions, moduleName, containingDirectory, loader, state) {
         if (!state.compilerOptions.rootDirs) {
             return undefined;
         }
@@ -26743,7 +26845,7 @@ var ts;
             if (state.traceEnabled) {
                 trace(state.host, ts.Diagnostics.Loading_0_from_the_root_dir_1_candidate_location_2, suffix, matchedNormalizedPrefix, candidate);
             }
-            var resolvedFileName = loader(extensions, candidate, !ts.directoryProbablyExists(containingDirectory, state.host), state);
+            var resolvedFileName = loader(parentFileExtension, extensions, candidate, !ts.directoryProbablyExists(containingDirectory, state.host), state);
             if (resolvedFileName) {
                 return resolvedFileName;
             }
@@ -26762,7 +26864,7 @@ var ts;
                     trace(state.host, ts.Diagnostics.Loading_0_from_the_root_dir_1_candidate_location_2, suffix, rootDir, candidate_1);
                 }
                 var baseDirectory = ts.getDirectoryPath(candidate_1);
-                var resolvedFileName_1 = loader(extensions, candidate_1, !ts.directoryProbablyExists(baseDirectory, state.host), state);
+                var resolvedFileName_1 = loader(parentFileExtension, extensions, candidate_1, !ts.directoryProbablyExists(baseDirectory, state.host), state);
                 if (resolvedFileName_1) {
                     return resolvedFileName_1;
                 }
@@ -26773,7 +26875,7 @@ var ts;
         }
         return undefined;
     }
-    function tryLoadModuleUsingBaseUrl(extensions, moduleName, loader, state) {
+    function tryLoadModuleUsingBaseUrl(parentFileExtension, extensions, moduleName, loader, state) {
         var baseUrl = state.compilerOptions.baseUrl;
         if (!baseUrl) {
             return undefined;
@@ -26785,7 +26887,7 @@ var ts;
         if (state.traceEnabled) {
             trace(state.host, ts.Diagnostics.Resolving_module_name_0_relative_to_base_url_1_2, moduleName, baseUrl, candidate);
         }
-        return loader(extensions, candidate, !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
+        return loader(parentFileExtension, extensions, candidate, !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
     }
     /**
      * Expose resolution logic to allow us to use Node module resolution logic from arbitrary locations.
@@ -26794,7 +26896,7 @@ var ts;
      */
     /* @internal */
     function resolveJSModule(moduleName, initialDir, host) {
-        var _a = tryResolveJSModuleWorker(moduleName, initialDir, host), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
+        var _a = tryResolveJSModuleWorker(".ts" /* Ts */, moduleName, initialDir, host), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
         if (!resolvedModule) {
             throw new Error("Could not resolve JS module '" + moduleName + "' starting at '" + initialDir + "'. Looked in: " + failedLookupLocations.join(", "));
         }
@@ -26803,7 +26905,7 @@ var ts;
     ts.resolveJSModule = resolveJSModule;
     /* @internal */
     function tryResolveJSModule(moduleName, initialDir, host) {
-        var resolvedModule = tryResolveJSModuleWorker(moduleName, initialDir, host).resolvedModule;
+        var resolvedModule = tryResolveJSModuleWorker(".ts" /* Ts */, moduleName, initialDir, host).resolvedModule;
         return resolvedModule && resolvedModule.resolvedFileName;
     }
     ts.tryResolveJSModule = tryResolveJSModule;
@@ -26811,14 +26913,14 @@ var ts;
     var tsExtensions = [Extensions.TypeScript, Extensions.JavaScript];
     var tsPlusJsonExtensions = tsExtensions.concat([Extensions.Json]);
     var tsconfigExtensions = [Extensions.TSConfig];
-    function tryResolveJSModuleWorker(moduleName, initialDir, host) {
-        return nodeModuleNameResolverWorker(moduleName, initialDir, { moduleResolution: ts.ModuleResolutionKind.NodeJs, allowJs: true }, host, /*cache*/ undefined, jsOnlyExtensions, /*redirectedReferences*/ undefined);
+    function tryResolveJSModuleWorker(parentFileExtension, moduleName, initialDir, host) {
+        return nodeModuleNameResolverWorker(parentFileExtension, moduleName, initialDir, { moduleResolution: ts.ModuleResolutionKind.NodeJs, allowJs: true }, host, /*cache*/ undefined, jsOnlyExtensions, /*redirectedReferences*/ undefined);
     }
-    function nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference, lookupConfig) {
-        return nodeModuleNameResolverWorker(moduleName, ts.getDirectoryPath(containingFile), compilerOptions, host, cache, lookupConfig ? tsconfigExtensions : (compilerOptions.resolveJsonModule ? tsPlusJsonExtensions : tsExtensions), redirectedReference);
+    function nodeModuleNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference, lookupConfig) {
+        return nodeModuleNameResolverWorker(parentFileExtension, moduleName, ts.getDirectoryPath(containingFile), compilerOptions, host, cache, lookupConfig ? tsconfigExtensions : (compilerOptions.resolveJsonModule ? tsPlusJsonExtensions : tsExtensions), redirectedReference);
     }
     ts.nodeModuleNameResolver = nodeModuleNameResolver;
-    function nodeModuleNameResolverWorker(moduleName, containingDirectory, compilerOptions, host, cache, extensions, redirectedReference) {
+    function nodeModuleNameResolverWorker(parentFileExtension, moduleName, containingDirectory, compilerOptions, host, cache, extensions, redirectedReference) {
         var traceEnabled = isTraceEnabled(compilerOptions, host);
         var failedLookupLocations = [];
         var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations };
@@ -26829,8 +26931,8 @@ var ts;
         }
         return { resolvedModule: undefined, failedLookupLocations: failedLookupLocations };
         function tryResolve(extensions) {
-            var loader = function (extensions, candidate, onlyRecordFailures, state) { return nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ true); };
-            var resolved = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loader, state);
+            var loader = function (parentFileExtension, extensions, candidate, onlyRecordFailures, state) { return nodeLoadModuleByRelativeName(parentFileExtension, extensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ true); };
+            var resolved = tryLoadModuleUsingOptionalResolutionSettings(parentFileExtension, extensions, moduleName, containingDirectory, loader, state);
             if (resolved) {
                 return toSearchResult({ resolved: resolved, isExternalLibraryImport: pathContainsNodeModules(resolved.path) });
             }
@@ -26838,7 +26940,7 @@ var ts;
                 if (traceEnabled) {
                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);
                 }
-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
+                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(parentFileExtension, extensions, moduleName, containingDirectory, state, cache, redirectedReference);
                 if (!resolved_1)
                     return undefined;
                 var resolvedValue = resolved_1.value;
@@ -26852,7 +26954,7 @@ var ts;
             }
             else {
                 var _a = ts.normalizePathAndParts(ts.combinePaths(containingDirectory, moduleName)), candidate = _a.path, parts = _a.parts;
-                var resolved_2 = nodeLoadModuleByRelativeName(extensions, candidate, /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true);
+                var resolved_2 = nodeLoadModuleByRelativeName(parentFileExtension, extensions, candidate, /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true);
                 // Treat explicit "node_modules" import as an external library import.
                 return resolved_2 && toSearchResult({ resolved: resolved_2, isExternalLibraryImport: ts.contains(parts, "node_modules") });
             }
@@ -26869,7 +26971,7 @@ var ts;
         ts.Debug.assert(host.fileExists(real), path + " linked to nonexistent file " + real); // tslint:disable-line
         return real;
     }
-    function nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
+    function nodeLoadModuleByRelativeName(parentFileExtension, extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
         if (state.traceEnabled) {
             trace(state.host, ts.Diagnostics.Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1, candidate, Extensions[extensions]);
         }
@@ -26883,10 +26985,10 @@ var ts;
                     onlyRecordFailures = true;
                 }
             }
-            var resolvedFromFile = loadModuleFromFile(extensions, candidate, onlyRecordFailures, state);
+            var resolvedFromFile = loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state);
             if (resolvedFromFile) {
                 var nm = considerPackageJson ? parseNodeModuleFromPath(resolvedFromFile) : undefined;
-                var packageInfo = nm && getPackageJsonInfo(nm.packageDirectory, nm.subModuleName, /*onlyRecordFailures*/ false, state);
+                var packageInfo = nm && getPackageJsonInfo(parentFileExtension, nm.packageDirectory, nm.subModuleName, /*onlyRecordFailures*/ false, state);
                 var packageId = packageInfo && packageInfo.packageId;
                 return withPackageId(packageId, resolvedFromFile);
             }
@@ -26900,7 +27002,7 @@ var ts;
                 onlyRecordFailures = true;
             }
         }
-        return loadNodeModuleFromDirectory(extensions, candidate, onlyRecordFailures, state, considerPackageJson);
+        return loadNodeModuleFromDirectory(parentFileExtension, extensions, candidate, onlyRecordFailures, state, considerPackageJson);
     }
     /*@internal*/
     ts.nodeModulesPathPart = "/node_modules/";
@@ -26951,20 +27053,20 @@ var ts;
         }
         return path + "/index.d.ts";
     }
-    function loadModuleFromFileNoPackageId(extensions, candidate, onlyRecordFailures, state) {
-        return noPackageId(loadModuleFromFile(extensions, candidate, onlyRecordFailures, state));
+    function loadModuleFromFileNoPackageId(parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
+        return noPackageId(loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state));
     }
     /**
      * @param {boolean} onlyRecordFailures - if true then function won't try to actually load files but instead record all attempts as failures. This flag is necessary
      * in cases when we know upfront that all load attempts will fail (because containing folder does not exists) however we still need to record all failed lookup locations.
      */
-    function loadModuleFromFile(extensions, candidate, onlyRecordFailures, state) {
+    function loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
         if (extensions === Extensions.Json || extensions === Extensions.TSConfig) {
             var extensionLess = ts.tryRemoveExtension(candidate, ".json" /* Json */);
-            return (extensionLess === undefined && extensions === Extensions.Json) ? undefined : tryAddingExtensions(extensionLess || candidate, extensions, onlyRecordFailures, state);
+            return (extensionLess === undefined && extensions === Extensions.Json) ? undefined : tryAddingExtensions(parentFileExtension, extensionLess || candidate, extensions, onlyRecordFailures, state);
         }
         // First, try adding an extension. An import of "foo" could be matched by a file "foo.ts", or "foo.js" by "foo.js.ts"
-        var resolvedByAddingExtension = tryAddingExtensions(candidate, extensions, onlyRecordFailures, state);
+        var resolvedByAddingExtension = tryAddingExtensions(parentFileExtension, candidate, extensions, onlyRecordFailures, state);
         if (resolvedByAddingExtension) {
             return resolvedByAddingExtension;
         }
@@ -26976,11 +27078,11 @@ var ts;
                 var extension = candidate.substring(extensionless.length);
                 trace(state.host, ts.Diagnostics.File_name_0_has_a_1_extension_stripping_it, candidate, extension);
             }
-            return tryAddingExtensions(extensionless, extensions, onlyRecordFailures, state);
+            return tryAddingExtensions(parentFileExtension, extensionless, extensions, onlyRecordFailures, state);
         }
     }
     /** Try to return an existing file that adds one of the `extensions` to `candidate`. */
-    function tryAddingExtensions(candidate, extensions, onlyRecordFailures, state) {
+    function tryAddingExtensions(parentFileExtension, candidate, extensions, onlyRecordFailures, state) {
         if (!onlyRecordFailures) {
             // check if containing folder exists - if it doesn't then just record failures for all supported extensions without disk probing
             var directory = ts.getDirectoryPath(candidate);
@@ -26988,16 +27090,212 @@ var ts;
                 onlyRecordFailures = !ts.directoryProbablyExists(directory, state.host);
             }
         }
-        switch (extensions) {
-            case Extensions.DtsOnly:
-                return tryExtension(".d.ts" /* Dts */);
-            case Extensions.TypeScript:
-                return tryExtension(".ts" /* Ts */) || tryExtension(".tsx" /* Tsx */) || tryExtension(".d.ts" /* Dts */);
-            case Extensions.JavaScript:
-                return tryExtension(".js" /* Js */) || tryExtension(".jsx" /* Jsx */);
-            case Extensions.TSConfig:
-            case Extensions.Json:
-                return tryExtension(".json" /* Json */);
+        switch (parentFileExtension) {
+            case ".web.ts" /* WebTs */:
+            case ".web.tsx" /* WebTsx */:
+            case ".web.js" /* WebJs */:
+            case ".web.jsx" /* WebJsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".web.json" /* WebJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".web.js" /* WebJs */) ||
+                            tryExtension(".web.jsx" /* WebJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".web.ts" /* WebTs */) ||
+                            tryExtension(".web.tsx" /* WebTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".native.js" /* NativeJs */:
+            case ".native.jsx" /* NativeJsx */:
+            case ".native.ts" /* NativeTs */:
+            case ".native.tsx" /* NativeTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".json" /* Json */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".ios.json" /* IosJson */) ||
+                            tryExtension(".android.json" /* AndroidJson */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".ios.js" /* IosJs */) ||
+                            tryExtension(".ios.jsx" /* IosJsx */) ||
+                            tryExtension(".android.js" /* AndroidJs */) ||
+                            tryExtension(".android.jsx" /* AndroidJsx */));
+                    }
+                    default: {
+                        return (tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ios.ts" /* IosTs */) ||
+                            tryExtension(".ios.tsx" /* IosTsx */) ||
+                            tryExtension(".android.ts" /* AndroidTs */) ||
+                            tryExtension(".android.tsx" /* AndroidTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".ios.js" /* IosJs */:
+            case ".ios.jsx" /* IosJsx */:
+            case ".ios.ts" /* IosTs */:
+            case ".ios.tsx" /* IosTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".ios.json" /* IosJson */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".ios.js" /* IosJs */) ||
+                            tryExtension(".ios.jsx" /* IosJsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".ios.ts" /* IosTs */) ||
+                            tryExtension(".ios.tsx" /* IosTsx */) ||
+                            tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".android.js" /* AndroidJs */:
+            case ".android.jsx" /* AndroidJsx */:
+            case ".android.ts" /* AndroidTs */:
+            case ".android.tsx" /* AndroidTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".android.json" /* AndroidJson */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".android.js" /* AndroidJs */) ||
+                            tryExtension(".android.jsx" /* AndroidJsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".android.ts" /* AndroidTs */) ||
+                            tryExtension(".android.tsx" /* AndroidTsx */) ||
+                            tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".node.js" /* NodeJs */:
+            case ".node.jsx" /* NodeJsx */:
+            case ".node.ts" /* NodeTs */:
+            case ".node.tsx" /* NodeTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".node.json" /* NodeJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".node.js" /* NodeJs */) ||
+                            tryExtension(".node.jsx" /* NodeJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".node.ts" /* NodeTs */) ||
+                            tryExtension(".node.tsx" /* NodeTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            default: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".json" /* Json */) ||
+                            tryExtension(".node.json" /* NodeJson */) ||
+                            tryExtension(".web.json" /* WebJson */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".ios.json" /* IosJson */) ||
+                            tryExtension(".android.json" /* AndroidJson */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */) ||
+                            tryExtension(".node.js" /* NodeJs */) ||
+                            tryExtension(".node.jsx" /* NodeJsx */) ||
+                            tryExtension(".web.js" /* WebJs */) ||
+                            tryExtension(".web.jsx" /* WebJsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".ios.js" /* IosJs */) ||
+                            tryExtension(".ios.jsx" /* IosJsx */) ||
+                            tryExtension(".android.js" /* AndroidJs */) ||
+                            tryExtension(".android.jsx" /* AndroidJsx */));
+                    }
+                    default: {
+                        return (tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */) ||
+                            tryExtension(".node.ts" /* NodeTs */) ||
+                            tryExtension(".node.tsx" /* NodeTsx */) ||
+                            tryExtension(".web.ts" /* WebTs */) ||
+                            tryExtension(".web.tsx" /* WebTsx */) ||
+                            tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ios.ts" /* IosTs */) ||
+                            tryExtension(".ios.tsx" /* IosTsx */) ||
+                            tryExtension(".android.ts" /* AndroidTs */) ||
+                            tryExtension(".android.tsx" /* AndroidTsx */));
+                    }
+                }
+            }
         }
         function tryExtension(ext) {
             var path = tryFile(candidate + ext, onlyRecordFailures, state);
@@ -27022,15 +27320,15 @@ var ts;
         state.failedLookupLocations.push(fileName);
         return undefined;
     }
-    function loadNodeModuleFromDirectory(extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
+    function loadNodeModuleFromDirectory(parentFileExtension, extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
         if (considerPackageJson === void 0) { considerPackageJson = true; }
-        var packageInfo = considerPackageJson ? getPackageJsonInfo(candidate, "", onlyRecordFailures, state) : undefined;
+        var packageInfo = considerPackageJson ? getPackageJsonInfo(parentFileExtension, candidate, "", onlyRecordFailures, state) : undefined;
         var packageId = packageInfo && packageInfo.packageId;
         var packageJsonContent = packageInfo && packageInfo.packageJsonContent;
         var versionPaths = packageJsonContent && readPackageJsonTypesVersionPaths(packageJsonContent, state);
-        return withPackageId(packageId, loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths));
+        return withPackageId(packageId, loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths));
     }
-    function getPackageJsonInfo(packageDirectory, subModuleName, onlyRecordFailures, state) {
+    function getPackageJsonInfo(parentFileExtension, packageDirectory, subModuleName, onlyRecordFailures, state) {
         var host = state.host, traceEnabled = state.traceEnabled;
         var directoryExists = !onlyRecordFailures && ts.directoryProbablyExists(packageDirectory, host);
         var packageJsonPath = ts.combinePaths(packageDirectory, "package.json");
@@ -27042,7 +27340,34 @@ var ts;
                     subModuleName = addExtensionAndIndex(path.substring(packageDirectory.length + 1));
                 }
                 else {
-                    var jsPath = readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                    var jsPath = void 0;
+                    switch (parentFileExtension) {
+                        case ".android.js" /* AndroidJs */:
+                        case ".ios.js" /* IosJs */:
+                        case ".native.js" /* NativeJs */:
+                        case ".android.jsx" /* AndroidJsx */:
+                        case ".ios.jsx" /* IosJsx */:
+                        case ".native.jsx" /* NativeJsx */:
+                        case ".android.ts" /* AndroidTs */:
+                        case ".ios.ts" /* IosTs */:
+                        case ".native.ts" /* NativeTs */:
+                        case ".android.tsx" /* AndroidTsx */:
+                        case ".ios.tsx" /* IosTsx */:
+                        case ".native.tsx" /* NativeTsx */: {
+                            jsPath = readPackageJsonReactNativeField(packageJsonContent, packageDirectory, state) || readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                            break;
+                        }
+                        case ".web.js" /* WebJs */:
+                        case ".web.jsx" /* WebJsx */:
+                        case ".web.ts" /* WebTs */:
+                        case ".web.tsx" /* WebTsx */: {
+                            jsPath = readPackageJsonBrowserField(packageJsonContent, packageDirectory, state) || readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                            break;
+                        }
+                        default: {
+                            jsPath = readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                        }
+                    }
                     if (typeof jsPath === "string" && jsPath.length > packageDirectory.length) {
                         var potentialSubModule_1 = jsPath.substring(packageDirectory.length + 1);
                         subModuleName = (ts.forEach(ts.supportedJSExtensions, function (extension) {
@@ -27059,7 +27384,7 @@ var ts;
             }
             var versionPaths = readPackageJsonTypesVersionPaths(packageJsonContent, state);
             var packageId = typeof packageJsonContent.name === "string" && typeof packageJsonContent.version === "string"
-                ? { name: packageJsonContent.name, subModuleName: subModuleName, version: packageJsonContent.version }
+                ? { name: packageJsonContent.name + "|" + parentFileExtension, subModuleName: subModuleName, version: packageJsonContent.version }
                 : undefined;
             if (traceEnabled) {
                 if (packageId) {
@@ -27079,18 +27404,79 @@ var ts;
             state.failedLookupLocations.push(packageJsonPath);
         }
     }
-    function loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, jsonContent, versionPaths) {
+    function loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, onlyRecordFailures, state, jsonContent, versionPaths) {
         var packageFile;
         if (jsonContent) {
             switch (extensions) {
                 case Extensions.JavaScript:
-                case Extensions.Json:
-                    packageFile = readPackageJsonMainField(jsonContent, candidate, state);
+                case Extensions.Json: {
+                    switch (parentFileExtension) {
+                        case ".android.js" /* AndroidJs */:
+                        case ".ios.js" /* IosJs */:
+                        case ".native.js" /* NativeJs */:
+                        case ".android.jsx" /* AndroidJsx */:
+                        case ".ios.jsx" /* IosJsx */:
+                        case ".native.jsx" /* NativeJsx */:
+                        case ".android.ts" /* AndroidTs */:
+                        case ".ios.ts" /* IosTs */:
+                        case ".native.ts" /* NativeTs */:
+                        case ".android.tsx" /* AndroidTsx */:
+                        case ".ios.tsx" /* IosTsx */:
+                        case ".native.tsx" /* NativeTsx */: {
+                            packageFile = readPackageJsonReactNativeField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        case ".web.js" /* WebJs */:
+                        case ".web.jsx" /* WebJsx */:
+                        case ".web.ts" /* WebTs */:
+                        case ".web.tsx" /* WebTsx */: {
+                            packageFile = readPackageJsonBrowserField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        default: {
+                            packageFile = readPackageJsonMainField(jsonContent, candidate, state);
+                        }
+                    }
                     break;
-                case Extensions.TypeScript:
-                    // When resolving typescript modules, try resolving using main field as well
-                    packageFile = readPackageJsonTypesFields(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                }
+                case Extensions.TypeScript: {
+                    switch (parentFileExtension) {
+                        case ".android.js" /* AndroidJs */:
+                        case ".ios.js" /* IosJs */:
+                        case ".native.js" /* NativeJs */:
+                        case ".android.jsx" /* AndroidJsx */:
+                        case ".ios.jsx" /* IosJsx */:
+                        case ".native.jsx" /* NativeJsx */:
+                        case ".android.ts" /* AndroidTs */:
+                        case ".ios.ts" /* IosTs */:
+                        case ".native.ts" /* NativeTs */:
+                        case ".android.tsx" /* AndroidTsx */:
+                        case ".ios.tsx" /* IosTsx */:
+                        case ".native.tsx" /* NativeTsx */: {
+                            packageFile = readPackageJsonReactNativeField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        case ".web.js" /* WebJs */:
+                        case ".web.jsx" /* WebJsx */:
+                        case ".web.ts" /* WebTs */:
+                        case ".web.tsx" /* WebTsx */: {
+                            packageFile = readPackageJsonBrowserField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        case ".node.js" /* NodeJs */:
+                        case ".node.jsx" /* NodeJsx */:
+                        case ".node.ts" /* NodeTs */:
+                        case ".node.tsx" /* NodeTsx */: {
+                            packageFile = readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        default: {
+                            // When resolving typescript modules, try resolving using main field as well
+                            packageFile = readPackageJsonTypesFields(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                        }
+                    }
                     break;
+                }
                 case Extensions.DtsOnly:
                     packageFile = readPackageJsonTypesFields(jsonContent, candidate, state);
                     break;
@@ -27101,7 +27487,7 @@ var ts;
                     return ts.Debug.assertNever(extensions);
             }
         }
-        var loader = function (extensions, candidate, onlyRecordFailures, state) {
+        var loader = function (parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
             var fromFile = tryFile(candidate, onlyRecordFailures, state);
             if (fromFile) {
                 var resolved = resolvedIfExtensionMatches(extensions, fromFile);
@@ -27115,7 +27501,7 @@ var ts;
             // Even if extensions is DtsOnly, we can still look up a .ts file as a result of package.json "types"
             var nextExtensions = extensions === Extensions.DtsOnly ? Extensions.TypeScript : extensions;
             // Don't do package.json lookup recursively, because Node.js' package lookup doesn't.
-            return nodeLoadModuleByRelativeName(nextExtensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ false);
+            return nodeLoadModuleByRelativeName(parentFileExtension, nextExtensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ false);
         };
         var onlyRecordFailuresForPackageFile = packageFile ? !ts.directoryProbablyExists(ts.getDirectoryPath(packageFile), state.host) : undefined;
         var onlyRecordFailuresForIndex = onlyRecordFailures || !ts.directoryProbablyExists(candidate, state.host);
@@ -27125,16 +27511,16 @@ var ts;
             if (state.traceEnabled) {
                 trace(state.host, ts.Diagnostics.package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2, versionPaths.version, ts.version, moduleName);
             }
-            var result = tryLoadModuleUsingPaths(extensions, moduleName, candidate, versionPaths.paths, loader, onlyRecordFailuresForPackageFile || onlyRecordFailuresForIndex, state);
+            var result = tryLoadModuleUsingPaths(parentFileExtension, extensions, moduleName, candidate, versionPaths.paths, loader, onlyRecordFailuresForPackageFile || onlyRecordFailuresForIndex, state);
             if (result) {
                 return removeIgnoredPackageId(result.value);
             }
         }
         // It won't have a `packageId` set, because we disabled `considerPackageJson`.
-        var packageFileResult = packageFile && removeIgnoredPackageId(loader(extensions, packageFile, onlyRecordFailuresForPackageFile, state));
+        var packageFileResult = packageFile && removeIgnoredPackageId(loader(parentFileExtension, extensions, packageFile, onlyRecordFailuresForPackageFile, state));
         if (packageFileResult)
             return packageFileResult;
-        return loadModuleFromFile(extensions, indexPath, onlyRecordFailuresForIndex, state);
+        return loadModuleFromFile(parentFileExtension, extensions, indexPath, onlyRecordFailuresForIndex, state);
     }
     /** Resolve from an arbitrarily specified file. Return `undefined` if it has an unsupported extension. */
     function resolvedIfExtensionMatches(extensions, path) {
@@ -27145,12 +27531,40 @@ var ts;
     function extensionIsOk(extensions, extension) {
         switch (extensions) {
             case Extensions.JavaScript:
-                return extension === ".js" /* Js */ || extension === ".jsx" /* Jsx */;
+                return (extension === ".js" /* Js */ ||
+                    extension === ".jsx" /* Jsx */ ||
+                    extension === ".node.js" /* NodeJs */ ||
+                    extension === ".node.jsx" /* NodeJsx */ ||
+                    extension === ".web.js" /* WebJs */ ||
+                    extension === ".web.jsx" /* WebJsx */ ||
+                    extension === ".native.js" /* NativeJs */ ||
+                    extension === ".native.jsx" /* NativeJsx */ ||
+                    extension === ".ios.js" /* IosJs */ ||
+                    extension === ".ios.jsx" /* IosJsx */ ||
+                    extension === ".android.js" /* AndroidJs */ ||
+                    extension === ".android.jsx" /* AndroidJsx */);
             case Extensions.TSConfig:
             case Extensions.Json:
-                return extension === ".json" /* Json */;
+                return (extension === ".json" /* Json */ ||
+                    extension === ".node.json" /* NodeJson */ ||
+                    extension === ".web.json" /* WebJson */ ||
+                    extension === ".native.json" /* NativeJson */ ||
+                    extension === ".ios.json" /* IosJson */ ||
+                    extension === ".android.json" /* AndroidJson */);
             case Extensions.TypeScript:
-                return extension === ".ts" /* Ts */ || extension === ".tsx" /* Tsx */ || extension === ".d.ts" /* Dts */;
+                return (extension === ".ts" /* Ts */ ||
+                    extension === ".tsx" /* Tsx */ ||
+                    extension === ".d.ts" /* Dts */ ||
+                    extension === ".node.ts" /* NodeTs */ ||
+                    extension === ".node.tsx" /* NodeTsx */ ||
+                    extension === ".web.ts" /* WebTs */ ||
+                    extension === ".web.tsx" /* WebTsx */ ||
+                    extension === ".native.ts" /* NativeTs */ ||
+                    extension === ".native.tsx" /* NativeTsx */ ||
+                    extension === ".ios.ts" /* IosTs */ ||
+                    extension === ".ios.tsx" /* IosTsx */ ||
+                    extension === ".android.ts" /* AndroidTs */ ||
+                    extension === ".android.tsx" /* AndroidTsx */);
             case Extensions.DtsOnly:
                 return extension === ".d.ts" /* Dts */;
         }
@@ -27164,32 +27578,33 @@ var ts;
         return idx === -1 ? { packageName: moduleName, rest: "" } : { packageName: moduleName.slice(0, idx), rest: moduleName.slice(idx + 1) };
     }
     ts.parsePackageName = parsePackageName;
-    function loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, directory, state, cache, redirectedReference) {
-        return loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName, directory, state, /*typesScopeOnly*/ false, cache, redirectedReference);
+    function loadModuleFromNearestNodeModulesDirectory(parentFileExtension, extensions, moduleName, directory, state, cache, redirectedReference) {
+        return loadModuleFromNearestNodeModulesDirectoryWorker(parentFileExtension, extensions, moduleName, directory, state, /*typesScopeOnly*/ false, cache, redirectedReference);
     }
     function loadModuleFromNearestNodeModulesDirectoryTypesScope(moduleName, directory, state) {
         // Extensions parameter here doesn't actually matter, because typesOnly ensures we're just doing @types lookup, which is always DtsOnly.
-        return loadModuleFromNearestNodeModulesDirectoryWorker(Extensions.DtsOnly, moduleName, directory, state, /*typesScopeOnly*/ true, /*cache*/ undefined, /*redirectedReference*/ undefined);
+        return loadModuleFromNearestNodeModulesDirectoryWorker(".ts" /* Ts */, Extensions.DtsOnly, moduleName, directory, state, /*typesScopeOnly*/ true, /*cache*/ undefined, /*redirectedReference*/ undefined);
     }
-    function loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
-        var perModuleNameCache = cache && cache.getOrCreateCacheForModuleName(moduleName, redirectedReference);
+    function loadModuleFromNearestNodeModulesDirectoryWorker(parentFileExtension, extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
+        var moduleNameKey = moduleName + "|" + parentFileExtension;
+        var perModuleNameCache = cache && cache.getOrCreateCacheForModuleName(moduleNameKey, redirectedReference);
         return ts.forEachAncestorDirectory(ts.normalizeSlashes(directory), function (ancestorDirectory) {
             if (ts.getBaseFileName(ancestorDirectory) !== "node_modules") {
                 var resolutionFromCache = tryFindNonRelativeModuleNameInCache(perModuleNameCache, moduleName, ancestorDirectory, state);
                 if (resolutionFromCache) {
                     return resolutionFromCache;
                 }
-                return toSearchResult(loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, ancestorDirectory, state, typesScopeOnly));
+                return toSearchResult(loadModuleFromImmediateNodeModulesDirectory(parentFileExtension, extensions, moduleName, ancestorDirectory, state, typesScopeOnly));
             }
         });
     }
-    function loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, directory, state, typesScopeOnly) {
+    function loadModuleFromImmediateNodeModulesDirectory(parentFileExtension, extensions, moduleName, directory, state, typesScopeOnly) {
         var nodeModulesFolder = ts.combinePaths(directory, "node_modules");
         var nodeModulesFolderExists = ts.directoryProbablyExists(nodeModulesFolder, state.host);
         if (!nodeModulesFolderExists && state.traceEnabled) {
             trace(state.host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, nodeModulesFolder);
         }
-        var packageResult = typesScopeOnly ? undefined : loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesFolder, nodeModulesFolderExists, state);
+        var packageResult = typesScopeOnly ? undefined : loadModuleFromSpecificNodeModulesDirectory(parentFileExtension, extensions, moduleName, nodeModulesFolder, nodeModulesFolderExists, state);
         if (packageResult) {
             return packageResult;
         }
@@ -27202,35 +27617,35 @@ var ts;
                 }
                 nodeModulesAtTypesExists = false;
             }
-            return loadModuleFromSpecificNodeModulesDirectory(Extensions.DtsOnly, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes_1, nodeModulesAtTypesExists, state);
+            return loadModuleFromSpecificNodeModulesDirectory(parentFileExtension, Extensions.DtsOnly, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes_1, nodeModulesAtTypesExists, state);
         }
     }
-    function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state) {
+    function loadModuleFromSpecificNodeModulesDirectory(parentFileExtension, extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state) {
         var candidate = ts.normalizePath(ts.combinePaths(nodeModulesDirectory, moduleName));
         // First look for a nested package.json, as in `node_modules/foo/bar/package.json`.
         var packageJsonContent;
         var packageId;
         var versionPaths;
-        var packageInfo = getPackageJsonInfo(candidate, "", !nodeModulesDirectoryExists, state);
+        var packageInfo = getPackageJsonInfo(parentFileExtension, candidate, "", !nodeModulesDirectoryExists, state);
         if (packageInfo) {
             (packageJsonContent = packageInfo.packageJsonContent, packageId = packageInfo.packageId, versionPaths = packageInfo.versionPaths);
-            var fromFile = loadModuleFromFile(extensions, candidate, !nodeModulesDirectoryExists, state);
+            var fromFile = loadModuleFromFile(parentFileExtension, extensions, candidate, !nodeModulesDirectoryExists, state);
             if (fromFile) {
                 return noPackageId(fromFile);
             }
-            var fromDirectory = loadNodeModuleFromDirectoryWorker(extensions, candidate, !nodeModulesDirectoryExists, state, packageJsonContent, versionPaths);
+            var fromDirectory = loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, !nodeModulesDirectoryExists, state, packageJsonContent, versionPaths);
             return withPackageId(packageId, fromDirectory);
         }
-        var loader = function (extensions, candidate, onlyRecordFailures, state) {
-            var pathAndExtension = loadModuleFromFile(extensions, candidate, onlyRecordFailures, state) ||
-                loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths);
+        var loader = function (parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
+            var pathAndExtension = loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state) ||
+                loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths);
             return withPackageId(packageId, pathAndExtension);
         };
         var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;
         if (rest !== "") { // If "rest" is empty, we just did this search above.
             var packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
             // Don't use a "types" or "main" from here because we're not loading the root, but a subdirectory -- just here for the packageId and path mappings.
-            var packageInfo_1 = getPackageJsonInfo(packageDirectory, rest, !nodeModulesDirectoryExists, state);
+            var packageInfo_1 = getPackageJsonInfo(parentFileExtension, packageDirectory, rest, !nodeModulesDirectoryExists, state);
             if (packageInfo_1)
                 (packageId = packageInfo_1.packageId, versionPaths = packageInfo_1.versionPaths);
             if (versionPaths) {
@@ -27238,15 +27653,15 @@ var ts;
                     trace(state.host, ts.Diagnostics.package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2, versionPaths.version, ts.version, rest);
                 }
                 var packageDirectoryExists = nodeModulesDirectoryExists && ts.directoryProbablyExists(packageDirectory, state.host);
-                var fromPaths = tryLoadModuleUsingPaths(extensions, rest, packageDirectory, versionPaths.paths, loader, !packageDirectoryExists, state);
+                var fromPaths = tryLoadModuleUsingPaths(parentFileExtension, extensions, rest, packageDirectory, versionPaths.paths, loader, !packageDirectoryExists, state);
                 if (fromPaths) {
                     return fromPaths.value;
                 }
             }
         }
-        return loader(extensions, candidate, !nodeModulesDirectoryExists, state);
+        return loader(parentFileExtension, extensions, candidate, !nodeModulesDirectoryExists, state);
     }
-    function tryLoadModuleUsingPaths(extensions, moduleName, baseDirectory, paths, loader, onlyRecordFailures, state) {
+    function tryLoadModuleUsingPaths(parentFileExtension, extensions, moduleName, baseDirectory, paths, loader, onlyRecordFailures, state) {
         var matchedPattern = ts.matchPatternOrExact(ts.getOwnKeys(paths), moduleName);
         if (matchedPattern) {
             var matchedStar_1 = ts.isString(matchedPattern) ? undefined : ts.matchedText(matchedPattern, moduleName);
@@ -27268,7 +27683,7 @@ var ts;
                         return noPackageId({ path: path_1, ext: extension });
                     }
                 }
-                return loader(extensions, candidate, onlyRecordFailures || !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
+                return loader(parentFileExtension, extensions, candidate, onlyRecordFailures || !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
             });
             return { value: resolved };
         }
@@ -27326,7 +27741,7 @@ var ts;
             return { value: result.resolvedModule && { path: result.resolvedModule.resolvedFileName, originalPath: result.resolvedModule.originalPath || true, extension: result.resolvedModule.extension, packageId: result.resolvedModule.packageId } };
         }
     }
-    function classicNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
+    function classicNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
         var traceEnabled = isTraceEnabled(compilerOptions, host);
         var failedLookupLocations = [];
         var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations };
@@ -27335,7 +27750,7 @@ var ts;
         // No originalPath because classic resolution doesn't resolve realPath
         return createResolvedModuleWithFailedLookupLocations(resolved && resolved.value, /*isExternalLibraryImport*/ false, failedLookupLocations);
         function tryResolve(extensions) {
-            var resolvedUsingSettings = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loadModuleFromFileNoPackageId, state);
+            var resolvedUsingSettings = tryLoadModuleUsingOptionalResolutionSettings(parentFileExtension, extensions, moduleName, containingDirectory, loadModuleFromFileNoPackageId, state);
             if (resolvedUsingSettings) {
                 return { value: resolvedUsingSettings };
             }
@@ -27348,7 +27763,7 @@ var ts;
                         return resolutionFromCache;
                     }
                     var searchName = ts.normalizePath(ts.combinePaths(directory, moduleName));
-                    return toSearchResult(loadModuleFromFileNoPackageId(extensions, searchName, /*onlyRecordFailures*/ false, state));
+                    return toSearchResult(loadModuleFromFileNoPackageId(parentFileExtension, extensions, searchName, /*onlyRecordFailures*/ false, state));
                 });
                 if (resolved_3) {
                     return resolved_3;
@@ -27360,7 +27775,7 @@ var ts;
             }
             else {
                 var candidate = ts.normalizePath(ts.combinePaths(containingDirectory, moduleName));
-                return toSearchResult(loadModuleFromFileNoPackageId(extensions, candidate, /*onlyRecordFailures*/ false, state));
+                return toSearchResult(loadModuleFromFileNoPackageId(parentFileExtension, extensions, candidate, /*onlyRecordFailures*/ false, state));
             }
         }
     }
@@ -27370,14 +27785,15 @@ var ts;
      * This is the minumum code needed to expose that functionality; the rest is in LSHost.
      */
     /* @internal */
-    function loadModuleFromGlobalCache(moduleName, projectName, compilerOptions, host, globalCache) {
+    function loadModuleFromGlobalCache(moduleName, containingFile, projectName, compilerOptions, host, globalCache) {
         var traceEnabled = isTraceEnabled(compilerOptions, host);
         if (traceEnabled) {
             trace(host, ts.Diagnostics.Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2, projectName, moduleName, globalCache);
         }
         var failedLookupLocations = [];
         var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations };
-        var resolved = loadModuleFromImmediateNodeModulesDirectory(Extensions.DtsOnly, moduleName, globalCache, state, /*typesScopeOnly*/ false);
+        var parentFileContext = ts.getFileExtension(containingFile);
+        var resolved = loadModuleFromImmediateNodeModulesDirectory(parentFileContext, Extensions.DtsOnly, moduleName, globalCache, state, /*typesScopeOnly*/ false);
         return createResolvedModuleWithFailedLookupLocations(resolved, /*isExternalLibraryImport*/ true, failedLookupLocations);
     }
     ts.loadModuleFromGlobalCache = loadModuleFromGlobalCache;
@@ -90444,16 +90860,41 @@ var ts;
         var extension = _a.extension;
         switch (extension) {
             case ".ts" /* Ts */:
+            case ".node.ts" /* NodeTs */:
+            case ".web.ts" /* WebTs */:
+            case ".native.ts" /* NativeTs */:
+            case ".ios.ts" /* IosTs */:
+            case ".android.ts" /* AndroidTs */:
             case ".d.ts" /* Dts */:
                 // These are always allowed.
                 return undefined;
             case ".tsx" /* Tsx */:
+            case ".node.tsx" /* NodeTsx */:
+            case ".web.tsx" /* WebTsx */:
+            case ".native.tsx" /* NativeTsx */:
+            case ".ios.tsx" /* IosTsx */:
+            case ".android.tsx" /* AndroidTsx */:
                 return needJsx();
             case ".jsx" /* Jsx */:
+            case ".node.jsx" /* NodeJsx */:
+            case ".web.jsx" /* WebJsx */:
+            case ".native.jsx" /* NativeJsx */:
+            case ".ios.jsx" /* IosJsx */:
+            case ".android.jsx" /* AndroidJsx */:
                 return needJsx() || needAllowJs();
             case ".js" /* Js */:
+            case ".node.js" /* NodeJs */:
+            case ".web.js" /* WebJs */:
+            case ".native.js" /* NativeJs */:
+            case ".ios.js" /* IosJs */:
+            case ".android.js" /* AndroidJs */:
                 return needAllowJs();
             case ".json" /* Json */:
+            case ".node.json" /* NodeJson */:
+            case ".web.json" /* WebJson */:
+            case ".native.json" /* NativeJson */:
+            case ".ios.json" /* IosJson */:
+            case ".android.json" /* AndroidJson */:
                 return needResolveJsonModule();
         }
         function needJsx() {
@@ -91864,7 +92305,7 @@ var ts;
             if (globalCache !== undefined && !ts.isExternalModuleNameRelative(moduleName) && !(primaryResult.resolvedModule && ts.extensionIsTS(primaryResult.resolvedModule.extension))) {
                 // create different collection of failed lookup locations for second pass
                 // if it will fail and we've already found something during the first pass - we don't want to pollute its results
-                var _a = ts.loadModuleFromGlobalCache(moduleName, resolutionHost.projectName, compilerOptions, host, globalCache), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
+                var _a = ts.loadModuleFromGlobalCache(moduleName, containingFile, resolutionHost.projectName, compilerOptions, host, globalCache), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
                 if (resolvedModule) {
                     return { resolvedModule: resolvedModule, failedLookupLocations: ts.addRange(primaryResult.failedLookupLocations, failedLookupLocations) };
                 }
@@ -91874,7 +92315,9 @@ var ts;
         }
         function resolveNamesWithLocalCache(names, containingFile, redirectedReference, cache, perDirectoryCacheWithRedirects, loader, getResolutionWithResolvedFileName, shouldRetryResolution, reusedNames, logChanges) {
             var path = resolutionHost.toPath(containingFile);
-            var resolutionsInFile = cache.get(path) || cache.set(path, ts.createMap()).get(path);
+            var context = ts.getFileExtension(containingFile);
+            var pathKey = path + "|" + context;
+            var resolutionsInFile = cache.get(pathKey) || cache.set(pathKey, ts.createMap()).get(pathKey);
             var dirPath = ts.getDirectoryPath(path);
             var perDirectoryCache = perDirectoryCacheWithRedirects.getOrCreateMapOfCacheRedirects(redirectedReference);
             var perDirectoryResolution = perDirectoryCache.get(dirPath);
@@ -91894,22 +92337,23 @@ var ts;
             var seenNamesInFile = ts.createMap();
             for (var _i = 0, names_2 = names; _i < names_2.length; _i++) {
                 var name = names_2[_i];
-                var resolution = resolutionsInFile.get(name);
+                var nameKey = name + "|" + context;
+                var resolution = resolutionsInFile.get(nameKey);
                 // Resolution is valid if it is present and not invalidated
-                if (!seenNamesInFile.has(name) &&
+                if (!seenNamesInFile.has(nameKey) &&
                     allFilesHaveInvalidatedResolution || unmatchedRedirects || !resolution || resolution.isInvalidated ||
                     // If the name is unresolved import that was invalidated, recalculate
                     (hasInvalidatedNonRelativeUnresolvedImport && !ts.isExternalModuleNameRelative(name) && shouldRetryResolution(resolution))) {
                     var existingResolution = resolution;
-                    var resolutionInDirectory = perDirectoryResolution.get(name);
+                    var resolutionInDirectory = perDirectoryResolution.get(nameKey);
                     if (resolutionInDirectory) {
                         resolution = resolutionInDirectory;
                     }
                     else {
                         resolution = loader(name, containingFile, compilerOptions, resolutionHost, redirectedReference);
-                        perDirectoryResolution.set(name, resolution);
+                        perDirectoryResolution.set(nameKey, resolution);
                     }
-                    resolutionsInFile.set(name, resolution);
+                    resolutionsInFile.set(nameKey, resolution);
                     watchFailedLookupLocationsOfExternalModuleResolutions(name, resolution);
                     if (existingResolution) {
                         stopWatchFailedLookupLocationOfResolution(existingResolution);
@@ -91921,14 +92365,15 @@ var ts;
                     }
                 }
                 ts.Debug.assert(resolution !== undefined && !resolution.isInvalidated);
-                seenNamesInFile.set(name, true);
+                seenNamesInFile.set(nameKey, true);
                 resolvedModules.push(getResolutionWithResolvedFileName(resolution));
             }
             // Stop watching and remove the unused name
-            resolutionsInFile.forEach(function (resolution, name) {
-                if (!seenNamesInFile.has(name) && !ts.contains(reusedNames, name)) {
+            resolutionsInFile.forEach(function (resolution, nameKey) {
+                var name = nameKey.split('|')[0];
+                if (!seenNamesInFile.has(nameKey) && !ts.contains(reusedNames, name)) {
                     stopWatchFailedLookupLocationOfResolution(resolution);
-                    resolutionsInFile.delete(name);
+                    resolutionsInFile.delete(nameKey);
                 }
             });
             return resolvedModules;
@@ -92726,11 +93171,46 @@ var ts;
                 case ".ts" /* Ts */:
                 case ".d.ts" /* Dts */:
                     return ".js" /* Js */;
+                case ".node.ts" /* NodeTs */:
+                    return ".node.js" /* NodeJs */;
+                case ".web.ts" /* WebTs */:
+                    return ".web.js" /* WebJs */;
+                case ".native.ts" /* NativeTs */:
+                    return ".native.js" /* NativeJs */;
+                case ".ios.ts" /* IosTs */:
+                    return ".ios.js" /* IosJs */;
+                case ".android.ts" /* AndroidTs */:
+                    return ".android.js" /* AndroidJs */;
                 case ".tsx" /* Tsx */:
                     return options.jsx === 1 /* Preserve */ ? ".jsx" /* Jsx */ : ".js" /* Js */;
+                case ".node.tsx" /* NodeTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".node.jsx" /* NodeJsx */ : ".node.js" /* NodeJs */;
+                case ".web.tsx" /* WebTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".web.jsx" /* WebJsx */ : ".web.js" /* WebJs */;
+                case ".native.tsx" /* NativeTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".native.jsx" /* NativeJsx */ : ".native.js" /* NativeJs */;
+                case ".ios.tsx" /* IosTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".ios.jsx" /* IosJsx */ : ".ios.js" /* IosJs */;
+                case ".android.tsx" /* AndroidTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".android.jsx" /* AndroidJsx */ : ".android.js" /* AndroidJs */;
                 case ".js" /* Js */:
                 case ".jsx" /* Jsx */:
+                case ".node.js" /* NodeJs */:
+                case ".node.jsx" /* NodeJsx */:
+                case ".web.js" /* WebJs */:
+                case ".web.jsx" /* WebJsx */:
+                case ".native.js" /* NativeJs */:
+                case ".native.jsx" /* NativeJsx */:
+                case ".ios.js" /* IosJs */:
+                case ".ios.jsx" /* IosJsx */:
+                case ".android.js" /* AndroidJs */:
+                case ".android.jsx" /* AndroidJsx */:
                 case ".json" /* Json */:
+                case ".node.json" /* NodeJson */:
+                case ".web.json" /* WebJson */:
+                case ".native.json" /* NativeJson */:
+                case ".ios.json" /* IosJson */:
+                case ".android.json" /* AndroidJson */:
                     return ext;
                 case ".tsbuildinfo" /* TsBuildInfo */:
                     return ts.Debug.fail("Extension " + ".tsbuildinfo" /* TsBuildInfo */ + " is unsupported:: FileName:: " + fileName);
@@ -97937,14 +98417,47 @@ var ts;
             }
             function kindModifiersFromExtension(extension) {
                 switch (extension) {
-                    case ".d.ts" /* Dts */: return ".d.ts" /* dtsModifier */;
-                    case ".js" /* Js */: return ".js" /* jsModifier */;
-                    case ".json" /* Json */: return ".json" /* jsonModifier */;
-                    case ".jsx" /* Jsx */: return ".jsx" /* jsxModifier */;
-                    case ".ts" /* Ts */: return ".ts" /* tsModifier */;
-                    case ".tsx" /* Tsx */: return ".tsx" /* tsxModifier */;
-                    case ".tsbuildinfo" /* TsBuildInfo */: return ts.Debug.fail("Extension " + ".tsbuildinfo" /* TsBuildInfo */ + " is unsupported.");
-                    case undefined: return "" /* none */;
+                    case ".d.ts" /* Dts */:
+                        return ".d.ts" /* dtsModifier */;
+                    case ".js" /* Js */:
+                    case ".node.js" /* NodeJs */:
+                    case ".web.js" /* WebJs */:
+                    case ".native.js" /* NativeJs */:
+                    case ".ios.js" /* IosJs */:
+                    case ".android.js" /* AndroidJs */:
+                        return ".js" /* jsModifier */;
+                    case ".json" /* Json */:
+                    case ".node.json" /* NodeJson */:
+                    case ".web.json" /* WebJson */:
+                    case ".native.json" /* NativeJson */:
+                    case ".ios.json" /* IosJson */:
+                    case ".android.json" /* AndroidJson */:
+                        return ".json" /* jsonModifier */;
+                    case ".jsx" /* Jsx */:
+                    case ".node.jsx" /* NodeJsx */:
+                    case ".web.jsx" /* WebJsx */:
+                    case ".native.jsx" /* NativeJsx */:
+                    case ".ios.jsx" /* IosJsx */:
+                    case ".android.jsx" /* AndroidJsx */:
+                        return ".jsx" /* jsxModifier */;
+                    case ".ts" /* Ts */:
+                    case ".node.ts" /* NodeTs */:
+                    case ".web.ts" /* WebTs */:
+                    case ".native.ts" /* NativeTs */:
+                    case ".ios.ts" /* IosTs */:
+                    case ".android.ts" /* AndroidTs */:
+                        return ".ts" /* tsModifier */;
+                    case ".tsx" /* Tsx */:
+                    case ".node.tsx" /* NodeTsx */:
+                    case ".web.tsx" /* WebTsx */:
+                    case ".native.tsx" /* NativeTsx */:
+                    case ".ios.tsx" /* IosTsx */:
+                    case ".android.tsx" /* AndroidTsx */:
+                        return ".tsx" /* tsxModifier */;
+                    case ".tsbuildinfo" /* TsBuildInfo */:
+                        return ts.Debug.fail("Extension " + ".tsbuildinfo" /* TsBuildInfo */ + " is unsupported.");
+                    case undefined:
+                        return "" /* none */;
                     default:
                         return ts.Debug.assertNever(extension);
                 }
diff --git a/lib/tsserverlibrary.d.ts b/lib/tsserverlibrary.d.ts
index 8208cdba2a..e5ccb858d4 100644
--- a/lib/tsserverlibrary.d.ts
+++ b/lib/tsserverlibrary.d.ts
@@ -2716,12 +2716,37 @@ declare namespace ts {
     }
     enum Extension {
         Ts = ".ts",
+        IosTs = ".ios.ts",
+        AndroidTs = ".android.ts",
+        NativeTs = ".native.ts",
+        WebTs = ".web.ts",
+        NodeTs = ".node.ts",
         Tsx = ".tsx",
+        IosTsx = ".ios.tsx",
+        AndroidTsx = ".android.tsx",
+        NativeTsx = ".native.tsx",
+        WebTsx = ".web.tsx",
+        NodeTsx = ".node.tsx",
         Dts = ".d.ts",
         Js = ".js",
+        IosJs = ".ios.js",
+        AndroidJs = ".android.js",
+        NativeJs = ".native.js",
+        WebJs = ".web.js",
+        NodeJs = ".node.js",
         Jsx = ".jsx",
         Json = ".json",
-        TsBuildInfo = ".tsbuildinfo"
+        TsBuildInfo = ".tsbuildinfo",
+        IosJsx = ".ios.jsx",
+        AndroidJsx = ".android.jsx",
+        NativeJsx = ".native.jsx",
+        WebJsx = ".web.jsx",
+        NodeJsx = ".node.jsx",
+        IosJson = ".ios.json",
+        AndroidJson = ".android.json",
+        NativeJson = ".native.json",
+        WebJson = ".web.json",
+        NodeJson = ".node.json"
     }
     interface ResolvedModuleWithFailedLookupLocations {
         readonly resolvedModule: ResolvedModuleFull | undefined;
@@ -3717,8 +3742,8 @@ declare namespace ts {
     function createModuleResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string): ModuleResolutionCache;
     function resolveModuleNameFromCache(moduleName: string, containingFile: string, cache: ModuleResolutionCache): ResolvedModuleWithFailedLookupLocations | undefined;
     function resolveModuleName(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
-    function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
-    function classicNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
+    function nodeModuleNameResolver(parentFileExtension: Extension, moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
+    function classicNameResolver(parentFileExtension: Extension, moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
 }
 declare namespace ts {
     function createNodeArray<T extends Node>(elements?: ReadonlyArray<T>, hasTrailingComma?: boolean): NodeArray<T>;
diff --git a/lib/tsserverlibrary.js b/lib/tsserverlibrary.js
index 79f6dcec55..85281df543 100644
--- a/lib/tsserverlibrary.js
+++ b/lib/tsserverlibrary.js
@@ -3842,12 +3842,37 @@ var ts;
     var Extension;
     (function (Extension) {
         Extension["Ts"] = ".ts";
+        Extension["IosTs"] = ".ios.ts";
+        Extension["AndroidTs"] = ".android.ts";
+        Extension["NativeTs"] = ".native.ts";
+        Extension["WebTs"] = ".web.ts";
+        Extension["NodeTs"] = ".node.ts";
         Extension["Tsx"] = ".tsx";
+        Extension["IosTsx"] = ".ios.tsx";
+        Extension["AndroidTsx"] = ".android.tsx";
+        Extension["NativeTsx"] = ".native.tsx";
+        Extension["WebTsx"] = ".web.tsx";
+        Extension["NodeTsx"] = ".node.tsx";
         Extension["Dts"] = ".d.ts";
         Extension["Js"] = ".js";
+        Extension["IosJs"] = ".ios.js";
+        Extension["AndroidJs"] = ".android.js";
+        Extension["NativeJs"] = ".native.js";
+        Extension["WebJs"] = ".web.js";
+        Extension["NodeJs"] = ".node.js";
         Extension["Jsx"] = ".jsx";
         Extension["Json"] = ".json";
         Extension["TsBuildInfo"] = ".tsbuildinfo";
+        Extension["IosJsx"] = ".ios.jsx";
+        Extension["AndroidJsx"] = ".android.jsx";
+        Extension["NativeJsx"] = ".native.jsx";
+        Extension["WebJsx"] = ".web.jsx";
+        Extension["NodeJsx"] = ".node.jsx";
+        Extension["IosJson"] = ".ios.json";
+        Extension["AndroidJson"] = ".android.json";
+        Extension["NativeJson"] = ".native.json";
+        Extension["WebJson"] = ".web.json";
+        Extension["NodeJson"] = ".node.json";
     })(Extension = ts.Extension || (ts.Extension = {}));
     /* @internal */
     var TransformFlags;
@@ -5036,7 +5061,21 @@ var ts;
             }
             function realpath(path) {
                 try {
-                    return _fs.realpathSync(path);
+                    var regexp = /\.([^\/]+?)$/;
+                    var match = path.match(regexp);
+                    var rpath = _fs.realpathSync(path);
+                    if (match !== null) {
+                        var ext = match[1];
+                        var rmatch = rpath.match(regexp);
+                        if (rmatch !== null) {
+                            var rext = rmatch[1];
+                            if (ext !== rext) {
+                                return rpath.replace(new RegExp(rext + "$"), ext);
+                            }
+                            return rpath;
+                        }
+                    }
+                    return rpath;
                 }
                 catch (_a) {
                     return path;
@@ -12052,7 +12091,7 @@ var ts;
     }
     /** Return ".ts", ".d.ts", or ".tsx", if that is the extension. */
     function tryExtractTSExtension(fileName) {
-        return ts.find(ts.supportedTSExtensionsForExtractExtension, function (extension) { return ts.fileExtensionIs(fileName, extension); });
+        return ts.find(ts.supportedTSExtensions, function (extension) { return ts.fileExtensionIs(fileName, extension); });
     }
     ts.tryExtractTSExtension = tryExtractTSExtension;
     /**
@@ -16016,14 +16055,55 @@ var ts;
     /**
      *  List of supported extensions in order of file resolution precedence.
      */
-    ts.supportedTSExtensions = [".ts" /* Ts */, ".tsx" /* Tsx */, ".d.ts" /* Dts */];
-    ts.supportedTSExtensionsWithJson = [".ts" /* Ts */, ".tsx" /* Tsx */, ".d.ts" /* Dts */, ".json" /* Json */];
-    /** Must have ".d.ts" first because if ".ts" goes first, that will be detected as the extension instead of ".d.ts". */
-    ts.supportedTSExtensionsForExtractExtension = [".d.ts" /* Dts */, ".ts" /* Ts */, ".tsx" /* Tsx */];
-    ts.supportedJSExtensions = [".js" /* Js */, ".jsx" /* Jsx */];
-    ts.supportedJSAndJsonExtensions = [".js" /* Js */, ".jsx" /* Jsx */, ".json" /* Json */];
+    ts.supportedJsonExtensions = [
+        ".node.json" /* NodeJson */,
+        ".web.json" /* WebJson */,
+        ".native.json" /* NativeJson */,
+        ".ios.json" /* IosJson */,
+        ".android.json" /* AndroidJson */,
+        ".json" /* Json */
+    ];
+    ts.supportedTSExtensions = [
+        ".node.ts" /* NodeTs */,
+        ".node.tsx" /* NodeTsx */,
+        ".web.ts" /* WebTs */,
+        ".web.tsx" /* WebTsx */,
+        ".native.ts" /* NativeTs */,
+        ".native.tsx" /* NativeTsx */,
+        ".ios.ts" /* IosTs */,
+        ".ios.tsx" /* IosTsx */,
+        ".android.ts" /* AndroidTs */,
+        ".android.tsx" /* AndroidTsx */,
+        ".d.ts" /* Dts */,
+        ".ts" /* Ts */,
+        ".tsx" /* Tsx */
+    ];
+    ts.supportedTSExtensionsWithJson = ts.supportedTSExtensions.concat(ts.supportedJsonExtensions);
+    ts.supportedJSExtensions = [
+        ".node.js" /* NodeJs */,
+        ".node.jsx" /* NodeJsx */,
+        ".web.js" /* WebJs */,
+        ".web.jsx" /* WebJsx */,
+        ".native.js" /* NativeJs */,
+        ".native.jsx" /* NativeJsx */,
+        ".ios.js" /* IosJs */,
+        ".ios.jsx" /* IosJsx */,
+        ".android.js" /* AndroidJs */,
+        ".android.jsx" /* AndroidJsx */,
+        ".js" /* Js */,
+        ".jsx" /* Jsx */
+    ];
+    ts.supportedJSAndJsonExtensions = ts.supportedJSExtensions.concat(ts.supportedJsonExtensions);
     var allSupportedExtensions = ts.supportedTSExtensions.concat(ts.supportedJSExtensions);
-    var allSupportedExtensionsWithJson = ts.supportedTSExtensions.concat(ts.supportedJSExtensions, [".json" /* Json */]);
+    var allSupportedExtensionsWithJson = ts.supportedTSExtensions.concat(ts.supportedJSExtensions, ts.supportedJsonExtensions);
+    function getAllSupportedExtensions() {
+        return allSupportedExtensions;
+    }
+    ts.getAllSupportedExtensions = getAllSupportedExtensions;
+    function getAllSupportedExtensionsWithJson() {
+        return allSupportedExtensionsWithJson;
+    }
+    ts.getAllSupportedExtensionsWithJson = getAllSupportedExtensionsWithJson;
     function getSupportedExtensions(options, extraFileExtensions) {
         var needJsExtensions = options && options.allowJs;
         if (!extraFileExtensions || extraFileExtensions.length === 0) {
@@ -16195,7 +16275,7 @@ var ts;
     ts.positionIsSynthesized = positionIsSynthesized;
     /** True if an extension is one of the supported TypeScript extensions. */
     function extensionIsTS(ext) {
-        return ext === ".ts" /* Ts */ || ext === ".tsx" /* Tsx */ || ext === ".d.ts" /* Dts */;
+        return ts.supportedTSExtensions.indexOf(ext) !== -1;
     }
     ts.extensionIsTS = extensionIsTS;
     function resolutionExtensionIsTSOrJson(ext) {
@@ -16216,7 +16296,7 @@ var ts;
     }
     ts.isAnySupportedFileExtension = isAnySupportedFileExtension;
     function tryGetExtensionFromPath(path) {
-        return ts.find(extensionsToRemove, function (e) { return ts.fileExtensionIs(path, e); });
+        return ts.find(allSupportedExtensionsWithJson, function (e) { return ts.fileExtensionIs(path, e); });
     }
     ts.tryGetExtensionFromPath = tryGetExtensionFromPath;
     function getAnyExtensionFromPathWorker(path, extensions, stringEqualityComparer) {
@@ -16257,6 +16337,19 @@ var ts;
         files: ts.emptyArray,
         directories: ts.emptyArray
     };
+    function getFileExtension(filepath) {
+        if (typeof filepath === "undefined") {
+            return ".ts" /* Ts */;
+        }
+        for (var _i = 0, allSupportedExtensionsWithJson_1 = allSupportedExtensionsWithJson; _i < allSupportedExtensionsWithJson_1.length; _i++) {
+            var ext = allSupportedExtensionsWithJson_1[_i];
+            if (ts.endsWith(filepath, ext)) {
+                return ext;
+            }
+        }
+        return ".ts" /* Ts */;
+    }
+    ts.getFileExtension = getFileExtension;
     /**
      * patternStrings contains both pattern strings (containing "*") and regular strings.
      * Return an exact match if possible, or a pattern match, or undefined.
@@ -25620,7 +25713,7 @@ var ts;
             return extendedConfigPath;
         }
         // If the path isn't a rooted or relative path, resolve like a module
-        var resolved = ts.nodeModuleNameResolver(extendedConfig, ts.combinePaths(basePath, "tsconfig.json"), { moduleResolution: ts.ModuleResolutionKind.NodeJs }, host, /*cache*/ undefined, /*projectRefs*/ undefined, /*lookupConfig*/ true);
+        var resolved = ts.nodeModuleNameResolver(".ts" /* Ts */, extendedConfig, ts.combinePaths(basePath, "tsconfig.json"), { moduleResolution: ts.ModuleResolutionKind.NodeJs }, host, /*cache*/ undefined, /*projectRefs*/ undefined, /*lookupConfig*/ true);
         if (resolved.resolvedModule) {
             return resolved.resolvedModule.resolvedFileName;
         }
@@ -26199,6 +26292,12 @@ var ts;
     function readPackageJsonMainField(jsonContent, baseDirectory, state) {
         return readPackageJsonPathField(jsonContent, "main", baseDirectory, state);
     }
+    function readPackageJsonReactNativeField(jsonContent, baseDirectory, state) {
+        return readPackageJsonPathField(jsonContent, "react-native", baseDirectory, state);
+    }
+    function readPackageJsonBrowserField(jsonContent, baseDirectory, state) {
+        return readPackageJsonPathField(jsonContent, "browser", baseDirectory, state);
+    }
     function readPackageJsonTypesVersionsField(jsonContent, state) {
         var typesVersions = readPackageJsonField(jsonContent, "typesVersions", "object", state);
         if (typesVersions === undefined)
@@ -26353,7 +26452,7 @@ var ts;
                     if (!directoryExists && traceEnabled) {
                         trace(host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, candidateDirectory);
                     }
-                    return resolvedTypeScriptOnly(loadNodeModuleFromDirectory(Extensions.DtsOnly, candidate, !directoryExists, moduleResolutionState));
+                    return resolvedTypeScriptOnly(loadNodeModuleFromDirectory(".ts" /* Ts */, Extensions.DtsOnly, candidate, !directoryExists, moduleResolutionState));
                 });
             }
             else {
@@ -26371,12 +26470,12 @@ var ts;
                 }
                 var result = void 0;
                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {
-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
+                    var searchResult = loadModuleFromNearestNodeModulesDirectory(".ts" /* Ts */, Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
                     result = searchResult && searchResult.value;
                 }
                 else {
                     var candidate = ts.normalizePathAndParts(ts.combinePaths(initialLocationForSecondaryLookup, typeReferenceDirectiveName)).path;
-                    result = nodeLoadModuleByRelativeName(Extensions.DtsOnly, candidate, /*onlyRecordFailures*/ false, moduleResolutionState, /*considerPackageJson*/ true);
+                    result = nodeLoadModuleByRelativeName(".ts" /* Ts */, Extensions.DtsOnly, candidate, /*onlyRecordFailures*/ false, moduleResolutionState, /*considerPackageJson*/ true);
                 }
                 var resolvedFile = resolvedTypeScriptOnly(result);
                 if (!resolvedFile && traceEnabled) {
@@ -26558,8 +26657,9 @@ var ts;
     ts.createModuleResolutionCacheWithMaps = createModuleResolutionCacheWithMaps;
     function resolveModuleNameFromCache(moduleName, containingFile, cache) {
         var containingDirectory = ts.getDirectoryPath(containingFile);
+        var parentFileExtension = ts.getFileExtension(containingFile);
         var perFolderCache = cache && cache.getOrCreateCacheForDirectory(containingDirectory);
-        return perFolderCache && perFolderCache.get(moduleName);
+        return perFolderCache && perFolderCache.get(moduleName + "|" + parentFileExtension);
     }
     ts.resolveModuleNameFromCache = resolveModuleNameFromCache;
     function resolveModuleName(moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
@@ -26574,8 +26674,10 @@ var ts;
             }
         }
         var containingDirectory = ts.getDirectoryPath(containingFile);
+        var parentFileExtension = ts.getFileExtension(containingFile);
+        var moduleNameKey = moduleName + "|" + parentFileExtension;
         var perFolderCache = cache && cache.getOrCreateCacheForDirectory(containingDirectory, redirectedReference);
-        var result = perFolderCache && perFolderCache.get(moduleName);
+        var result = perFolderCache && perFolderCache.get(moduleNameKey);
         if (result) {
             if (traceEnabled) {
                 trace(host, ts.Diagnostics.Resolution_for_module_0_was_found_in_cache_from_location_1, moduleName, containingDirectory);
@@ -26596,19 +26698,19 @@ var ts;
             }
             switch (moduleResolution) {
                 case ts.ModuleResolutionKind.NodeJs:
-                    result = nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
+                    result = nodeModuleNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
                     break;
                 case ts.ModuleResolutionKind.Classic:
-                    result = classicNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
+                    result = classicNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
                     break;
                 default:
                     return ts.Debug.fail("Unexpected moduleResolution: " + moduleResolution);
             }
             if (perFolderCache) {
-                perFolderCache.set(moduleName, result);
+                perFolderCache.set(moduleNameKey, result);
                 if (!ts.isExternalModuleNameRelative(moduleName)) {
                     // put result in per-module name cache
-                    cache.getOrCreateCacheForModuleName(moduleName, redirectedReference).set(containingDirectory, result);
+                    cache.getOrCreateCacheForModuleName(moduleNameKey, redirectedReference).set(containingDirectory, result);
                 }
             }
         }
@@ -26683,28 +26785,28 @@ var ts;
      * be converted to a path relative to found rootDir entry './content/protocols/file2' (*). As a last step compiler will check all remaining
      * entries in 'rootDirs', use them to build absolute path out of (*) and try to resolve module from this location.
      */
-    function tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loader, state) {
-        var resolved = tryLoadModuleUsingPathsIfEligible(extensions, moduleName, loader, state);
+    function tryLoadModuleUsingOptionalResolutionSettings(parentFileExtension, extensions, moduleName, containingDirectory, loader, state) {
+        var resolved = tryLoadModuleUsingPathsIfEligible(parentFileExtension, extensions, moduleName, loader, state);
         if (resolved)
             return resolved.value;
         if (!ts.isExternalModuleNameRelative(moduleName)) {
-            return tryLoadModuleUsingBaseUrl(extensions, moduleName, loader, state);
+            return tryLoadModuleUsingBaseUrl(parentFileExtension, extensions, moduleName, loader, state);
         }
         else {
-            return tryLoadModuleUsingRootDirs(extensions, moduleName, containingDirectory, loader, state);
+            return tryLoadModuleUsingRootDirs(parentFileExtension, extensions, moduleName, containingDirectory, loader, state);
         }
     }
-    function tryLoadModuleUsingPathsIfEligible(extensions, moduleName, loader, state) {
+    function tryLoadModuleUsingPathsIfEligible(parentFileExtension, extensions, moduleName, loader, state) {
         var _a = state.compilerOptions, baseUrl = _a.baseUrl, paths = _a.paths;
         if (baseUrl && paths && !ts.pathIsRelative(moduleName)) {
             if (state.traceEnabled) {
                 trace(state.host, ts.Diagnostics.baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1, baseUrl, moduleName);
                 trace(state.host, ts.Diagnostics.paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0, moduleName);
             }
-            return tryLoadModuleUsingPaths(extensions, moduleName, baseUrl, paths, loader, /*onlyRecordFailures*/ false, state);
+            return tryLoadModuleUsingPaths(parentFileExtension, extensions, moduleName, baseUrl, paths, loader, /*onlyRecordFailures*/ false, state);
         }
     }
-    function tryLoadModuleUsingRootDirs(extensions, moduleName, containingDirectory, loader, state) {
+    function tryLoadModuleUsingRootDirs(parentFileExtension, extensions, moduleName, containingDirectory, loader, state) {
         if (!state.compilerOptions.rootDirs) {
             return undefined;
         }
@@ -26742,7 +26844,7 @@ var ts;
             if (state.traceEnabled) {
                 trace(state.host, ts.Diagnostics.Loading_0_from_the_root_dir_1_candidate_location_2, suffix, matchedNormalizedPrefix, candidate);
             }
-            var resolvedFileName = loader(extensions, candidate, !ts.directoryProbablyExists(containingDirectory, state.host), state);
+            var resolvedFileName = loader(parentFileExtension, extensions, candidate, !ts.directoryProbablyExists(containingDirectory, state.host), state);
             if (resolvedFileName) {
                 return resolvedFileName;
             }
@@ -26761,7 +26863,7 @@ var ts;
                     trace(state.host, ts.Diagnostics.Loading_0_from_the_root_dir_1_candidate_location_2, suffix, rootDir, candidate_1);
                 }
                 var baseDirectory = ts.getDirectoryPath(candidate_1);
-                var resolvedFileName_1 = loader(extensions, candidate_1, !ts.directoryProbablyExists(baseDirectory, state.host), state);
+                var resolvedFileName_1 = loader(parentFileExtension, extensions, candidate_1, !ts.directoryProbablyExists(baseDirectory, state.host), state);
                 if (resolvedFileName_1) {
                     return resolvedFileName_1;
                 }
@@ -26772,7 +26874,7 @@ var ts;
         }
         return undefined;
     }
-    function tryLoadModuleUsingBaseUrl(extensions, moduleName, loader, state) {
+    function tryLoadModuleUsingBaseUrl(parentFileExtension, extensions, moduleName, loader, state) {
         var baseUrl = state.compilerOptions.baseUrl;
         if (!baseUrl) {
             return undefined;
@@ -26784,7 +26886,7 @@ var ts;
         if (state.traceEnabled) {
             trace(state.host, ts.Diagnostics.Resolving_module_name_0_relative_to_base_url_1_2, moduleName, baseUrl, candidate);
         }
-        return loader(extensions, candidate, !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
+        return loader(parentFileExtension, extensions, candidate, !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
     }
     /**
      * Expose resolution logic to allow us to use Node module resolution logic from arbitrary locations.
@@ -26793,7 +26895,7 @@ var ts;
      */
     /* @internal */
     function resolveJSModule(moduleName, initialDir, host) {
-        var _a = tryResolveJSModuleWorker(moduleName, initialDir, host), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
+        var _a = tryResolveJSModuleWorker(".ts" /* Ts */, moduleName, initialDir, host), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
         if (!resolvedModule) {
             throw new Error("Could not resolve JS module '" + moduleName + "' starting at '" + initialDir + "'. Looked in: " + failedLookupLocations.join(", "));
         }
@@ -26802,7 +26904,7 @@ var ts;
     ts.resolveJSModule = resolveJSModule;
     /* @internal */
     function tryResolveJSModule(moduleName, initialDir, host) {
-        var resolvedModule = tryResolveJSModuleWorker(moduleName, initialDir, host).resolvedModule;
+        var resolvedModule = tryResolveJSModuleWorker(".ts" /* Ts */, moduleName, initialDir, host).resolvedModule;
         return resolvedModule && resolvedModule.resolvedFileName;
     }
     ts.tryResolveJSModule = tryResolveJSModule;
@@ -26810,14 +26912,14 @@ var ts;
     var tsExtensions = [Extensions.TypeScript, Extensions.JavaScript];
     var tsPlusJsonExtensions = tsExtensions.concat([Extensions.Json]);
     var tsconfigExtensions = [Extensions.TSConfig];
-    function tryResolveJSModuleWorker(moduleName, initialDir, host) {
-        return nodeModuleNameResolverWorker(moduleName, initialDir, { moduleResolution: ts.ModuleResolutionKind.NodeJs, allowJs: true }, host, /*cache*/ undefined, jsOnlyExtensions, /*redirectedReferences*/ undefined);
+    function tryResolveJSModuleWorker(parentFileExtension, moduleName, initialDir, host) {
+        return nodeModuleNameResolverWorker(parentFileExtension, moduleName, initialDir, { moduleResolution: ts.ModuleResolutionKind.NodeJs, allowJs: true }, host, /*cache*/ undefined, jsOnlyExtensions, /*redirectedReferences*/ undefined);
     }
-    function nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference, lookupConfig) {
-        return nodeModuleNameResolverWorker(moduleName, ts.getDirectoryPath(containingFile), compilerOptions, host, cache, lookupConfig ? tsconfigExtensions : (compilerOptions.resolveJsonModule ? tsPlusJsonExtensions : tsExtensions), redirectedReference);
+    function nodeModuleNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference, lookupConfig) {
+        return nodeModuleNameResolverWorker(parentFileExtension, moduleName, ts.getDirectoryPath(containingFile), compilerOptions, host, cache, lookupConfig ? tsconfigExtensions : (compilerOptions.resolveJsonModule ? tsPlusJsonExtensions : tsExtensions), redirectedReference);
     }
     ts.nodeModuleNameResolver = nodeModuleNameResolver;
-    function nodeModuleNameResolverWorker(moduleName, containingDirectory, compilerOptions, host, cache, extensions, redirectedReference) {
+    function nodeModuleNameResolverWorker(parentFileExtension, moduleName, containingDirectory, compilerOptions, host, cache, extensions, redirectedReference) {
         var traceEnabled = isTraceEnabled(compilerOptions, host);
         var failedLookupLocations = [];
         var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations };
@@ -26828,8 +26930,8 @@ var ts;
         }
         return { resolvedModule: undefined, failedLookupLocations: failedLookupLocations };
         function tryResolve(extensions) {
-            var loader = function (extensions, candidate, onlyRecordFailures, state) { return nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ true); };
-            var resolved = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loader, state);
+            var loader = function (parentFileExtension, extensions, candidate, onlyRecordFailures, state) { return nodeLoadModuleByRelativeName(parentFileExtension, extensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ true); };
+            var resolved = tryLoadModuleUsingOptionalResolutionSettings(parentFileExtension, extensions, moduleName, containingDirectory, loader, state);
             if (resolved) {
                 return toSearchResult({ resolved: resolved, isExternalLibraryImport: pathContainsNodeModules(resolved.path) });
             }
@@ -26837,7 +26939,7 @@ var ts;
                 if (traceEnabled) {
                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);
                 }
-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
+                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(parentFileExtension, extensions, moduleName, containingDirectory, state, cache, redirectedReference);
                 if (!resolved_1)
                     return undefined;
                 var resolvedValue = resolved_1.value;
@@ -26851,7 +26953,7 @@ var ts;
             }
             else {
                 var _a = ts.normalizePathAndParts(ts.combinePaths(containingDirectory, moduleName)), candidate = _a.path, parts = _a.parts;
-                var resolved_2 = nodeLoadModuleByRelativeName(extensions, candidate, /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true);
+                var resolved_2 = nodeLoadModuleByRelativeName(parentFileExtension, extensions, candidate, /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true);
                 // Treat explicit "node_modules" import as an external library import.
                 return resolved_2 && toSearchResult({ resolved: resolved_2, isExternalLibraryImport: ts.contains(parts, "node_modules") });
             }
@@ -26868,7 +26970,7 @@ var ts;
         ts.Debug.assert(host.fileExists(real), path + " linked to nonexistent file " + real); // tslint:disable-line
         return real;
     }
-    function nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
+    function nodeLoadModuleByRelativeName(parentFileExtension, extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
         if (state.traceEnabled) {
             trace(state.host, ts.Diagnostics.Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1, candidate, Extensions[extensions]);
         }
@@ -26882,10 +26984,10 @@ var ts;
                     onlyRecordFailures = true;
                 }
             }
-            var resolvedFromFile = loadModuleFromFile(extensions, candidate, onlyRecordFailures, state);
+            var resolvedFromFile = loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state);
             if (resolvedFromFile) {
                 var nm = considerPackageJson ? parseNodeModuleFromPath(resolvedFromFile) : undefined;
-                var packageInfo = nm && getPackageJsonInfo(nm.packageDirectory, nm.subModuleName, /*onlyRecordFailures*/ false, state);
+                var packageInfo = nm && getPackageJsonInfo(parentFileExtension, nm.packageDirectory, nm.subModuleName, /*onlyRecordFailures*/ false, state);
                 var packageId = packageInfo && packageInfo.packageId;
                 return withPackageId(packageId, resolvedFromFile);
             }
@@ -26899,7 +27001,7 @@ var ts;
                 onlyRecordFailures = true;
             }
         }
-        return loadNodeModuleFromDirectory(extensions, candidate, onlyRecordFailures, state, considerPackageJson);
+        return loadNodeModuleFromDirectory(parentFileExtension, extensions, candidate, onlyRecordFailures, state, considerPackageJson);
     }
     /*@internal*/
     ts.nodeModulesPathPart = "/node_modules/";
@@ -26950,20 +27052,20 @@ var ts;
         }
         return path + "/index.d.ts";
     }
-    function loadModuleFromFileNoPackageId(extensions, candidate, onlyRecordFailures, state) {
-        return noPackageId(loadModuleFromFile(extensions, candidate, onlyRecordFailures, state));
+    function loadModuleFromFileNoPackageId(parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
+        return noPackageId(loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state));
     }
     /**
      * @param {boolean} onlyRecordFailures - if true then function won't try to actually load files but instead record all attempts as failures. This flag is necessary
      * in cases when we know upfront that all load attempts will fail (because containing folder does not exists) however we still need to record all failed lookup locations.
      */
-    function loadModuleFromFile(extensions, candidate, onlyRecordFailures, state) {
+    function loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
         if (extensions === Extensions.Json || extensions === Extensions.TSConfig) {
             var extensionLess = ts.tryRemoveExtension(candidate, ".json" /* Json */);
-            return (extensionLess === undefined && extensions === Extensions.Json) ? undefined : tryAddingExtensions(extensionLess || candidate, extensions, onlyRecordFailures, state);
+            return (extensionLess === undefined && extensions === Extensions.Json) ? undefined : tryAddingExtensions(parentFileExtension, extensionLess || candidate, extensions, onlyRecordFailures, state);
         }
         // First, try adding an extension. An import of "foo" could be matched by a file "foo.ts", or "foo.js" by "foo.js.ts"
-        var resolvedByAddingExtension = tryAddingExtensions(candidate, extensions, onlyRecordFailures, state);
+        var resolvedByAddingExtension = tryAddingExtensions(parentFileExtension, candidate, extensions, onlyRecordFailures, state);
         if (resolvedByAddingExtension) {
             return resolvedByAddingExtension;
         }
@@ -26975,11 +27077,11 @@ var ts;
                 var extension = candidate.substring(extensionless.length);
                 trace(state.host, ts.Diagnostics.File_name_0_has_a_1_extension_stripping_it, candidate, extension);
             }
-            return tryAddingExtensions(extensionless, extensions, onlyRecordFailures, state);
+            return tryAddingExtensions(parentFileExtension, extensionless, extensions, onlyRecordFailures, state);
         }
     }
     /** Try to return an existing file that adds one of the `extensions` to `candidate`. */
-    function tryAddingExtensions(candidate, extensions, onlyRecordFailures, state) {
+    function tryAddingExtensions(parentFileExtension, candidate, extensions, onlyRecordFailures, state) {
         if (!onlyRecordFailures) {
             // check if containing folder exists - if it doesn't then just record failures for all supported extensions without disk probing
             var directory = ts.getDirectoryPath(candidate);
@@ -26987,16 +27089,212 @@ var ts;
                 onlyRecordFailures = !ts.directoryProbablyExists(directory, state.host);
             }
         }
-        switch (extensions) {
-            case Extensions.DtsOnly:
-                return tryExtension(".d.ts" /* Dts */);
-            case Extensions.TypeScript:
-                return tryExtension(".ts" /* Ts */) || tryExtension(".tsx" /* Tsx */) || tryExtension(".d.ts" /* Dts */);
-            case Extensions.JavaScript:
-                return tryExtension(".js" /* Js */) || tryExtension(".jsx" /* Jsx */);
-            case Extensions.TSConfig:
-            case Extensions.Json:
-                return tryExtension(".json" /* Json */);
+        switch (parentFileExtension) {
+            case ".web.ts" /* WebTs */:
+            case ".web.tsx" /* WebTsx */:
+            case ".web.js" /* WebJs */:
+            case ".web.jsx" /* WebJsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".web.json" /* WebJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".web.js" /* WebJs */) ||
+                            tryExtension(".web.jsx" /* WebJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".web.ts" /* WebTs */) ||
+                            tryExtension(".web.tsx" /* WebTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".native.js" /* NativeJs */:
+            case ".native.jsx" /* NativeJsx */:
+            case ".native.ts" /* NativeTs */:
+            case ".native.tsx" /* NativeTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".json" /* Json */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".ios.json" /* IosJson */) ||
+                            tryExtension(".android.json" /* AndroidJson */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".ios.js" /* IosJs */) ||
+                            tryExtension(".ios.jsx" /* IosJsx */) ||
+                            tryExtension(".android.js" /* AndroidJs */) ||
+                            tryExtension(".android.jsx" /* AndroidJsx */));
+                    }
+                    default: {
+                        return (tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ios.ts" /* IosTs */) ||
+                            tryExtension(".ios.tsx" /* IosTsx */) ||
+                            tryExtension(".android.ts" /* AndroidTs */) ||
+                            tryExtension(".android.tsx" /* AndroidTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".ios.js" /* IosJs */:
+            case ".ios.jsx" /* IosJsx */:
+            case ".ios.ts" /* IosTs */:
+            case ".ios.tsx" /* IosTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".ios.json" /* IosJson */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".ios.js" /* IosJs */) ||
+                            tryExtension(".ios.jsx" /* IosJsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".ios.ts" /* IosTs */) ||
+                            tryExtension(".ios.tsx" /* IosTsx */) ||
+                            tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".android.js" /* AndroidJs */:
+            case ".android.jsx" /* AndroidJsx */:
+            case ".android.ts" /* AndroidTs */:
+            case ".android.tsx" /* AndroidTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".android.json" /* AndroidJson */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".android.js" /* AndroidJs */) ||
+                            tryExtension(".android.jsx" /* AndroidJsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".android.ts" /* AndroidTs */) ||
+                            tryExtension(".android.tsx" /* AndroidTsx */) ||
+                            tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".node.js" /* NodeJs */:
+            case ".node.jsx" /* NodeJsx */:
+            case ".node.ts" /* NodeTs */:
+            case ".node.tsx" /* NodeTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".node.json" /* NodeJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".node.js" /* NodeJs */) ||
+                            tryExtension(".node.jsx" /* NodeJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".node.ts" /* NodeTs */) ||
+                            tryExtension(".node.tsx" /* NodeTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            default: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".json" /* Json */) ||
+                            tryExtension(".node.json" /* NodeJson */) ||
+                            tryExtension(".web.json" /* WebJson */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".ios.json" /* IosJson */) ||
+                            tryExtension(".android.json" /* AndroidJson */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */) ||
+                            tryExtension(".node.js" /* NodeJs */) ||
+                            tryExtension(".node.jsx" /* NodeJsx */) ||
+                            tryExtension(".web.js" /* WebJs */) ||
+                            tryExtension(".web.jsx" /* WebJsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".ios.js" /* IosJs */) ||
+                            tryExtension(".ios.jsx" /* IosJsx */) ||
+                            tryExtension(".android.js" /* AndroidJs */) ||
+                            tryExtension(".android.jsx" /* AndroidJsx */));
+                    }
+                    default: {
+                        return (tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */) ||
+                            tryExtension(".node.ts" /* NodeTs */) ||
+                            tryExtension(".node.tsx" /* NodeTsx */) ||
+                            tryExtension(".web.ts" /* WebTs */) ||
+                            tryExtension(".web.tsx" /* WebTsx */) ||
+                            tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ios.ts" /* IosTs */) ||
+                            tryExtension(".ios.tsx" /* IosTsx */) ||
+                            tryExtension(".android.ts" /* AndroidTs */) ||
+                            tryExtension(".android.tsx" /* AndroidTsx */));
+                    }
+                }
+            }
         }
         function tryExtension(ext) {
             var path = tryFile(candidate + ext, onlyRecordFailures, state);
@@ -27021,15 +27319,15 @@ var ts;
         state.failedLookupLocations.push(fileName);
         return undefined;
     }
-    function loadNodeModuleFromDirectory(extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
+    function loadNodeModuleFromDirectory(parentFileExtension, extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
         if (considerPackageJson === void 0) { considerPackageJson = true; }
-        var packageInfo = considerPackageJson ? getPackageJsonInfo(candidate, "", onlyRecordFailures, state) : undefined;
+        var packageInfo = considerPackageJson ? getPackageJsonInfo(parentFileExtension, candidate, "", onlyRecordFailures, state) : undefined;
         var packageId = packageInfo && packageInfo.packageId;
         var packageJsonContent = packageInfo && packageInfo.packageJsonContent;
         var versionPaths = packageJsonContent && readPackageJsonTypesVersionPaths(packageJsonContent, state);
-        return withPackageId(packageId, loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths));
+        return withPackageId(packageId, loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths));
     }
-    function getPackageJsonInfo(packageDirectory, subModuleName, onlyRecordFailures, state) {
+    function getPackageJsonInfo(parentFileExtension, packageDirectory, subModuleName, onlyRecordFailures, state) {
         var host = state.host, traceEnabled = state.traceEnabled;
         var directoryExists = !onlyRecordFailures && ts.directoryProbablyExists(packageDirectory, host);
         var packageJsonPath = ts.combinePaths(packageDirectory, "package.json");
@@ -27041,7 +27339,34 @@ var ts;
                     subModuleName = addExtensionAndIndex(path.substring(packageDirectory.length + 1));
                 }
                 else {
-                    var jsPath = readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                    var jsPath = void 0;
+                    switch (parentFileExtension) {
+                        case ".android.js" /* AndroidJs */:
+                        case ".ios.js" /* IosJs */:
+                        case ".native.js" /* NativeJs */:
+                        case ".android.jsx" /* AndroidJsx */:
+                        case ".ios.jsx" /* IosJsx */:
+                        case ".native.jsx" /* NativeJsx */:
+                        case ".android.ts" /* AndroidTs */:
+                        case ".ios.ts" /* IosTs */:
+                        case ".native.ts" /* NativeTs */:
+                        case ".android.tsx" /* AndroidTsx */:
+                        case ".ios.tsx" /* IosTsx */:
+                        case ".native.tsx" /* NativeTsx */: {
+                            jsPath = readPackageJsonReactNativeField(packageJsonContent, packageDirectory, state) || readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                            break;
+                        }
+                        case ".web.js" /* WebJs */:
+                        case ".web.jsx" /* WebJsx */:
+                        case ".web.ts" /* WebTs */:
+                        case ".web.tsx" /* WebTsx */: {
+                            jsPath = readPackageJsonBrowserField(packageJsonContent, packageDirectory, state) || readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                            break;
+                        }
+                        default: {
+                            jsPath = readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                        }
+                    }
                     if (typeof jsPath === "string" && jsPath.length > packageDirectory.length) {
                         var potentialSubModule_1 = jsPath.substring(packageDirectory.length + 1);
                         subModuleName = (ts.forEach(ts.supportedJSExtensions, function (extension) {
@@ -27058,7 +27383,7 @@ var ts;
             }
             var versionPaths = readPackageJsonTypesVersionPaths(packageJsonContent, state);
             var packageId = typeof packageJsonContent.name === "string" && typeof packageJsonContent.version === "string"
-                ? { name: packageJsonContent.name, subModuleName: subModuleName, version: packageJsonContent.version }
+                ? { name: packageJsonContent.name + "|" + parentFileExtension, subModuleName: subModuleName, version: packageJsonContent.version }
                 : undefined;
             if (traceEnabled) {
                 if (packageId) {
@@ -27078,18 +27403,79 @@ var ts;
             state.failedLookupLocations.push(packageJsonPath);
         }
     }
-    function loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, jsonContent, versionPaths) {
+    function loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, onlyRecordFailures, state, jsonContent, versionPaths) {
         var packageFile;
         if (jsonContent) {
             switch (extensions) {
                 case Extensions.JavaScript:
-                case Extensions.Json:
-                    packageFile = readPackageJsonMainField(jsonContent, candidate, state);
+                case Extensions.Json: {
+                    switch (parentFileExtension) {
+                        case ".android.js" /* AndroidJs */:
+                        case ".ios.js" /* IosJs */:
+                        case ".native.js" /* NativeJs */:
+                        case ".android.jsx" /* AndroidJsx */:
+                        case ".ios.jsx" /* IosJsx */:
+                        case ".native.jsx" /* NativeJsx */:
+                        case ".android.ts" /* AndroidTs */:
+                        case ".ios.ts" /* IosTs */:
+                        case ".native.ts" /* NativeTs */:
+                        case ".android.tsx" /* AndroidTsx */:
+                        case ".ios.tsx" /* IosTsx */:
+                        case ".native.tsx" /* NativeTsx */: {
+                            packageFile = readPackageJsonReactNativeField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        case ".web.js" /* WebJs */:
+                        case ".web.jsx" /* WebJsx */:
+                        case ".web.ts" /* WebTs */:
+                        case ".web.tsx" /* WebTsx */: {
+                            packageFile = readPackageJsonBrowserField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        default: {
+                            packageFile = readPackageJsonMainField(jsonContent, candidate, state);
+                        }
+                    }
                     break;
-                case Extensions.TypeScript:
-                    // When resolving typescript modules, try resolving using main field as well
-                    packageFile = readPackageJsonTypesFields(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                }
+                case Extensions.TypeScript: {
+                    switch (parentFileExtension) {
+                        case ".android.js" /* AndroidJs */:
+                        case ".ios.js" /* IosJs */:
+                        case ".native.js" /* NativeJs */:
+                        case ".android.jsx" /* AndroidJsx */:
+                        case ".ios.jsx" /* IosJsx */:
+                        case ".native.jsx" /* NativeJsx */:
+                        case ".android.ts" /* AndroidTs */:
+                        case ".ios.ts" /* IosTs */:
+                        case ".native.ts" /* NativeTs */:
+                        case ".android.tsx" /* AndroidTsx */:
+                        case ".ios.tsx" /* IosTsx */:
+                        case ".native.tsx" /* NativeTsx */: {
+                            packageFile = readPackageJsonReactNativeField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        case ".web.js" /* WebJs */:
+                        case ".web.jsx" /* WebJsx */:
+                        case ".web.ts" /* WebTs */:
+                        case ".web.tsx" /* WebTsx */: {
+                            packageFile = readPackageJsonBrowserField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        case ".node.js" /* NodeJs */:
+                        case ".node.jsx" /* NodeJsx */:
+                        case ".node.ts" /* NodeTs */:
+                        case ".node.tsx" /* NodeTsx */: {
+                            packageFile = readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        default: {
+                            // When resolving typescript modules, try resolving using main field as well
+                            packageFile = readPackageJsonTypesFields(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                        }
+                    }
                     break;
+                }
                 case Extensions.DtsOnly:
                     packageFile = readPackageJsonTypesFields(jsonContent, candidate, state);
                     break;
@@ -27100,7 +27486,7 @@ var ts;
                     return ts.Debug.assertNever(extensions);
             }
         }
-        var loader = function (extensions, candidate, onlyRecordFailures, state) {
+        var loader = function (parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
             var fromFile = tryFile(candidate, onlyRecordFailures, state);
             if (fromFile) {
                 var resolved = resolvedIfExtensionMatches(extensions, fromFile);
@@ -27114,7 +27500,7 @@ var ts;
             // Even if extensions is DtsOnly, we can still look up a .ts file as a result of package.json "types"
             var nextExtensions = extensions === Extensions.DtsOnly ? Extensions.TypeScript : extensions;
             // Don't do package.json lookup recursively, because Node.js' package lookup doesn't.
-            return nodeLoadModuleByRelativeName(nextExtensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ false);
+            return nodeLoadModuleByRelativeName(parentFileExtension, nextExtensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ false);
         };
         var onlyRecordFailuresForPackageFile = packageFile ? !ts.directoryProbablyExists(ts.getDirectoryPath(packageFile), state.host) : undefined;
         var onlyRecordFailuresForIndex = onlyRecordFailures || !ts.directoryProbablyExists(candidate, state.host);
@@ -27124,16 +27510,16 @@ var ts;
             if (state.traceEnabled) {
                 trace(state.host, ts.Diagnostics.package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2, versionPaths.version, ts.version, moduleName);
             }
-            var result = tryLoadModuleUsingPaths(extensions, moduleName, candidate, versionPaths.paths, loader, onlyRecordFailuresForPackageFile || onlyRecordFailuresForIndex, state);
+            var result = tryLoadModuleUsingPaths(parentFileExtension, extensions, moduleName, candidate, versionPaths.paths, loader, onlyRecordFailuresForPackageFile || onlyRecordFailuresForIndex, state);
             if (result) {
                 return removeIgnoredPackageId(result.value);
             }
         }
         // It won't have a `packageId` set, because we disabled `considerPackageJson`.
-        var packageFileResult = packageFile && removeIgnoredPackageId(loader(extensions, packageFile, onlyRecordFailuresForPackageFile, state));
+        var packageFileResult = packageFile && removeIgnoredPackageId(loader(parentFileExtension, extensions, packageFile, onlyRecordFailuresForPackageFile, state));
         if (packageFileResult)
             return packageFileResult;
-        return loadModuleFromFile(extensions, indexPath, onlyRecordFailuresForIndex, state);
+        return loadModuleFromFile(parentFileExtension, extensions, indexPath, onlyRecordFailuresForIndex, state);
     }
     /** Resolve from an arbitrarily specified file. Return `undefined` if it has an unsupported extension. */
     function resolvedIfExtensionMatches(extensions, path) {
@@ -27144,12 +27530,40 @@ var ts;
     function extensionIsOk(extensions, extension) {
         switch (extensions) {
             case Extensions.JavaScript:
-                return extension === ".js" /* Js */ || extension === ".jsx" /* Jsx */;
+                return (extension === ".js" /* Js */ ||
+                    extension === ".jsx" /* Jsx */ ||
+                    extension === ".node.js" /* NodeJs */ ||
+                    extension === ".node.jsx" /* NodeJsx */ ||
+                    extension === ".web.js" /* WebJs */ ||
+                    extension === ".web.jsx" /* WebJsx */ ||
+                    extension === ".native.js" /* NativeJs */ ||
+                    extension === ".native.jsx" /* NativeJsx */ ||
+                    extension === ".ios.js" /* IosJs */ ||
+                    extension === ".ios.jsx" /* IosJsx */ ||
+                    extension === ".android.js" /* AndroidJs */ ||
+                    extension === ".android.jsx" /* AndroidJsx */);
             case Extensions.TSConfig:
             case Extensions.Json:
-                return extension === ".json" /* Json */;
+                return (extension === ".json" /* Json */ ||
+                    extension === ".node.json" /* NodeJson */ ||
+                    extension === ".web.json" /* WebJson */ ||
+                    extension === ".native.json" /* NativeJson */ ||
+                    extension === ".ios.json" /* IosJson */ ||
+                    extension === ".android.json" /* AndroidJson */);
             case Extensions.TypeScript:
-                return extension === ".ts" /* Ts */ || extension === ".tsx" /* Tsx */ || extension === ".d.ts" /* Dts */;
+                return (extension === ".ts" /* Ts */ ||
+                    extension === ".tsx" /* Tsx */ ||
+                    extension === ".d.ts" /* Dts */ ||
+                    extension === ".node.ts" /* NodeTs */ ||
+                    extension === ".node.tsx" /* NodeTsx */ ||
+                    extension === ".web.ts" /* WebTs */ ||
+                    extension === ".web.tsx" /* WebTsx */ ||
+                    extension === ".native.ts" /* NativeTs */ ||
+                    extension === ".native.tsx" /* NativeTsx */ ||
+                    extension === ".ios.ts" /* IosTs */ ||
+                    extension === ".ios.tsx" /* IosTsx */ ||
+                    extension === ".android.ts" /* AndroidTs */ ||
+                    extension === ".android.tsx" /* AndroidTsx */);
             case Extensions.DtsOnly:
                 return extension === ".d.ts" /* Dts */;
         }
@@ -27163,32 +27577,33 @@ var ts;
         return idx === -1 ? { packageName: moduleName, rest: "" } : { packageName: moduleName.slice(0, idx), rest: moduleName.slice(idx + 1) };
     }
     ts.parsePackageName = parsePackageName;
-    function loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, directory, state, cache, redirectedReference) {
-        return loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName, directory, state, /*typesScopeOnly*/ false, cache, redirectedReference);
+    function loadModuleFromNearestNodeModulesDirectory(parentFileExtension, extensions, moduleName, directory, state, cache, redirectedReference) {
+        return loadModuleFromNearestNodeModulesDirectoryWorker(parentFileExtension, extensions, moduleName, directory, state, /*typesScopeOnly*/ false, cache, redirectedReference);
     }
     function loadModuleFromNearestNodeModulesDirectoryTypesScope(moduleName, directory, state) {
         // Extensions parameter here doesn't actually matter, because typesOnly ensures we're just doing @types lookup, which is always DtsOnly.
-        return loadModuleFromNearestNodeModulesDirectoryWorker(Extensions.DtsOnly, moduleName, directory, state, /*typesScopeOnly*/ true, /*cache*/ undefined, /*redirectedReference*/ undefined);
+        return loadModuleFromNearestNodeModulesDirectoryWorker(".ts" /* Ts */, Extensions.DtsOnly, moduleName, directory, state, /*typesScopeOnly*/ true, /*cache*/ undefined, /*redirectedReference*/ undefined);
     }
-    function loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
-        var perModuleNameCache = cache && cache.getOrCreateCacheForModuleName(moduleName, redirectedReference);
+    function loadModuleFromNearestNodeModulesDirectoryWorker(parentFileExtension, extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
+        var moduleNameKey = moduleName + "|" + parentFileExtension;
+        var perModuleNameCache = cache && cache.getOrCreateCacheForModuleName(moduleNameKey, redirectedReference);
         return ts.forEachAncestorDirectory(ts.normalizeSlashes(directory), function (ancestorDirectory) {
             if (ts.getBaseFileName(ancestorDirectory) !== "node_modules") {
                 var resolutionFromCache = tryFindNonRelativeModuleNameInCache(perModuleNameCache, moduleName, ancestorDirectory, state);
                 if (resolutionFromCache) {
                     return resolutionFromCache;
                 }
-                return toSearchResult(loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, ancestorDirectory, state, typesScopeOnly));
+                return toSearchResult(loadModuleFromImmediateNodeModulesDirectory(parentFileExtension, extensions, moduleName, ancestorDirectory, state, typesScopeOnly));
             }
         });
     }
-    function loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, directory, state, typesScopeOnly) {
+    function loadModuleFromImmediateNodeModulesDirectory(parentFileExtension, extensions, moduleName, directory, state, typesScopeOnly) {
         var nodeModulesFolder = ts.combinePaths(directory, "node_modules");
         var nodeModulesFolderExists = ts.directoryProbablyExists(nodeModulesFolder, state.host);
         if (!nodeModulesFolderExists && state.traceEnabled) {
             trace(state.host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, nodeModulesFolder);
         }
-        var packageResult = typesScopeOnly ? undefined : loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesFolder, nodeModulesFolderExists, state);
+        var packageResult = typesScopeOnly ? undefined : loadModuleFromSpecificNodeModulesDirectory(parentFileExtension, extensions, moduleName, nodeModulesFolder, nodeModulesFolderExists, state);
         if (packageResult) {
             return packageResult;
         }
@@ -27201,35 +27616,35 @@ var ts;
                 }
                 nodeModulesAtTypesExists = false;
             }
-            return loadModuleFromSpecificNodeModulesDirectory(Extensions.DtsOnly, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes_1, nodeModulesAtTypesExists, state);
+            return loadModuleFromSpecificNodeModulesDirectory(parentFileExtension, Extensions.DtsOnly, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes_1, nodeModulesAtTypesExists, state);
         }
     }
-    function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state) {
+    function loadModuleFromSpecificNodeModulesDirectory(parentFileExtension, extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state) {
         var candidate = ts.normalizePath(ts.combinePaths(nodeModulesDirectory, moduleName));
         // First look for a nested package.json, as in `node_modules/foo/bar/package.json`.
         var packageJsonContent;
         var packageId;
         var versionPaths;
-        var packageInfo = getPackageJsonInfo(candidate, "", !nodeModulesDirectoryExists, state);
+        var packageInfo = getPackageJsonInfo(parentFileExtension, candidate, "", !nodeModulesDirectoryExists, state);
         if (packageInfo) {
             (packageJsonContent = packageInfo.packageJsonContent, packageId = packageInfo.packageId, versionPaths = packageInfo.versionPaths);
-            var fromFile = loadModuleFromFile(extensions, candidate, !nodeModulesDirectoryExists, state);
+            var fromFile = loadModuleFromFile(parentFileExtension, extensions, candidate, !nodeModulesDirectoryExists, state);
             if (fromFile) {
                 return noPackageId(fromFile);
             }
-            var fromDirectory = loadNodeModuleFromDirectoryWorker(extensions, candidate, !nodeModulesDirectoryExists, state, packageJsonContent, versionPaths);
+            var fromDirectory = loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, !nodeModulesDirectoryExists, state, packageJsonContent, versionPaths);
             return withPackageId(packageId, fromDirectory);
         }
-        var loader = function (extensions, candidate, onlyRecordFailures, state) {
-            var pathAndExtension = loadModuleFromFile(extensions, candidate, onlyRecordFailures, state) ||
-                loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths);
+        var loader = function (parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
+            var pathAndExtension = loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state) ||
+                loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths);
             return withPackageId(packageId, pathAndExtension);
         };
         var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;
         if (rest !== "") { // If "rest" is empty, we just did this search above.
             var packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
             // Don't use a "types" or "main" from here because we're not loading the root, but a subdirectory -- just here for the packageId and path mappings.
-            var packageInfo_1 = getPackageJsonInfo(packageDirectory, rest, !nodeModulesDirectoryExists, state);
+            var packageInfo_1 = getPackageJsonInfo(parentFileExtension, packageDirectory, rest, !nodeModulesDirectoryExists, state);
             if (packageInfo_1)
                 (packageId = packageInfo_1.packageId, versionPaths = packageInfo_1.versionPaths);
             if (versionPaths) {
@@ -27237,15 +27652,15 @@ var ts;
                     trace(state.host, ts.Diagnostics.package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2, versionPaths.version, ts.version, rest);
                 }
                 var packageDirectoryExists = nodeModulesDirectoryExists && ts.directoryProbablyExists(packageDirectory, state.host);
-                var fromPaths = tryLoadModuleUsingPaths(extensions, rest, packageDirectory, versionPaths.paths, loader, !packageDirectoryExists, state);
+                var fromPaths = tryLoadModuleUsingPaths(parentFileExtension, extensions, rest, packageDirectory, versionPaths.paths, loader, !packageDirectoryExists, state);
                 if (fromPaths) {
                     return fromPaths.value;
                 }
             }
         }
-        return loader(extensions, candidate, !nodeModulesDirectoryExists, state);
+        return loader(parentFileExtension, extensions, candidate, !nodeModulesDirectoryExists, state);
     }
-    function tryLoadModuleUsingPaths(extensions, moduleName, baseDirectory, paths, loader, onlyRecordFailures, state) {
+    function tryLoadModuleUsingPaths(parentFileExtension, extensions, moduleName, baseDirectory, paths, loader, onlyRecordFailures, state) {
         var matchedPattern = ts.matchPatternOrExact(ts.getOwnKeys(paths), moduleName);
         if (matchedPattern) {
             var matchedStar_1 = ts.isString(matchedPattern) ? undefined : ts.matchedText(matchedPattern, moduleName);
@@ -27267,7 +27682,7 @@ var ts;
                         return noPackageId({ path: path_1, ext: extension });
                     }
                 }
-                return loader(extensions, candidate, onlyRecordFailures || !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
+                return loader(parentFileExtension, extensions, candidate, onlyRecordFailures || !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
             });
             return { value: resolved };
         }
@@ -27325,7 +27740,7 @@ var ts;
             return { value: result.resolvedModule && { path: result.resolvedModule.resolvedFileName, originalPath: result.resolvedModule.originalPath || true, extension: result.resolvedModule.extension, packageId: result.resolvedModule.packageId } };
         }
     }
-    function classicNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
+    function classicNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
         var traceEnabled = isTraceEnabled(compilerOptions, host);
         var failedLookupLocations = [];
         var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations };
@@ -27334,7 +27749,7 @@ var ts;
         // No originalPath because classic resolution doesn't resolve realPath
         return createResolvedModuleWithFailedLookupLocations(resolved && resolved.value, /*isExternalLibraryImport*/ false, failedLookupLocations);
         function tryResolve(extensions) {
-            var resolvedUsingSettings = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loadModuleFromFileNoPackageId, state);
+            var resolvedUsingSettings = tryLoadModuleUsingOptionalResolutionSettings(parentFileExtension, extensions, moduleName, containingDirectory, loadModuleFromFileNoPackageId, state);
             if (resolvedUsingSettings) {
                 return { value: resolvedUsingSettings };
             }
@@ -27347,7 +27762,7 @@ var ts;
                         return resolutionFromCache;
                     }
                     var searchName = ts.normalizePath(ts.combinePaths(directory, moduleName));
-                    return toSearchResult(loadModuleFromFileNoPackageId(extensions, searchName, /*onlyRecordFailures*/ false, state));
+                    return toSearchResult(loadModuleFromFileNoPackageId(parentFileExtension, extensions, searchName, /*onlyRecordFailures*/ false, state));
                 });
                 if (resolved_3) {
                     return resolved_3;
@@ -27359,7 +27774,7 @@ var ts;
             }
             else {
                 var candidate = ts.normalizePath(ts.combinePaths(containingDirectory, moduleName));
-                return toSearchResult(loadModuleFromFileNoPackageId(extensions, candidate, /*onlyRecordFailures*/ false, state));
+                return toSearchResult(loadModuleFromFileNoPackageId(parentFileExtension, extensions, candidate, /*onlyRecordFailures*/ false, state));
             }
         }
     }
@@ -27369,14 +27784,15 @@ var ts;
      * This is the minumum code needed to expose that functionality; the rest is in LSHost.
      */
     /* @internal */
-    function loadModuleFromGlobalCache(moduleName, projectName, compilerOptions, host, globalCache) {
+    function loadModuleFromGlobalCache(moduleName, containingFile, projectName, compilerOptions, host, globalCache) {
         var traceEnabled = isTraceEnabled(compilerOptions, host);
         if (traceEnabled) {
             trace(host, ts.Diagnostics.Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2, projectName, moduleName, globalCache);
         }
         var failedLookupLocations = [];
         var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations };
-        var resolved = loadModuleFromImmediateNodeModulesDirectory(Extensions.DtsOnly, moduleName, globalCache, state, /*typesScopeOnly*/ false);
+        var parentFileContext = ts.getFileExtension(containingFile);
+        var resolved = loadModuleFromImmediateNodeModulesDirectory(parentFileContext, Extensions.DtsOnly, moduleName, globalCache, state, /*typesScopeOnly*/ false);
         return createResolvedModuleWithFailedLookupLocations(resolved, /*isExternalLibraryImport*/ true, failedLookupLocations);
     }
     ts.loadModuleFromGlobalCache = loadModuleFromGlobalCache;
@@ -90443,16 +90859,41 @@ var ts;
         var extension = _a.extension;
         switch (extension) {
             case ".ts" /* Ts */:
+            case ".node.ts" /* NodeTs */:
+            case ".web.ts" /* WebTs */:
+            case ".native.ts" /* NativeTs */:
+            case ".ios.ts" /* IosTs */:
+            case ".android.ts" /* AndroidTs */:
             case ".d.ts" /* Dts */:
                 // These are always allowed.
                 return undefined;
             case ".tsx" /* Tsx */:
+            case ".node.tsx" /* NodeTsx */:
+            case ".web.tsx" /* WebTsx */:
+            case ".native.tsx" /* NativeTsx */:
+            case ".ios.tsx" /* IosTsx */:
+            case ".android.tsx" /* AndroidTsx */:
                 return needJsx();
             case ".jsx" /* Jsx */:
+            case ".node.jsx" /* NodeJsx */:
+            case ".web.jsx" /* WebJsx */:
+            case ".native.jsx" /* NativeJsx */:
+            case ".ios.jsx" /* IosJsx */:
+            case ".android.jsx" /* AndroidJsx */:
                 return needJsx() || needAllowJs();
             case ".js" /* Js */:
+            case ".node.js" /* NodeJs */:
+            case ".web.js" /* WebJs */:
+            case ".native.js" /* NativeJs */:
+            case ".ios.js" /* IosJs */:
+            case ".android.js" /* AndroidJs */:
                 return needAllowJs();
             case ".json" /* Json */:
+            case ".node.json" /* NodeJson */:
+            case ".web.json" /* WebJson */:
+            case ".native.json" /* NativeJson */:
+            case ".ios.json" /* IosJson */:
+            case ".android.json" /* AndroidJson */:
                 return needResolveJsonModule();
         }
         function needJsx() {
@@ -91863,7 +92304,7 @@ var ts;
             if (globalCache !== undefined && !ts.isExternalModuleNameRelative(moduleName) && !(primaryResult.resolvedModule && ts.extensionIsTS(primaryResult.resolvedModule.extension))) {
                 // create different collection of failed lookup locations for second pass
                 // if it will fail and we've already found something during the first pass - we don't want to pollute its results
-                var _a = ts.loadModuleFromGlobalCache(moduleName, resolutionHost.projectName, compilerOptions, host, globalCache), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
+                var _a = ts.loadModuleFromGlobalCache(moduleName, containingFile, resolutionHost.projectName, compilerOptions, host, globalCache), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
                 if (resolvedModule) {
                     return { resolvedModule: resolvedModule, failedLookupLocations: ts.addRange(primaryResult.failedLookupLocations, failedLookupLocations) };
                 }
@@ -91873,7 +92314,9 @@ var ts;
         }
         function resolveNamesWithLocalCache(names, containingFile, redirectedReference, cache, perDirectoryCacheWithRedirects, loader, getResolutionWithResolvedFileName, shouldRetryResolution, reusedNames, logChanges) {
             var path = resolutionHost.toPath(containingFile);
-            var resolutionsInFile = cache.get(path) || cache.set(path, ts.createMap()).get(path);
+            var context = ts.getFileExtension(containingFile);
+            var pathKey = path + "|" + context;
+            var resolutionsInFile = cache.get(pathKey) || cache.set(pathKey, ts.createMap()).get(pathKey);
             var dirPath = ts.getDirectoryPath(path);
             var perDirectoryCache = perDirectoryCacheWithRedirects.getOrCreateMapOfCacheRedirects(redirectedReference);
             var perDirectoryResolution = perDirectoryCache.get(dirPath);
@@ -91893,22 +92336,23 @@ var ts;
             var seenNamesInFile = ts.createMap();
             for (var _i = 0, names_2 = names; _i < names_2.length; _i++) {
                 var name = names_2[_i];
-                var resolution = resolutionsInFile.get(name);
+                var nameKey = name + "|" + context;
+                var resolution = resolutionsInFile.get(nameKey);
                 // Resolution is valid if it is present and not invalidated
-                if (!seenNamesInFile.has(name) &&
+                if (!seenNamesInFile.has(nameKey) &&
                     allFilesHaveInvalidatedResolution || unmatchedRedirects || !resolution || resolution.isInvalidated ||
                     // If the name is unresolved import that was invalidated, recalculate
                     (hasInvalidatedNonRelativeUnresolvedImport && !ts.isExternalModuleNameRelative(name) && shouldRetryResolution(resolution))) {
                     var existingResolution = resolution;
-                    var resolutionInDirectory = perDirectoryResolution.get(name);
+                    var resolutionInDirectory = perDirectoryResolution.get(nameKey);
                     if (resolutionInDirectory) {
                         resolution = resolutionInDirectory;
                     }
                     else {
                         resolution = loader(name, containingFile, compilerOptions, resolutionHost, redirectedReference);
-                        perDirectoryResolution.set(name, resolution);
+                        perDirectoryResolution.set(nameKey, resolution);
                     }
-                    resolutionsInFile.set(name, resolution);
+                    resolutionsInFile.set(nameKey, resolution);
                     watchFailedLookupLocationsOfExternalModuleResolutions(name, resolution);
                     if (existingResolution) {
                         stopWatchFailedLookupLocationOfResolution(existingResolution);
@@ -91920,14 +92364,15 @@ var ts;
                     }
                 }
                 ts.Debug.assert(resolution !== undefined && !resolution.isInvalidated);
-                seenNamesInFile.set(name, true);
+                seenNamesInFile.set(nameKey, true);
                 resolvedModules.push(getResolutionWithResolvedFileName(resolution));
             }
             // Stop watching and remove the unused name
-            resolutionsInFile.forEach(function (resolution, name) {
-                if (!seenNamesInFile.has(name) && !ts.contains(reusedNames, name)) {
+            resolutionsInFile.forEach(function (resolution, nameKey) {
+                var name = nameKey.split('|')[0];
+                if (!seenNamesInFile.has(nameKey) && !ts.contains(reusedNames, name)) {
                     stopWatchFailedLookupLocationOfResolution(resolution);
-                    resolutionsInFile.delete(name);
+                    resolutionsInFile.delete(nameKey);
                 }
             });
             return resolvedModules;
@@ -92725,11 +93170,46 @@ var ts;
                 case ".ts" /* Ts */:
                 case ".d.ts" /* Dts */:
                     return ".js" /* Js */;
+                case ".node.ts" /* NodeTs */:
+                    return ".node.js" /* NodeJs */;
+                case ".web.ts" /* WebTs */:
+                    return ".web.js" /* WebJs */;
+                case ".native.ts" /* NativeTs */:
+                    return ".native.js" /* NativeJs */;
+                case ".ios.ts" /* IosTs */:
+                    return ".ios.js" /* IosJs */;
+                case ".android.ts" /* AndroidTs */:
+                    return ".android.js" /* AndroidJs */;
                 case ".tsx" /* Tsx */:
                     return options.jsx === 1 /* Preserve */ ? ".jsx" /* Jsx */ : ".js" /* Js */;
+                case ".node.tsx" /* NodeTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".node.jsx" /* NodeJsx */ : ".node.js" /* NodeJs */;
+                case ".web.tsx" /* WebTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".web.jsx" /* WebJsx */ : ".web.js" /* WebJs */;
+                case ".native.tsx" /* NativeTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".native.jsx" /* NativeJsx */ : ".native.js" /* NativeJs */;
+                case ".ios.tsx" /* IosTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".ios.jsx" /* IosJsx */ : ".ios.js" /* IosJs */;
+                case ".android.tsx" /* AndroidTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".android.jsx" /* AndroidJsx */ : ".android.js" /* AndroidJs */;
                 case ".js" /* Js */:
                 case ".jsx" /* Jsx */:
+                case ".node.js" /* NodeJs */:
+                case ".node.jsx" /* NodeJsx */:
+                case ".web.js" /* WebJs */:
+                case ".web.jsx" /* WebJsx */:
+                case ".native.js" /* NativeJs */:
+                case ".native.jsx" /* NativeJsx */:
+                case ".ios.js" /* IosJs */:
+                case ".ios.jsx" /* IosJsx */:
+                case ".android.js" /* AndroidJs */:
+                case ".android.jsx" /* AndroidJsx */:
                 case ".json" /* Json */:
+                case ".node.json" /* NodeJson */:
+                case ".web.json" /* WebJson */:
+                case ".native.json" /* NativeJson */:
+                case ".ios.json" /* IosJson */:
+                case ".android.json" /* AndroidJson */:
                     return ext;
                 case ".tsbuildinfo" /* TsBuildInfo */:
                     return ts.Debug.fail("Extension " + ".tsbuildinfo" /* TsBuildInfo */ + " is unsupported:: FileName:: " + fileName);
@@ -98276,14 +98756,47 @@ var ts;
             }
             function kindModifiersFromExtension(extension) {
                 switch (extension) {
-                    case ".d.ts" /* Dts */: return ".d.ts" /* dtsModifier */;
-                    case ".js" /* Js */: return ".js" /* jsModifier */;
-                    case ".json" /* Json */: return ".json" /* jsonModifier */;
-                    case ".jsx" /* Jsx */: return ".jsx" /* jsxModifier */;
-                    case ".ts" /* Ts */: return ".ts" /* tsModifier */;
-                    case ".tsx" /* Tsx */: return ".tsx" /* tsxModifier */;
-                    case ".tsbuildinfo" /* TsBuildInfo */: return ts.Debug.fail("Extension " + ".tsbuildinfo" /* TsBuildInfo */ + " is unsupported.");
-                    case undefined: return "" /* none */;
+                    case ".d.ts" /* Dts */:
+                        return ".d.ts" /* dtsModifier */;
+                    case ".js" /* Js */:
+                    case ".node.js" /* NodeJs */:
+                    case ".web.js" /* WebJs */:
+                    case ".native.js" /* NativeJs */:
+                    case ".ios.js" /* IosJs */:
+                    case ".android.js" /* AndroidJs */:
+                        return ".js" /* jsModifier */;
+                    case ".json" /* Json */:
+                    case ".node.json" /* NodeJson */:
+                    case ".web.json" /* WebJson */:
+                    case ".native.json" /* NativeJson */:
+                    case ".ios.json" /* IosJson */:
+                    case ".android.json" /* AndroidJson */:
+                        return ".json" /* jsonModifier */;
+                    case ".jsx" /* Jsx */:
+                    case ".node.jsx" /* NodeJsx */:
+                    case ".web.jsx" /* WebJsx */:
+                    case ".native.jsx" /* NativeJsx */:
+                    case ".ios.jsx" /* IosJsx */:
+                    case ".android.jsx" /* AndroidJsx */:
+                        return ".jsx" /* jsxModifier */;
+                    case ".ts" /* Ts */:
+                    case ".node.ts" /* NodeTs */:
+                    case ".web.ts" /* WebTs */:
+                    case ".native.ts" /* NativeTs */:
+                    case ".ios.ts" /* IosTs */:
+                    case ".android.ts" /* AndroidTs */:
+                        return ".ts" /* tsModifier */;
+                    case ".tsx" /* Tsx */:
+                    case ".node.tsx" /* NodeTsx */:
+                    case ".web.tsx" /* WebTsx */:
+                    case ".native.tsx" /* NativeTsx */:
+                    case ".ios.tsx" /* IosTsx */:
+                    case ".android.tsx" /* AndroidTsx */:
+                        return ".tsx" /* tsxModifier */;
+                    case ".tsbuildinfo" /* TsBuildInfo */:
+                        return ts.Debug.fail("Extension " + ".tsbuildinfo" /* TsBuildInfo */ + " is unsupported.");
+                    case undefined:
+                        return "" /* none */;
                     default:
                         return ts.Debug.assertNever(extension);
                 }
diff --git a/lib/typescript.d.ts b/lib/typescript.d.ts
index 314ccf298c..74fd79f711 100644
--- a/lib/typescript.d.ts
+++ b/lib/typescript.d.ts
@@ -2716,12 +2716,37 @@ declare namespace ts {
     }
     enum Extension {
         Ts = ".ts",
+        IosTs = ".ios.ts",
+        AndroidTs = ".android.ts",
+        NativeTs = ".native.ts",
+        WebTs = ".web.ts",
+        NodeTs = ".node.ts",
         Tsx = ".tsx",
+        IosTsx = ".ios.tsx",
+        AndroidTsx = ".android.tsx",
+        NativeTsx = ".native.tsx",
+        WebTsx = ".web.tsx",
+        NodeTsx = ".node.tsx",
         Dts = ".d.ts",
         Js = ".js",
+        IosJs = ".ios.js",
+        AndroidJs = ".android.js",
+        NativeJs = ".native.js",
+        WebJs = ".web.js",
+        NodeJs = ".node.js",
         Jsx = ".jsx",
         Json = ".json",
-        TsBuildInfo = ".tsbuildinfo"
+        TsBuildInfo = ".tsbuildinfo",
+        IosJsx = ".ios.jsx",
+        AndroidJsx = ".android.jsx",
+        NativeJsx = ".native.jsx",
+        WebJsx = ".web.jsx",
+        NodeJsx = ".node.jsx",
+        IosJson = ".ios.json",
+        AndroidJson = ".android.json",
+        NativeJson = ".native.json",
+        WebJson = ".web.json",
+        NodeJson = ".node.json"
     }
     interface ResolvedModuleWithFailedLookupLocations {
         readonly resolvedModule: ResolvedModuleFull | undefined;
@@ -3717,8 +3742,8 @@ declare namespace ts {
     function createModuleResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string): ModuleResolutionCache;
     function resolveModuleNameFromCache(moduleName: string, containingFile: string, cache: ModuleResolutionCache): ResolvedModuleWithFailedLookupLocations | undefined;
     function resolveModuleName(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
-    function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
-    function classicNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
+    function nodeModuleNameResolver(parentFileExtension: Extension, moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
+    function classicNameResolver(parentFileExtension: Extension, moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
 }
 declare namespace ts {
     function createNodeArray<T extends Node>(elements?: ReadonlyArray<T>, hasTrailingComma?: boolean): NodeArray<T>;
diff --git a/lib/typescript.js b/lib/typescript.js
index af0dc4daef..d7c4383182 100644
--- a/lib/typescript.js
+++ b/lib/typescript.js
@@ -3833,12 +3833,37 @@ var ts;
     var Extension;
     (function (Extension) {
         Extension["Ts"] = ".ts";
+        Extension["IosTs"] = ".ios.ts";
+        Extension["AndroidTs"] = ".android.ts";
+        Extension["NativeTs"] = ".native.ts";
+        Extension["WebTs"] = ".web.ts";
+        Extension["NodeTs"] = ".node.ts";
         Extension["Tsx"] = ".tsx";
+        Extension["IosTsx"] = ".ios.tsx";
+        Extension["AndroidTsx"] = ".android.tsx";
+        Extension["NativeTsx"] = ".native.tsx";
+        Extension["WebTsx"] = ".web.tsx";
+        Extension["NodeTsx"] = ".node.tsx";
         Extension["Dts"] = ".d.ts";
         Extension["Js"] = ".js";
+        Extension["IosJs"] = ".ios.js";
+        Extension["AndroidJs"] = ".android.js";
+        Extension["NativeJs"] = ".native.js";
+        Extension["WebJs"] = ".web.js";
+        Extension["NodeJs"] = ".node.js";
         Extension["Jsx"] = ".jsx";
         Extension["Json"] = ".json";
         Extension["TsBuildInfo"] = ".tsbuildinfo";
+        Extension["IosJsx"] = ".ios.jsx";
+        Extension["AndroidJsx"] = ".android.jsx";
+        Extension["NativeJsx"] = ".native.jsx";
+        Extension["WebJsx"] = ".web.jsx";
+        Extension["NodeJsx"] = ".node.jsx";
+        Extension["IosJson"] = ".ios.json";
+        Extension["AndroidJson"] = ".android.json";
+        Extension["NativeJson"] = ".native.json";
+        Extension["WebJson"] = ".web.json";
+        Extension["NodeJson"] = ".node.json";
     })(Extension = ts.Extension || (ts.Extension = {}));
     /* @internal */
     var TransformFlags;
@@ -5027,7 +5052,21 @@ var ts;
             }
             function realpath(path) {
                 try {
-                    return _fs.realpathSync(path);
+                    var regexp = /\.([^\/]+?)$/;
+                    var match = path.match(regexp);
+                    var rpath = _fs.realpathSync(path);
+                    if (match !== null) {
+                        var ext = match[1];
+                        var rmatch = rpath.match(regexp);
+                        if (rmatch !== null) {
+                            var rext = rmatch[1];
+                            if (ext !== rext) {
+                                return rpath.replace(new RegExp(rext + "$"), ext);
+                            }
+                            return rpath;
+                        }
+                    }
+                    return rpath;
                 }
                 catch (_a) {
                     return path;
@@ -12043,7 +12082,7 @@ var ts;
     }
     /** Return ".ts", ".d.ts", or ".tsx", if that is the extension. */
     function tryExtractTSExtension(fileName) {
-        return ts.find(ts.supportedTSExtensionsForExtractExtension, function (extension) { return ts.fileExtensionIs(fileName, extension); });
+        return ts.find(ts.supportedTSExtensions, function (extension) { return ts.fileExtensionIs(fileName, extension); });
     }
     ts.tryExtractTSExtension = tryExtractTSExtension;
     /**
@@ -16007,14 +16046,55 @@ var ts;
     /**
      *  List of supported extensions in order of file resolution precedence.
      */
-    ts.supportedTSExtensions = [".ts" /* Ts */, ".tsx" /* Tsx */, ".d.ts" /* Dts */];
-    ts.supportedTSExtensionsWithJson = [".ts" /* Ts */, ".tsx" /* Tsx */, ".d.ts" /* Dts */, ".json" /* Json */];
-    /** Must have ".d.ts" first because if ".ts" goes first, that will be detected as the extension instead of ".d.ts". */
-    ts.supportedTSExtensionsForExtractExtension = [".d.ts" /* Dts */, ".ts" /* Ts */, ".tsx" /* Tsx */];
-    ts.supportedJSExtensions = [".js" /* Js */, ".jsx" /* Jsx */];
-    ts.supportedJSAndJsonExtensions = [".js" /* Js */, ".jsx" /* Jsx */, ".json" /* Json */];
+    ts.supportedJsonExtensions = [
+        ".node.json" /* NodeJson */,
+        ".web.json" /* WebJson */,
+        ".native.json" /* NativeJson */,
+        ".ios.json" /* IosJson */,
+        ".android.json" /* AndroidJson */,
+        ".json" /* Json */
+    ];
+    ts.supportedTSExtensions = [
+        ".node.ts" /* NodeTs */,
+        ".node.tsx" /* NodeTsx */,
+        ".web.ts" /* WebTs */,
+        ".web.tsx" /* WebTsx */,
+        ".native.ts" /* NativeTs */,
+        ".native.tsx" /* NativeTsx */,
+        ".ios.ts" /* IosTs */,
+        ".ios.tsx" /* IosTsx */,
+        ".android.ts" /* AndroidTs */,
+        ".android.tsx" /* AndroidTsx */,
+        ".d.ts" /* Dts */,
+        ".ts" /* Ts */,
+        ".tsx" /* Tsx */
+    ];
+    ts.supportedTSExtensionsWithJson = ts.supportedTSExtensions.concat(ts.supportedJsonExtensions);
+    ts.supportedJSExtensions = [
+        ".node.js" /* NodeJs */,
+        ".node.jsx" /* NodeJsx */,
+        ".web.js" /* WebJs */,
+        ".web.jsx" /* WebJsx */,
+        ".native.js" /* NativeJs */,
+        ".native.jsx" /* NativeJsx */,
+        ".ios.js" /* IosJs */,
+        ".ios.jsx" /* IosJsx */,
+        ".android.js" /* AndroidJs */,
+        ".android.jsx" /* AndroidJsx */,
+        ".js" /* Js */,
+        ".jsx" /* Jsx */
+    ];
+    ts.supportedJSAndJsonExtensions = ts.supportedJSExtensions.concat(ts.supportedJsonExtensions);
     var allSupportedExtensions = ts.supportedTSExtensions.concat(ts.supportedJSExtensions);
-    var allSupportedExtensionsWithJson = ts.supportedTSExtensions.concat(ts.supportedJSExtensions, [".json" /* Json */]);
+    var allSupportedExtensionsWithJson = ts.supportedTSExtensions.concat(ts.supportedJSExtensions, ts.supportedJsonExtensions);
+    function getAllSupportedExtensions() {
+        return allSupportedExtensions;
+    }
+    ts.getAllSupportedExtensions = getAllSupportedExtensions;
+    function getAllSupportedExtensionsWithJson() {
+        return allSupportedExtensionsWithJson;
+    }
+    ts.getAllSupportedExtensionsWithJson = getAllSupportedExtensionsWithJson;
     function getSupportedExtensions(options, extraFileExtensions) {
         var needJsExtensions = options && options.allowJs;
         if (!extraFileExtensions || extraFileExtensions.length === 0) {
@@ -16186,7 +16266,7 @@ var ts;
     ts.positionIsSynthesized = positionIsSynthesized;
     /** True if an extension is one of the supported TypeScript extensions. */
     function extensionIsTS(ext) {
-        return ext === ".ts" /* Ts */ || ext === ".tsx" /* Tsx */ || ext === ".d.ts" /* Dts */;
+        return ts.supportedTSExtensions.indexOf(ext) !== -1;
     }
     ts.extensionIsTS = extensionIsTS;
     function resolutionExtensionIsTSOrJson(ext) {
@@ -16207,7 +16287,7 @@ var ts;
     }
     ts.isAnySupportedFileExtension = isAnySupportedFileExtension;
     function tryGetExtensionFromPath(path) {
-        return ts.find(extensionsToRemove, function (e) { return ts.fileExtensionIs(path, e); });
+        return ts.find(allSupportedExtensionsWithJson, function (e) { return ts.fileExtensionIs(path, e); });
     }
     ts.tryGetExtensionFromPath = tryGetExtensionFromPath;
     function getAnyExtensionFromPathWorker(path, extensions, stringEqualityComparer) {
@@ -16248,6 +16328,19 @@ var ts;
         files: ts.emptyArray,
         directories: ts.emptyArray
     };
+    function getFileExtension(filepath) {
+        if (typeof filepath === "undefined") {
+            return ".ts" /* Ts */;
+        }
+        for (var _i = 0, allSupportedExtensionsWithJson_1 = allSupportedExtensionsWithJson; _i < allSupportedExtensionsWithJson_1.length; _i++) {
+            var ext = allSupportedExtensionsWithJson_1[_i];
+            if (ts.endsWith(filepath, ext)) {
+                return ext;
+            }
+        }
+        return ".ts" /* Ts */;
+    }
+    ts.getFileExtension = getFileExtension;
     /**
      * patternStrings contains both pattern strings (containing "*") and regular strings.
      * Return an exact match if possible, or a pattern match, or undefined.
@@ -25611,7 +25704,7 @@ var ts;
             return extendedConfigPath;
         }
         // If the path isn't a rooted or relative path, resolve like a module
-        var resolved = ts.nodeModuleNameResolver(extendedConfig, ts.combinePaths(basePath, "tsconfig.json"), { moduleResolution: ts.ModuleResolutionKind.NodeJs }, host, /*cache*/ undefined, /*projectRefs*/ undefined, /*lookupConfig*/ true);
+        var resolved = ts.nodeModuleNameResolver(".ts" /* Ts */, extendedConfig, ts.combinePaths(basePath, "tsconfig.json"), { moduleResolution: ts.ModuleResolutionKind.NodeJs }, host, /*cache*/ undefined, /*projectRefs*/ undefined, /*lookupConfig*/ true);
         if (resolved.resolvedModule) {
             return resolved.resolvedModule.resolvedFileName;
         }
@@ -26190,6 +26283,12 @@ var ts;
     function readPackageJsonMainField(jsonContent, baseDirectory, state) {
         return readPackageJsonPathField(jsonContent, "main", baseDirectory, state);
     }
+    function readPackageJsonReactNativeField(jsonContent, baseDirectory, state) {
+        return readPackageJsonPathField(jsonContent, "react-native", baseDirectory, state);
+    }
+    function readPackageJsonBrowserField(jsonContent, baseDirectory, state) {
+        return readPackageJsonPathField(jsonContent, "browser", baseDirectory, state);
+    }
     function readPackageJsonTypesVersionsField(jsonContent, state) {
         var typesVersions = readPackageJsonField(jsonContent, "typesVersions", "object", state);
         if (typesVersions === undefined)
@@ -26344,7 +26443,7 @@ var ts;
                     if (!directoryExists && traceEnabled) {
                         trace(host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, candidateDirectory);
                     }
-                    return resolvedTypeScriptOnly(loadNodeModuleFromDirectory(Extensions.DtsOnly, candidate, !directoryExists, moduleResolutionState));
+                    return resolvedTypeScriptOnly(loadNodeModuleFromDirectory(".ts" /* Ts */, Extensions.DtsOnly, candidate, !directoryExists, moduleResolutionState));
                 });
             }
             else {
@@ -26362,12 +26461,12 @@ var ts;
                 }
                 var result = void 0;
                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {
-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
+                    var searchResult = loadModuleFromNearestNodeModulesDirectory(".ts" /* Ts */, Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
                     result = searchResult && searchResult.value;
                 }
                 else {
                     var candidate = ts.normalizePathAndParts(ts.combinePaths(initialLocationForSecondaryLookup, typeReferenceDirectiveName)).path;
-                    result = nodeLoadModuleByRelativeName(Extensions.DtsOnly, candidate, /*onlyRecordFailures*/ false, moduleResolutionState, /*considerPackageJson*/ true);
+                    result = nodeLoadModuleByRelativeName(".ts" /* Ts */, Extensions.DtsOnly, candidate, /*onlyRecordFailures*/ false, moduleResolutionState, /*considerPackageJson*/ true);
                 }
                 var resolvedFile = resolvedTypeScriptOnly(result);
                 if (!resolvedFile && traceEnabled) {
@@ -26549,8 +26648,9 @@ var ts;
     ts.createModuleResolutionCacheWithMaps = createModuleResolutionCacheWithMaps;
     function resolveModuleNameFromCache(moduleName, containingFile, cache) {
         var containingDirectory = ts.getDirectoryPath(containingFile);
+        var parentFileExtension = ts.getFileExtension(containingFile);
         var perFolderCache = cache && cache.getOrCreateCacheForDirectory(containingDirectory);
-        return perFolderCache && perFolderCache.get(moduleName);
+        return perFolderCache && perFolderCache.get(moduleName + "|" + parentFileExtension);
     }
     ts.resolveModuleNameFromCache = resolveModuleNameFromCache;
     function resolveModuleName(moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
@@ -26565,8 +26665,10 @@ var ts;
             }
         }
         var containingDirectory = ts.getDirectoryPath(containingFile);
+        var parentFileExtension = ts.getFileExtension(containingFile);
+        var moduleNameKey = moduleName + "|" + parentFileExtension;
         var perFolderCache = cache && cache.getOrCreateCacheForDirectory(containingDirectory, redirectedReference);
-        var result = perFolderCache && perFolderCache.get(moduleName);
+        var result = perFolderCache && perFolderCache.get(moduleNameKey);
         if (result) {
             if (traceEnabled) {
                 trace(host, ts.Diagnostics.Resolution_for_module_0_was_found_in_cache_from_location_1, moduleName, containingDirectory);
@@ -26587,19 +26689,19 @@ var ts;
             }
             switch (moduleResolution) {
                 case ts.ModuleResolutionKind.NodeJs:
-                    result = nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
+                    result = nodeModuleNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
                     break;
                 case ts.ModuleResolutionKind.Classic:
-                    result = classicNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
+                    result = classicNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
                     break;
                 default:
                     return ts.Debug.fail("Unexpected moduleResolution: " + moduleResolution);
             }
             if (perFolderCache) {
-                perFolderCache.set(moduleName, result);
+                perFolderCache.set(moduleNameKey, result);
                 if (!ts.isExternalModuleNameRelative(moduleName)) {
                     // put result in per-module name cache
-                    cache.getOrCreateCacheForModuleName(moduleName, redirectedReference).set(containingDirectory, result);
+                    cache.getOrCreateCacheForModuleName(moduleNameKey, redirectedReference).set(containingDirectory, result);
                 }
             }
         }
@@ -26674,28 +26776,28 @@ var ts;
      * be converted to a path relative to found rootDir entry './content/protocols/file2' (*). As a last step compiler will check all remaining
      * entries in 'rootDirs', use them to build absolute path out of (*) and try to resolve module from this location.
      */
-    function tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loader, state) {
-        var resolved = tryLoadModuleUsingPathsIfEligible(extensions, moduleName, loader, state);
+    function tryLoadModuleUsingOptionalResolutionSettings(parentFileExtension, extensions, moduleName, containingDirectory, loader, state) {
+        var resolved = tryLoadModuleUsingPathsIfEligible(parentFileExtension, extensions, moduleName, loader, state);
         if (resolved)
             return resolved.value;
         if (!ts.isExternalModuleNameRelative(moduleName)) {
-            return tryLoadModuleUsingBaseUrl(extensions, moduleName, loader, state);
+            return tryLoadModuleUsingBaseUrl(parentFileExtension, extensions, moduleName, loader, state);
         }
         else {
-            return tryLoadModuleUsingRootDirs(extensions, moduleName, containingDirectory, loader, state);
+            return tryLoadModuleUsingRootDirs(parentFileExtension, extensions, moduleName, containingDirectory, loader, state);
         }
     }
-    function tryLoadModuleUsingPathsIfEligible(extensions, moduleName, loader, state) {
+    function tryLoadModuleUsingPathsIfEligible(parentFileExtension, extensions, moduleName, loader, state) {
         var _a = state.compilerOptions, baseUrl = _a.baseUrl, paths = _a.paths;
         if (baseUrl && paths && !ts.pathIsRelative(moduleName)) {
             if (state.traceEnabled) {
                 trace(state.host, ts.Diagnostics.baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1, baseUrl, moduleName);
                 trace(state.host, ts.Diagnostics.paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0, moduleName);
             }
-            return tryLoadModuleUsingPaths(extensions, moduleName, baseUrl, paths, loader, /*onlyRecordFailures*/ false, state);
+            return tryLoadModuleUsingPaths(parentFileExtension, extensions, moduleName, baseUrl, paths, loader, /*onlyRecordFailures*/ false, state);
         }
     }
-    function tryLoadModuleUsingRootDirs(extensions, moduleName, containingDirectory, loader, state) {
+    function tryLoadModuleUsingRootDirs(parentFileExtension, extensions, moduleName, containingDirectory, loader, state) {
         if (!state.compilerOptions.rootDirs) {
             return undefined;
         }
@@ -26733,7 +26835,7 @@ var ts;
             if (state.traceEnabled) {
                 trace(state.host, ts.Diagnostics.Loading_0_from_the_root_dir_1_candidate_location_2, suffix, matchedNormalizedPrefix, candidate);
             }
-            var resolvedFileName = loader(extensions, candidate, !ts.directoryProbablyExists(containingDirectory, state.host), state);
+            var resolvedFileName = loader(parentFileExtension, extensions, candidate, !ts.directoryProbablyExists(containingDirectory, state.host), state);
             if (resolvedFileName) {
                 return resolvedFileName;
             }
@@ -26752,7 +26854,7 @@ var ts;
                     trace(state.host, ts.Diagnostics.Loading_0_from_the_root_dir_1_candidate_location_2, suffix, rootDir, candidate_1);
                 }
                 var baseDirectory = ts.getDirectoryPath(candidate_1);
-                var resolvedFileName_1 = loader(extensions, candidate_1, !ts.directoryProbablyExists(baseDirectory, state.host), state);
+                var resolvedFileName_1 = loader(parentFileExtension, extensions, candidate_1, !ts.directoryProbablyExists(baseDirectory, state.host), state);
                 if (resolvedFileName_1) {
                     return resolvedFileName_1;
                 }
@@ -26763,7 +26865,7 @@ var ts;
         }
         return undefined;
     }
-    function tryLoadModuleUsingBaseUrl(extensions, moduleName, loader, state) {
+    function tryLoadModuleUsingBaseUrl(parentFileExtension, extensions, moduleName, loader, state) {
         var baseUrl = state.compilerOptions.baseUrl;
         if (!baseUrl) {
             return undefined;
@@ -26775,7 +26877,7 @@ var ts;
         if (state.traceEnabled) {
             trace(state.host, ts.Diagnostics.Resolving_module_name_0_relative_to_base_url_1_2, moduleName, baseUrl, candidate);
         }
-        return loader(extensions, candidate, !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
+        return loader(parentFileExtension, extensions, candidate, !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
     }
     /**
      * Expose resolution logic to allow us to use Node module resolution logic from arbitrary locations.
@@ -26784,7 +26886,7 @@ var ts;
      */
     /* @internal */
     function resolveJSModule(moduleName, initialDir, host) {
-        var _a = tryResolveJSModuleWorker(moduleName, initialDir, host), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
+        var _a = tryResolveJSModuleWorker(".ts" /* Ts */, moduleName, initialDir, host), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
         if (!resolvedModule) {
             throw new Error("Could not resolve JS module '" + moduleName + "' starting at '" + initialDir + "'. Looked in: " + failedLookupLocations.join(", "));
         }
@@ -26793,7 +26895,7 @@ var ts;
     ts.resolveJSModule = resolveJSModule;
     /* @internal */
     function tryResolveJSModule(moduleName, initialDir, host) {
-        var resolvedModule = tryResolveJSModuleWorker(moduleName, initialDir, host).resolvedModule;
+        var resolvedModule = tryResolveJSModuleWorker(".ts" /* Ts */, moduleName, initialDir, host).resolvedModule;
         return resolvedModule && resolvedModule.resolvedFileName;
     }
     ts.tryResolveJSModule = tryResolveJSModule;
@@ -26801,14 +26903,14 @@ var ts;
     var tsExtensions = [Extensions.TypeScript, Extensions.JavaScript];
     var tsPlusJsonExtensions = tsExtensions.concat([Extensions.Json]);
     var tsconfigExtensions = [Extensions.TSConfig];
-    function tryResolveJSModuleWorker(moduleName, initialDir, host) {
-        return nodeModuleNameResolverWorker(moduleName, initialDir, { moduleResolution: ts.ModuleResolutionKind.NodeJs, allowJs: true }, host, /*cache*/ undefined, jsOnlyExtensions, /*redirectedReferences*/ undefined);
+    function tryResolveJSModuleWorker(parentFileExtension, moduleName, initialDir, host) {
+        return nodeModuleNameResolverWorker(parentFileExtension, moduleName, initialDir, { moduleResolution: ts.ModuleResolutionKind.NodeJs, allowJs: true }, host, /*cache*/ undefined, jsOnlyExtensions, /*redirectedReferences*/ undefined);
     }
-    function nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference, lookupConfig) {
-        return nodeModuleNameResolverWorker(moduleName, ts.getDirectoryPath(containingFile), compilerOptions, host, cache, lookupConfig ? tsconfigExtensions : (compilerOptions.resolveJsonModule ? tsPlusJsonExtensions : tsExtensions), redirectedReference);
+    function nodeModuleNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference, lookupConfig) {
+        return nodeModuleNameResolverWorker(parentFileExtension, moduleName, ts.getDirectoryPath(containingFile), compilerOptions, host, cache, lookupConfig ? tsconfigExtensions : (compilerOptions.resolveJsonModule ? tsPlusJsonExtensions : tsExtensions), redirectedReference);
     }
     ts.nodeModuleNameResolver = nodeModuleNameResolver;
-    function nodeModuleNameResolverWorker(moduleName, containingDirectory, compilerOptions, host, cache, extensions, redirectedReference) {
+    function nodeModuleNameResolverWorker(parentFileExtension, moduleName, containingDirectory, compilerOptions, host, cache, extensions, redirectedReference) {
         var traceEnabled = isTraceEnabled(compilerOptions, host);
         var failedLookupLocations = [];
         var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations };
@@ -26819,8 +26921,8 @@ var ts;
         }
         return { resolvedModule: undefined, failedLookupLocations: failedLookupLocations };
         function tryResolve(extensions) {
-            var loader = function (extensions, candidate, onlyRecordFailures, state) { return nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ true); };
-            var resolved = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loader, state);
+            var loader = function (parentFileExtension, extensions, candidate, onlyRecordFailures, state) { return nodeLoadModuleByRelativeName(parentFileExtension, extensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ true); };
+            var resolved = tryLoadModuleUsingOptionalResolutionSettings(parentFileExtension, extensions, moduleName, containingDirectory, loader, state);
             if (resolved) {
                 return toSearchResult({ resolved: resolved, isExternalLibraryImport: pathContainsNodeModules(resolved.path) });
             }
@@ -26828,7 +26930,7 @@ var ts;
                 if (traceEnabled) {
                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);
                 }
-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
+                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(parentFileExtension, extensions, moduleName, containingDirectory, state, cache, redirectedReference);
                 if (!resolved_1)
                     return undefined;
                 var resolvedValue = resolved_1.value;
@@ -26842,7 +26944,7 @@ var ts;
             }
             else {
                 var _a = ts.normalizePathAndParts(ts.combinePaths(containingDirectory, moduleName)), candidate = _a.path, parts = _a.parts;
-                var resolved_2 = nodeLoadModuleByRelativeName(extensions, candidate, /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true);
+                var resolved_2 = nodeLoadModuleByRelativeName(parentFileExtension, extensions, candidate, /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true);
                 // Treat explicit "node_modules" import as an external library import.
                 return resolved_2 && toSearchResult({ resolved: resolved_2, isExternalLibraryImport: ts.contains(parts, "node_modules") });
             }
@@ -26859,7 +26961,7 @@ var ts;
         ts.Debug.assert(host.fileExists(real), path + " linked to nonexistent file " + real); // tslint:disable-line
         return real;
     }
-    function nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
+    function nodeLoadModuleByRelativeName(parentFileExtension, extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
         if (state.traceEnabled) {
             trace(state.host, ts.Diagnostics.Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1, candidate, Extensions[extensions]);
         }
@@ -26873,10 +26975,10 @@ var ts;
                     onlyRecordFailures = true;
                 }
             }
-            var resolvedFromFile = loadModuleFromFile(extensions, candidate, onlyRecordFailures, state);
+            var resolvedFromFile = loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state);
             if (resolvedFromFile) {
                 var nm = considerPackageJson ? parseNodeModuleFromPath(resolvedFromFile) : undefined;
-                var packageInfo = nm && getPackageJsonInfo(nm.packageDirectory, nm.subModuleName, /*onlyRecordFailures*/ false, state);
+                var packageInfo = nm && getPackageJsonInfo(parentFileExtension, nm.packageDirectory, nm.subModuleName, /*onlyRecordFailures*/ false, state);
                 var packageId = packageInfo && packageInfo.packageId;
                 return withPackageId(packageId, resolvedFromFile);
             }
@@ -26890,7 +26992,7 @@ var ts;
                 onlyRecordFailures = true;
             }
         }
-        return loadNodeModuleFromDirectory(extensions, candidate, onlyRecordFailures, state, considerPackageJson);
+        return loadNodeModuleFromDirectory(parentFileExtension, extensions, candidate, onlyRecordFailures, state, considerPackageJson);
     }
     /*@internal*/
     ts.nodeModulesPathPart = "/node_modules/";
@@ -26941,20 +27043,20 @@ var ts;
         }
         return path + "/index.d.ts";
     }
-    function loadModuleFromFileNoPackageId(extensions, candidate, onlyRecordFailures, state) {
-        return noPackageId(loadModuleFromFile(extensions, candidate, onlyRecordFailures, state));
+    function loadModuleFromFileNoPackageId(parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
+        return noPackageId(loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state));
     }
     /**
      * @param {boolean} onlyRecordFailures - if true then function won't try to actually load files but instead record all attempts as failures. This flag is necessary
      * in cases when we know upfront that all load attempts will fail (because containing folder does not exists) however we still need to record all failed lookup locations.
      */
-    function loadModuleFromFile(extensions, candidate, onlyRecordFailures, state) {
+    function loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
         if (extensions === Extensions.Json || extensions === Extensions.TSConfig) {
             var extensionLess = ts.tryRemoveExtension(candidate, ".json" /* Json */);
-            return (extensionLess === undefined && extensions === Extensions.Json) ? undefined : tryAddingExtensions(extensionLess || candidate, extensions, onlyRecordFailures, state);
+            return (extensionLess === undefined && extensions === Extensions.Json) ? undefined : tryAddingExtensions(parentFileExtension, extensionLess || candidate, extensions, onlyRecordFailures, state);
         }
         // First, try adding an extension. An import of "foo" could be matched by a file "foo.ts", or "foo.js" by "foo.js.ts"
-        var resolvedByAddingExtension = tryAddingExtensions(candidate, extensions, onlyRecordFailures, state);
+        var resolvedByAddingExtension = tryAddingExtensions(parentFileExtension, candidate, extensions, onlyRecordFailures, state);
         if (resolvedByAddingExtension) {
             return resolvedByAddingExtension;
         }
@@ -26966,11 +27068,11 @@ var ts;
                 var extension = candidate.substring(extensionless.length);
                 trace(state.host, ts.Diagnostics.File_name_0_has_a_1_extension_stripping_it, candidate, extension);
             }
-            return tryAddingExtensions(extensionless, extensions, onlyRecordFailures, state);
+            return tryAddingExtensions(parentFileExtension, extensionless, extensions, onlyRecordFailures, state);
         }
     }
     /** Try to return an existing file that adds one of the `extensions` to `candidate`. */
-    function tryAddingExtensions(candidate, extensions, onlyRecordFailures, state) {
+    function tryAddingExtensions(parentFileExtension, candidate, extensions, onlyRecordFailures, state) {
         if (!onlyRecordFailures) {
             // check if containing folder exists - if it doesn't then just record failures for all supported extensions without disk probing
             var directory = ts.getDirectoryPath(candidate);
@@ -26978,16 +27080,212 @@ var ts;
                 onlyRecordFailures = !ts.directoryProbablyExists(directory, state.host);
             }
         }
-        switch (extensions) {
-            case Extensions.DtsOnly:
-                return tryExtension(".d.ts" /* Dts */);
-            case Extensions.TypeScript:
-                return tryExtension(".ts" /* Ts */) || tryExtension(".tsx" /* Tsx */) || tryExtension(".d.ts" /* Dts */);
-            case Extensions.JavaScript:
-                return tryExtension(".js" /* Js */) || tryExtension(".jsx" /* Jsx */);
-            case Extensions.TSConfig:
-            case Extensions.Json:
-                return tryExtension(".json" /* Json */);
+        switch (parentFileExtension) {
+            case ".web.ts" /* WebTs */:
+            case ".web.tsx" /* WebTsx */:
+            case ".web.js" /* WebJs */:
+            case ".web.jsx" /* WebJsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".web.json" /* WebJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".web.js" /* WebJs */) ||
+                            tryExtension(".web.jsx" /* WebJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".web.ts" /* WebTs */) ||
+                            tryExtension(".web.tsx" /* WebTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".native.js" /* NativeJs */:
+            case ".native.jsx" /* NativeJsx */:
+            case ".native.ts" /* NativeTs */:
+            case ".native.tsx" /* NativeTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".json" /* Json */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".ios.json" /* IosJson */) ||
+                            tryExtension(".android.json" /* AndroidJson */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".ios.js" /* IosJs */) ||
+                            tryExtension(".ios.jsx" /* IosJsx */) ||
+                            tryExtension(".android.js" /* AndroidJs */) ||
+                            tryExtension(".android.jsx" /* AndroidJsx */));
+                    }
+                    default: {
+                        return (tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ios.ts" /* IosTs */) ||
+                            tryExtension(".ios.tsx" /* IosTsx */) ||
+                            tryExtension(".android.ts" /* AndroidTs */) ||
+                            tryExtension(".android.tsx" /* AndroidTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".ios.js" /* IosJs */:
+            case ".ios.jsx" /* IosJsx */:
+            case ".ios.ts" /* IosTs */:
+            case ".ios.tsx" /* IosTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".ios.json" /* IosJson */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".ios.js" /* IosJs */) ||
+                            tryExtension(".ios.jsx" /* IosJsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".ios.ts" /* IosTs */) ||
+                            tryExtension(".ios.tsx" /* IosTsx */) ||
+                            tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".android.js" /* AndroidJs */:
+            case ".android.jsx" /* AndroidJsx */:
+            case ".android.ts" /* AndroidTs */:
+            case ".android.tsx" /* AndroidTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".android.json" /* AndroidJson */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".android.js" /* AndroidJs */) ||
+                            tryExtension(".android.jsx" /* AndroidJsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".android.ts" /* AndroidTs */) ||
+                            tryExtension(".android.tsx" /* AndroidTsx */) ||
+                            tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".node.js" /* NodeJs */:
+            case ".node.jsx" /* NodeJsx */:
+            case ".node.ts" /* NodeTs */:
+            case ".node.tsx" /* NodeTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".node.json" /* NodeJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".node.js" /* NodeJs */) ||
+                            tryExtension(".node.jsx" /* NodeJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".node.ts" /* NodeTs */) ||
+                            tryExtension(".node.tsx" /* NodeTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            default: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".json" /* Json */) ||
+                            tryExtension(".node.json" /* NodeJson */) ||
+                            tryExtension(".web.json" /* WebJson */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".ios.json" /* IosJson */) ||
+                            tryExtension(".android.json" /* AndroidJson */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */) ||
+                            tryExtension(".node.js" /* NodeJs */) ||
+                            tryExtension(".node.jsx" /* NodeJsx */) ||
+                            tryExtension(".web.js" /* WebJs */) ||
+                            tryExtension(".web.jsx" /* WebJsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".ios.js" /* IosJs */) ||
+                            tryExtension(".ios.jsx" /* IosJsx */) ||
+                            tryExtension(".android.js" /* AndroidJs */) ||
+                            tryExtension(".android.jsx" /* AndroidJsx */));
+                    }
+                    default: {
+                        return (tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */) ||
+                            tryExtension(".node.ts" /* NodeTs */) ||
+                            tryExtension(".node.tsx" /* NodeTsx */) ||
+                            tryExtension(".web.ts" /* WebTs */) ||
+                            tryExtension(".web.tsx" /* WebTsx */) ||
+                            tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ios.ts" /* IosTs */) ||
+                            tryExtension(".ios.tsx" /* IosTsx */) ||
+                            tryExtension(".android.ts" /* AndroidTs */) ||
+                            tryExtension(".android.tsx" /* AndroidTsx */));
+                    }
+                }
+            }
         }
         function tryExtension(ext) {
             var path = tryFile(candidate + ext, onlyRecordFailures, state);
@@ -27012,15 +27310,15 @@ var ts;
         state.failedLookupLocations.push(fileName);
         return undefined;
     }
-    function loadNodeModuleFromDirectory(extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
+    function loadNodeModuleFromDirectory(parentFileExtension, extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
         if (considerPackageJson === void 0) { considerPackageJson = true; }
-        var packageInfo = considerPackageJson ? getPackageJsonInfo(candidate, "", onlyRecordFailures, state) : undefined;
+        var packageInfo = considerPackageJson ? getPackageJsonInfo(parentFileExtension, candidate, "", onlyRecordFailures, state) : undefined;
         var packageId = packageInfo && packageInfo.packageId;
         var packageJsonContent = packageInfo && packageInfo.packageJsonContent;
         var versionPaths = packageJsonContent && readPackageJsonTypesVersionPaths(packageJsonContent, state);
-        return withPackageId(packageId, loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths));
+        return withPackageId(packageId, loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths));
     }
-    function getPackageJsonInfo(packageDirectory, subModuleName, onlyRecordFailures, state) {
+    function getPackageJsonInfo(parentFileExtension, packageDirectory, subModuleName, onlyRecordFailures, state) {
         var host = state.host, traceEnabled = state.traceEnabled;
         var directoryExists = !onlyRecordFailures && ts.directoryProbablyExists(packageDirectory, host);
         var packageJsonPath = ts.combinePaths(packageDirectory, "package.json");
@@ -27032,7 +27330,34 @@ var ts;
                     subModuleName = addExtensionAndIndex(path.substring(packageDirectory.length + 1));
                 }
                 else {
-                    var jsPath = readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                    var jsPath = void 0;
+                    switch (parentFileExtension) {
+                        case ".android.js" /* AndroidJs */:
+                        case ".ios.js" /* IosJs */:
+                        case ".native.js" /* NativeJs */:
+                        case ".android.jsx" /* AndroidJsx */:
+                        case ".ios.jsx" /* IosJsx */:
+                        case ".native.jsx" /* NativeJsx */:
+                        case ".android.ts" /* AndroidTs */:
+                        case ".ios.ts" /* IosTs */:
+                        case ".native.ts" /* NativeTs */:
+                        case ".android.tsx" /* AndroidTsx */:
+                        case ".ios.tsx" /* IosTsx */:
+                        case ".native.tsx" /* NativeTsx */: {
+                            jsPath = readPackageJsonReactNativeField(packageJsonContent, packageDirectory, state) || readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                            break;
+                        }
+                        case ".web.js" /* WebJs */:
+                        case ".web.jsx" /* WebJsx */:
+                        case ".web.ts" /* WebTs */:
+                        case ".web.tsx" /* WebTsx */: {
+                            jsPath = readPackageJsonBrowserField(packageJsonContent, packageDirectory, state) || readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                            break;
+                        }
+                        default: {
+                            jsPath = readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                        }
+                    }
                     if (typeof jsPath === "string" && jsPath.length > packageDirectory.length) {
                         var potentialSubModule_1 = jsPath.substring(packageDirectory.length + 1);
                         subModuleName = (ts.forEach(ts.supportedJSExtensions, function (extension) {
@@ -27049,7 +27374,7 @@ var ts;
             }
             var versionPaths = readPackageJsonTypesVersionPaths(packageJsonContent, state);
             var packageId = typeof packageJsonContent.name === "string" && typeof packageJsonContent.version === "string"
-                ? { name: packageJsonContent.name, subModuleName: subModuleName, version: packageJsonContent.version }
+                ? { name: packageJsonContent.name + "|" + parentFileExtension, subModuleName: subModuleName, version: packageJsonContent.version }
                 : undefined;
             if (traceEnabled) {
                 if (packageId) {
@@ -27069,18 +27394,79 @@ var ts;
             state.failedLookupLocations.push(packageJsonPath);
         }
     }
-    function loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, jsonContent, versionPaths) {
+    function loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, onlyRecordFailures, state, jsonContent, versionPaths) {
         var packageFile;
         if (jsonContent) {
             switch (extensions) {
                 case Extensions.JavaScript:
-                case Extensions.Json:
-                    packageFile = readPackageJsonMainField(jsonContent, candidate, state);
+                case Extensions.Json: {
+                    switch (parentFileExtension) {
+                        case ".android.js" /* AndroidJs */:
+                        case ".ios.js" /* IosJs */:
+                        case ".native.js" /* NativeJs */:
+                        case ".android.jsx" /* AndroidJsx */:
+                        case ".ios.jsx" /* IosJsx */:
+                        case ".native.jsx" /* NativeJsx */:
+                        case ".android.ts" /* AndroidTs */:
+                        case ".ios.ts" /* IosTs */:
+                        case ".native.ts" /* NativeTs */:
+                        case ".android.tsx" /* AndroidTsx */:
+                        case ".ios.tsx" /* IosTsx */:
+                        case ".native.tsx" /* NativeTsx */: {
+                            packageFile = readPackageJsonReactNativeField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        case ".web.js" /* WebJs */:
+                        case ".web.jsx" /* WebJsx */:
+                        case ".web.ts" /* WebTs */:
+                        case ".web.tsx" /* WebTsx */: {
+                            packageFile = readPackageJsonBrowserField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        default: {
+                            packageFile = readPackageJsonMainField(jsonContent, candidate, state);
+                        }
+                    }
                     break;
-                case Extensions.TypeScript:
-                    // When resolving typescript modules, try resolving using main field as well
-                    packageFile = readPackageJsonTypesFields(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                }
+                case Extensions.TypeScript: {
+                    switch (parentFileExtension) {
+                        case ".android.js" /* AndroidJs */:
+                        case ".ios.js" /* IosJs */:
+                        case ".native.js" /* NativeJs */:
+                        case ".android.jsx" /* AndroidJsx */:
+                        case ".ios.jsx" /* IosJsx */:
+                        case ".native.jsx" /* NativeJsx */:
+                        case ".android.ts" /* AndroidTs */:
+                        case ".ios.ts" /* IosTs */:
+                        case ".native.ts" /* NativeTs */:
+                        case ".android.tsx" /* AndroidTsx */:
+                        case ".ios.tsx" /* IosTsx */:
+                        case ".native.tsx" /* NativeTsx */: {
+                            packageFile = readPackageJsonReactNativeField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        case ".web.js" /* WebJs */:
+                        case ".web.jsx" /* WebJsx */:
+                        case ".web.ts" /* WebTs */:
+                        case ".web.tsx" /* WebTsx */: {
+                            packageFile = readPackageJsonBrowserField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        case ".node.js" /* NodeJs */:
+                        case ".node.jsx" /* NodeJsx */:
+                        case ".node.ts" /* NodeTs */:
+                        case ".node.tsx" /* NodeTsx */: {
+                            packageFile = readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        default: {
+                            // When resolving typescript modules, try resolving using main field as well
+                            packageFile = readPackageJsonTypesFields(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                        }
+                    }
                     break;
+                }
                 case Extensions.DtsOnly:
                     packageFile = readPackageJsonTypesFields(jsonContent, candidate, state);
                     break;
@@ -27091,7 +27477,7 @@ var ts;
                     return ts.Debug.assertNever(extensions);
             }
         }
-        var loader = function (extensions, candidate, onlyRecordFailures, state) {
+        var loader = function (parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
             var fromFile = tryFile(candidate, onlyRecordFailures, state);
             if (fromFile) {
                 var resolved = resolvedIfExtensionMatches(extensions, fromFile);
@@ -27105,7 +27491,7 @@ var ts;
             // Even if extensions is DtsOnly, we can still look up a .ts file as a result of package.json "types"
             var nextExtensions = extensions === Extensions.DtsOnly ? Extensions.TypeScript : extensions;
             // Don't do package.json lookup recursively, because Node.js' package lookup doesn't.
-            return nodeLoadModuleByRelativeName(nextExtensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ false);
+            return nodeLoadModuleByRelativeName(parentFileExtension, nextExtensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ false);
         };
         var onlyRecordFailuresForPackageFile = packageFile ? !ts.directoryProbablyExists(ts.getDirectoryPath(packageFile), state.host) : undefined;
         var onlyRecordFailuresForIndex = onlyRecordFailures || !ts.directoryProbablyExists(candidate, state.host);
@@ -27115,16 +27501,16 @@ var ts;
             if (state.traceEnabled) {
                 trace(state.host, ts.Diagnostics.package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2, versionPaths.version, ts.version, moduleName);
             }
-            var result = tryLoadModuleUsingPaths(extensions, moduleName, candidate, versionPaths.paths, loader, onlyRecordFailuresForPackageFile || onlyRecordFailuresForIndex, state);
+            var result = tryLoadModuleUsingPaths(parentFileExtension, extensions, moduleName, candidate, versionPaths.paths, loader, onlyRecordFailuresForPackageFile || onlyRecordFailuresForIndex, state);
             if (result) {
                 return removeIgnoredPackageId(result.value);
             }
         }
         // It won't have a `packageId` set, because we disabled `considerPackageJson`.
-        var packageFileResult = packageFile && removeIgnoredPackageId(loader(extensions, packageFile, onlyRecordFailuresForPackageFile, state));
+        var packageFileResult = packageFile && removeIgnoredPackageId(loader(parentFileExtension, extensions, packageFile, onlyRecordFailuresForPackageFile, state));
         if (packageFileResult)
             return packageFileResult;
-        return loadModuleFromFile(extensions, indexPath, onlyRecordFailuresForIndex, state);
+        return loadModuleFromFile(parentFileExtension, extensions, indexPath, onlyRecordFailuresForIndex, state);
     }
     /** Resolve from an arbitrarily specified file. Return `undefined` if it has an unsupported extension. */
     function resolvedIfExtensionMatches(extensions, path) {
@@ -27135,12 +27521,40 @@ var ts;
     function extensionIsOk(extensions, extension) {
         switch (extensions) {
             case Extensions.JavaScript:
-                return extension === ".js" /* Js */ || extension === ".jsx" /* Jsx */;
+                return (extension === ".js" /* Js */ ||
+                    extension === ".jsx" /* Jsx */ ||
+                    extension === ".node.js" /* NodeJs */ ||
+                    extension === ".node.jsx" /* NodeJsx */ ||
+                    extension === ".web.js" /* WebJs */ ||
+                    extension === ".web.jsx" /* WebJsx */ ||
+                    extension === ".native.js" /* NativeJs */ ||
+                    extension === ".native.jsx" /* NativeJsx */ ||
+                    extension === ".ios.js" /* IosJs */ ||
+                    extension === ".ios.jsx" /* IosJsx */ ||
+                    extension === ".android.js" /* AndroidJs */ ||
+                    extension === ".android.jsx" /* AndroidJsx */);
             case Extensions.TSConfig:
             case Extensions.Json:
-                return extension === ".json" /* Json */;
+                return (extension === ".json" /* Json */ ||
+                    extension === ".node.json" /* NodeJson */ ||
+                    extension === ".web.json" /* WebJson */ ||
+                    extension === ".native.json" /* NativeJson */ ||
+                    extension === ".ios.json" /* IosJson */ ||
+                    extension === ".android.json" /* AndroidJson */);
             case Extensions.TypeScript:
-                return extension === ".ts" /* Ts */ || extension === ".tsx" /* Tsx */ || extension === ".d.ts" /* Dts */;
+                return (extension === ".ts" /* Ts */ ||
+                    extension === ".tsx" /* Tsx */ ||
+                    extension === ".d.ts" /* Dts */ ||
+                    extension === ".node.ts" /* NodeTs */ ||
+                    extension === ".node.tsx" /* NodeTsx */ ||
+                    extension === ".web.ts" /* WebTs */ ||
+                    extension === ".web.tsx" /* WebTsx */ ||
+                    extension === ".native.ts" /* NativeTs */ ||
+                    extension === ".native.tsx" /* NativeTsx */ ||
+                    extension === ".ios.ts" /* IosTs */ ||
+                    extension === ".ios.tsx" /* IosTsx */ ||
+                    extension === ".android.ts" /* AndroidTs */ ||
+                    extension === ".android.tsx" /* AndroidTsx */);
             case Extensions.DtsOnly:
                 return extension === ".d.ts" /* Dts */;
         }
@@ -27154,32 +27568,33 @@ var ts;
         return idx === -1 ? { packageName: moduleName, rest: "" } : { packageName: moduleName.slice(0, idx), rest: moduleName.slice(idx + 1) };
     }
     ts.parsePackageName = parsePackageName;
-    function loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, directory, state, cache, redirectedReference) {
-        return loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName, directory, state, /*typesScopeOnly*/ false, cache, redirectedReference);
+    function loadModuleFromNearestNodeModulesDirectory(parentFileExtension, extensions, moduleName, directory, state, cache, redirectedReference) {
+        return loadModuleFromNearestNodeModulesDirectoryWorker(parentFileExtension, extensions, moduleName, directory, state, /*typesScopeOnly*/ false, cache, redirectedReference);
     }
     function loadModuleFromNearestNodeModulesDirectoryTypesScope(moduleName, directory, state) {
         // Extensions parameter here doesn't actually matter, because typesOnly ensures we're just doing @types lookup, which is always DtsOnly.
-        return loadModuleFromNearestNodeModulesDirectoryWorker(Extensions.DtsOnly, moduleName, directory, state, /*typesScopeOnly*/ true, /*cache*/ undefined, /*redirectedReference*/ undefined);
+        return loadModuleFromNearestNodeModulesDirectoryWorker(".ts" /* Ts */, Extensions.DtsOnly, moduleName, directory, state, /*typesScopeOnly*/ true, /*cache*/ undefined, /*redirectedReference*/ undefined);
     }
-    function loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
-        var perModuleNameCache = cache && cache.getOrCreateCacheForModuleName(moduleName, redirectedReference);
+    function loadModuleFromNearestNodeModulesDirectoryWorker(parentFileExtension, extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
+        var moduleNameKey = moduleName + "|" + parentFileExtension;
+        var perModuleNameCache = cache && cache.getOrCreateCacheForModuleName(moduleNameKey, redirectedReference);
         return ts.forEachAncestorDirectory(ts.normalizeSlashes(directory), function (ancestorDirectory) {
             if (ts.getBaseFileName(ancestorDirectory) !== "node_modules") {
                 var resolutionFromCache = tryFindNonRelativeModuleNameInCache(perModuleNameCache, moduleName, ancestorDirectory, state);
                 if (resolutionFromCache) {
                     return resolutionFromCache;
                 }
-                return toSearchResult(loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, ancestorDirectory, state, typesScopeOnly));
+                return toSearchResult(loadModuleFromImmediateNodeModulesDirectory(parentFileExtension, extensions, moduleName, ancestorDirectory, state, typesScopeOnly));
             }
         });
     }
-    function loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, directory, state, typesScopeOnly) {
+    function loadModuleFromImmediateNodeModulesDirectory(parentFileExtension, extensions, moduleName, directory, state, typesScopeOnly) {
         var nodeModulesFolder = ts.combinePaths(directory, "node_modules");
         var nodeModulesFolderExists = ts.directoryProbablyExists(nodeModulesFolder, state.host);
         if (!nodeModulesFolderExists && state.traceEnabled) {
             trace(state.host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, nodeModulesFolder);
         }
-        var packageResult = typesScopeOnly ? undefined : loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesFolder, nodeModulesFolderExists, state);
+        var packageResult = typesScopeOnly ? undefined : loadModuleFromSpecificNodeModulesDirectory(parentFileExtension, extensions, moduleName, nodeModulesFolder, nodeModulesFolderExists, state);
         if (packageResult) {
             return packageResult;
         }
@@ -27192,35 +27607,35 @@ var ts;
                 }
                 nodeModulesAtTypesExists = false;
             }
-            return loadModuleFromSpecificNodeModulesDirectory(Extensions.DtsOnly, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes_1, nodeModulesAtTypesExists, state);
+            return loadModuleFromSpecificNodeModulesDirectory(parentFileExtension, Extensions.DtsOnly, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes_1, nodeModulesAtTypesExists, state);
         }
     }
-    function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state) {
+    function loadModuleFromSpecificNodeModulesDirectory(parentFileExtension, extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state) {
         var candidate = ts.normalizePath(ts.combinePaths(nodeModulesDirectory, moduleName));
         // First look for a nested package.json, as in `node_modules/foo/bar/package.json`.
         var packageJsonContent;
         var packageId;
         var versionPaths;
-        var packageInfo = getPackageJsonInfo(candidate, "", !nodeModulesDirectoryExists, state);
+        var packageInfo = getPackageJsonInfo(parentFileExtension, candidate, "", !nodeModulesDirectoryExists, state);
         if (packageInfo) {
             (packageJsonContent = packageInfo.packageJsonContent, packageId = packageInfo.packageId, versionPaths = packageInfo.versionPaths);
-            var fromFile = loadModuleFromFile(extensions, candidate, !nodeModulesDirectoryExists, state);
+            var fromFile = loadModuleFromFile(parentFileExtension, extensions, candidate, !nodeModulesDirectoryExists, state);
             if (fromFile) {
                 return noPackageId(fromFile);
             }
-            var fromDirectory = loadNodeModuleFromDirectoryWorker(extensions, candidate, !nodeModulesDirectoryExists, state, packageJsonContent, versionPaths);
+            var fromDirectory = loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, !nodeModulesDirectoryExists, state, packageJsonContent, versionPaths);
             return withPackageId(packageId, fromDirectory);
         }
-        var loader = function (extensions, candidate, onlyRecordFailures, state) {
-            var pathAndExtension = loadModuleFromFile(extensions, candidate, onlyRecordFailures, state) ||
-                loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths);
+        var loader = function (parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
+            var pathAndExtension = loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state) ||
+                loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths);
             return withPackageId(packageId, pathAndExtension);
         };
         var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;
         if (rest !== "") { // If "rest" is empty, we just did this search above.
             var packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
             // Don't use a "types" or "main" from here because we're not loading the root, but a subdirectory -- just here for the packageId and path mappings.
-            var packageInfo_1 = getPackageJsonInfo(packageDirectory, rest, !nodeModulesDirectoryExists, state);
+            var packageInfo_1 = getPackageJsonInfo(parentFileExtension, packageDirectory, rest, !nodeModulesDirectoryExists, state);
             if (packageInfo_1)
                 (packageId = packageInfo_1.packageId, versionPaths = packageInfo_1.versionPaths);
             if (versionPaths) {
@@ -27228,15 +27643,15 @@ var ts;
                     trace(state.host, ts.Diagnostics.package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2, versionPaths.version, ts.version, rest);
                 }
                 var packageDirectoryExists = nodeModulesDirectoryExists && ts.directoryProbablyExists(packageDirectory, state.host);
-                var fromPaths = tryLoadModuleUsingPaths(extensions, rest, packageDirectory, versionPaths.paths, loader, !packageDirectoryExists, state);
+                var fromPaths = tryLoadModuleUsingPaths(parentFileExtension, extensions, rest, packageDirectory, versionPaths.paths, loader, !packageDirectoryExists, state);
                 if (fromPaths) {
                     return fromPaths.value;
                 }
             }
         }
-        return loader(extensions, candidate, !nodeModulesDirectoryExists, state);
+        return loader(parentFileExtension, extensions, candidate, !nodeModulesDirectoryExists, state);
     }
-    function tryLoadModuleUsingPaths(extensions, moduleName, baseDirectory, paths, loader, onlyRecordFailures, state) {
+    function tryLoadModuleUsingPaths(parentFileExtension, extensions, moduleName, baseDirectory, paths, loader, onlyRecordFailures, state) {
         var matchedPattern = ts.matchPatternOrExact(ts.getOwnKeys(paths), moduleName);
         if (matchedPattern) {
             var matchedStar_1 = ts.isString(matchedPattern) ? undefined : ts.matchedText(matchedPattern, moduleName);
@@ -27258,7 +27673,7 @@ var ts;
                         return noPackageId({ path: path_1, ext: extension });
                     }
                 }
-                return loader(extensions, candidate, onlyRecordFailures || !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
+                return loader(parentFileExtension, extensions, candidate, onlyRecordFailures || !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
             });
             return { value: resolved };
         }
@@ -27316,7 +27731,7 @@ var ts;
             return { value: result.resolvedModule && { path: result.resolvedModule.resolvedFileName, originalPath: result.resolvedModule.originalPath || true, extension: result.resolvedModule.extension, packageId: result.resolvedModule.packageId } };
         }
     }
-    function classicNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
+    function classicNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
         var traceEnabled = isTraceEnabled(compilerOptions, host);
         var failedLookupLocations = [];
         var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations };
@@ -27325,7 +27740,7 @@ var ts;
         // No originalPath because classic resolution doesn't resolve realPath
         return createResolvedModuleWithFailedLookupLocations(resolved && resolved.value, /*isExternalLibraryImport*/ false, failedLookupLocations);
         function tryResolve(extensions) {
-            var resolvedUsingSettings = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loadModuleFromFileNoPackageId, state);
+            var resolvedUsingSettings = tryLoadModuleUsingOptionalResolutionSettings(parentFileExtension, extensions, moduleName, containingDirectory, loadModuleFromFileNoPackageId, state);
             if (resolvedUsingSettings) {
                 return { value: resolvedUsingSettings };
             }
@@ -27338,7 +27753,7 @@ var ts;
                         return resolutionFromCache;
                     }
                     var searchName = ts.normalizePath(ts.combinePaths(directory, moduleName));
-                    return toSearchResult(loadModuleFromFileNoPackageId(extensions, searchName, /*onlyRecordFailures*/ false, state));
+                    return toSearchResult(loadModuleFromFileNoPackageId(parentFileExtension, extensions, searchName, /*onlyRecordFailures*/ false, state));
                 });
                 if (resolved_3) {
                     return resolved_3;
@@ -27350,7 +27765,7 @@ var ts;
             }
             else {
                 var candidate = ts.normalizePath(ts.combinePaths(containingDirectory, moduleName));
-                return toSearchResult(loadModuleFromFileNoPackageId(extensions, candidate, /*onlyRecordFailures*/ false, state));
+                return toSearchResult(loadModuleFromFileNoPackageId(parentFileExtension, extensions, candidate, /*onlyRecordFailures*/ false, state));
             }
         }
     }
@@ -27360,14 +27775,15 @@ var ts;
      * This is the minumum code needed to expose that functionality; the rest is in LSHost.
      */
     /* @internal */
-    function loadModuleFromGlobalCache(moduleName, projectName, compilerOptions, host, globalCache) {
+    function loadModuleFromGlobalCache(moduleName, containingFile, projectName, compilerOptions, host, globalCache) {
         var traceEnabled = isTraceEnabled(compilerOptions, host);
         if (traceEnabled) {
             trace(host, ts.Diagnostics.Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2, projectName, moduleName, globalCache);
         }
         var failedLookupLocations = [];
         var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations };
-        var resolved = loadModuleFromImmediateNodeModulesDirectory(Extensions.DtsOnly, moduleName, globalCache, state, /*typesScopeOnly*/ false);
+        var parentFileContext = ts.getFileExtension(containingFile);
+        var resolved = loadModuleFromImmediateNodeModulesDirectory(parentFileContext, Extensions.DtsOnly, moduleName, globalCache, state, /*typesScopeOnly*/ false);
         return createResolvedModuleWithFailedLookupLocations(resolved, /*isExternalLibraryImport*/ true, failedLookupLocations);
     }
     ts.loadModuleFromGlobalCache = loadModuleFromGlobalCache;
@@ -90434,16 +90850,41 @@ var ts;
         var extension = _a.extension;
         switch (extension) {
             case ".ts" /* Ts */:
+            case ".node.ts" /* NodeTs */:
+            case ".web.ts" /* WebTs */:
+            case ".native.ts" /* NativeTs */:
+            case ".ios.ts" /* IosTs */:
+            case ".android.ts" /* AndroidTs */:
             case ".d.ts" /* Dts */:
                 // These are always allowed.
                 return undefined;
             case ".tsx" /* Tsx */:
+            case ".node.tsx" /* NodeTsx */:
+            case ".web.tsx" /* WebTsx */:
+            case ".native.tsx" /* NativeTsx */:
+            case ".ios.tsx" /* IosTsx */:
+            case ".android.tsx" /* AndroidTsx */:
                 return needJsx();
             case ".jsx" /* Jsx */:
+            case ".node.jsx" /* NodeJsx */:
+            case ".web.jsx" /* WebJsx */:
+            case ".native.jsx" /* NativeJsx */:
+            case ".ios.jsx" /* IosJsx */:
+            case ".android.jsx" /* AndroidJsx */:
                 return needJsx() || needAllowJs();
             case ".js" /* Js */:
+            case ".node.js" /* NodeJs */:
+            case ".web.js" /* WebJs */:
+            case ".native.js" /* NativeJs */:
+            case ".ios.js" /* IosJs */:
+            case ".android.js" /* AndroidJs */:
                 return needAllowJs();
             case ".json" /* Json */:
+            case ".node.json" /* NodeJson */:
+            case ".web.json" /* WebJson */:
+            case ".native.json" /* NativeJson */:
+            case ".ios.json" /* IosJson */:
+            case ".android.json" /* AndroidJson */:
                 return needResolveJsonModule();
         }
         function needJsx() {
@@ -91854,7 +92295,7 @@ var ts;
             if (globalCache !== undefined && !ts.isExternalModuleNameRelative(moduleName) && !(primaryResult.resolvedModule && ts.extensionIsTS(primaryResult.resolvedModule.extension))) {
                 // create different collection of failed lookup locations for second pass
                 // if it will fail and we've already found something during the first pass - we don't want to pollute its results
-                var _a = ts.loadModuleFromGlobalCache(moduleName, resolutionHost.projectName, compilerOptions, host, globalCache), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
+                var _a = ts.loadModuleFromGlobalCache(moduleName, containingFile, resolutionHost.projectName, compilerOptions, host, globalCache), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
                 if (resolvedModule) {
                     return { resolvedModule: resolvedModule, failedLookupLocations: ts.addRange(primaryResult.failedLookupLocations, failedLookupLocations) };
                 }
@@ -91864,7 +92305,9 @@ var ts;
         }
         function resolveNamesWithLocalCache(names, containingFile, redirectedReference, cache, perDirectoryCacheWithRedirects, loader, getResolutionWithResolvedFileName, shouldRetryResolution, reusedNames, logChanges) {
             var path = resolutionHost.toPath(containingFile);
-            var resolutionsInFile = cache.get(path) || cache.set(path, ts.createMap()).get(path);
+            var context = ts.getFileExtension(containingFile);
+            var pathKey = path + "|" + context;
+            var resolutionsInFile = cache.get(pathKey) || cache.set(pathKey, ts.createMap()).get(pathKey);
             var dirPath = ts.getDirectoryPath(path);
             var perDirectoryCache = perDirectoryCacheWithRedirects.getOrCreateMapOfCacheRedirects(redirectedReference);
             var perDirectoryResolution = perDirectoryCache.get(dirPath);
@@ -91884,22 +92327,23 @@ var ts;
             var seenNamesInFile = ts.createMap();
             for (var _i = 0, names_2 = names; _i < names_2.length; _i++) {
                 var name = names_2[_i];
-                var resolution = resolutionsInFile.get(name);
+                var nameKey = name + "|" + context;
+                var resolution = resolutionsInFile.get(nameKey);
                 // Resolution is valid if it is present and not invalidated
-                if (!seenNamesInFile.has(name) &&
+                if (!seenNamesInFile.has(nameKey) &&
                     allFilesHaveInvalidatedResolution || unmatchedRedirects || !resolution || resolution.isInvalidated ||
                     // If the name is unresolved import that was invalidated, recalculate
                     (hasInvalidatedNonRelativeUnresolvedImport && !ts.isExternalModuleNameRelative(name) && shouldRetryResolution(resolution))) {
                     var existingResolution = resolution;
-                    var resolutionInDirectory = perDirectoryResolution.get(name);
+                    var resolutionInDirectory = perDirectoryResolution.get(nameKey);
                     if (resolutionInDirectory) {
                         resolution = resolutionInDirectory;
                     }
                     else {
                         resolution = loader(name, containingFile, compilerOptions, resolutionHost, redirectedReference);
-                        perDirectoryResolution.set(name, resolution);
+                        perDirectoryResolution.set(nameKey, resolution);
                     }
-                    resolutionsInFile.set(name, resolution);
+                    resolutionsInFile.set(nameKey, resolution);
                     watchFailedLookupLocationsOfExternalModuleResolutions(name, resolution);
                     if (existingResolution) {
                         stopWatchFailedLookupLocationOfResolution(existingResolution);
@@ -91911,14 +92355,15 @@ var ts;
                     }
                 }
                 ts.Debug.assert(resolution !== undefined && !resolution.isInvalidated);
-                seenNamesInFile.set(name, true);
+                seenNamesInFile.set(nameKey, true);
                 resolvedModules.push(getResolutionWithResolvedFileName(resolution));
             }
             // Stop watching and remove the unused name
-            resolutionsInFile.forEach(function (resolution, name) {
-                if (!seenNamesInFile.has(name) && !ts.contains(reusedNames, name)) {
+            resolutionsInFile.forEach(function (resolution, nameKey) {
+                var name = nameKey.split('|')[0];
+                if (!seenNamesInFile.has(nameKey) && !ts.contains(reusedNames, name)) {
                     stopWatchFailedLookupLocationOfResolution(resolution);
-                    resolutionsInFile.delete(name);
+                    resolutionsInFile.delete(nameKey);
                 }
             });
             return resolvedModules;
@@ -92716,11 +93161,46 @@ var ts;
                 case ".ts" /* Ts */:
                 case ".d.ts" /* Dts */:
                     return ".js" /* Js */;
+                case ".node.ts" /* NodeTs */:
+                    return ".node.js" /* NodeJs */;
+                case ".web.ts" /* WebTs */:
+                    return ".web.js" /* WebJs */;
+                case ".native.ts" /* NativeTs */:
+                    return ".native.js" /* NativeJs */;
+                case ".ios.ts" /* IosTs */:
+                    return ".ios.js" /* IosJs */;
+                case ".android.ts" /* AndroidTs */:
+                    return ".android.js" /* AndroidJs */;
                 case ".tsx" /* Tsx */:
                     return options.jsx === 1 /* Preserve */ ? ".jsx" /* Jsx */ : ".js" /* Js */;
+                case ".node.tsx" /* NodeTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".node.jsx" /* NodeJsx */ : ".node.js" /* NodeJs */;
+                case ".web.tsx" /* WebTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".web.jsx" /* WebJsx */ : ".web.js" /* WebJs */;
+                case ".native.tsx" /* NativeTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".native.jsx" /* NativeJsx */ : ".native.js" /* NativeJs */;
+                case ".ios.tsx" /* IosTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".ios.jsx" /* IosJsx */ : ".ios.js" /* IosJs */;
+                case ".android.tsx" /* AndroidTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".android.jsx" /* AndroidJsx */ : ".android.js" /* AndroidJs */;
                 case ".js" /* Js */:
                 case ".jsx" /* Jsx */:
+                case ".node.js" /* NodeJs */:
+                case ".node.jsx" /* NodeJsx */:
+                case ".web.js" /* WebJs */:
+                case ".web.jsx" /* WebJsx */:
+                case ".native.js" /* NativeJs */:
+                case ".native.jsx" /* NativeJsx */:
+                case ".ios.js" /* IosJs */:
+                case ".ios.jsx" /* IosJsx */:
+                case ".android.js" /* AndroidJs */:
+                case ".android.jsx" /* AndroidJsx */:
                 case ".json" /* Json */:
+                case ".node.json" /* NodeJson */:
+                case ".web.json" /* WebJson */:
+                case ".native.json" /* NativeJson */:
+                case ".ios.json" /* IosJson */:
+                case ".android.json" /* AndroidJson */:
                     return ext;
                 case ".tsbuildinfo" /* TsBuildInfo */:
                     return ts.Debug.fail("Extension " + ".tsbuildinfo" /* TsBuildInfo */ + " is unsupported:: FileName:: " + fileName);
@@ -98267,14 +98747,47 @@ var ts;
             }
             function kindModifiersFromExtension(extension) {
                 switch (extension) {
-                    case ".d.ts" /* Dts */: return ".d.ts" /* dtsModifier */;
-                    case ".js" /* Js */: return ".js" /* jsModifier */;
-                    case ".json" /* Json */: return ".json" /* jsonModifier */;
-                    case ".jsx" /* Jsx */: return ".jsx" /* jsxModifier */;
-                    case ".ts" /* Ts */: return ".ts" /* tsModifier */;
-                    case ".tsx" /* Tsx */: return ".tsx" /* tsxModifier */;
-                    case ".tsbuildinfo" /* TsBuildInfo */: return ts.Debug.fail("Extension " + ".tsbuildinfo" /* TsBuildInfo */ + " is unsupported.");
-                    case undefined: return "" /* none */;
+                    case ".d.ts" /* Dts */:
+                        return ".d.ts" /* dtsModifier */;
+                    case ".js" /* Js */:
+                    case ".node.js" /* NodeJs */:
+                    case ".web.js" /* WebJs */:
+                    case ".native.js" /* NativeJs */:
+                    case ".ios.js" /* IosJs */:
+                    case ".android.js" /* AndroidJs */:
+                        return ".js" /* jsModifier */;
+                    case ".json" /* Json */:
+                    case ".node.json" /* NodeJson */:
+                    case ".web.json" /* WebJson */:
+                    case ".native.json" /* NativeJson */:
+                    case ".ios.json" /* IosJson */:
+                    case ".android.json" /* AndroidJson */:
+                        return ".json" /* jsonModifier */;
+                    case ".jsx" /* Jsx */:
+                    case ".node.jsx" /* NodeJsx */:
+                    case ".web.jsx" /* WebJsx */:
+                    case ".native.jsx" /* NativeJsx */:
+                    case ".ios.jsx" /* IosJsx */:
+                    case ".android.jsx" /* AndroidJsx */:
+                        return ".jsx" /* jsxModifier */;
+                    case ".ts" /* Ts */:
+                    case ".node.ts" /* NodeTs */:
+                    case ".web.ts" /* WebTs */:
+                    case ".native.ts" /* NativeTs */:
+                    case ".ios.ts" /* IosTs */:
+                    case ".android.ts" /* AndroidTs */:
+                        return ".ts" /* tsModifier */;
+                    case ".tsx" /* Tsx */:
+                    case ".node.tsx" /* NodeTsx */:
+                    case ".web.tsx" /* WebTsx */:
+                    case ".native.tsx" /* NativeTsx */:
+                    case ".ios.tsx" /* IosTsx */:
+                    case ".android.tsx" /* AndroidTsx */:
+                        return ".tsx" /* tsxModifier */;
+                    case ".tsbuildinfo" /* TsBuildInfo */:
+                        return ts.Debug.fail("Extension " + ".tsbuildinfo" /* TsBuildInfo */ + " is unsupported.");
+                    case undefined:
+                        return "" /* none */;
                     default:
                         return ts.Debug.assertNever(extension);
                 }
diff --git a/lib/typescriptServices.d.ts b/lib/typescriptServices.d.ts
index b9b02d5591..5ebb6784d2 100644
--- a/lib/typescriptServices.d.ts
+++ b/lib/typescriptServices.d.ts
@@ -2716,12 +2716,37 @@ declare namespace ts {
     }
     enum Extension {
         Ts = ".ts",
+        IosTs = ".ios.ts",
+        AndroidTs = ".android.ts",
+        NativeTs = ".native.ts",
+        WebTs = ".web.ts",
+        NodeTs = ".node.ts",
         Tsx = ".tsx",
+        IosTsx = ".ios.tsx",
+        AndroidTsx = ".android.tsx",
+        NativeTsx = ".native.tsx",
+        WebTsx = ".web.tsx",
+        NodeTsx = ".node.tsx",
         Dts = ".d.ts",
         Js = ".js",
+        IosJs = ".ios.js",
+        AndroidJs = ".android.js",
+        NativeJs = ".native.js",
+        WebJs = ".web.js",
+        NodeJs = ".node.js",
         Jsx = ".jsx",
         Json = ".json",
-        TsBuildInfo = ".tsbuildinfo"
+        TsBuildInfo = ".tsbuildinfo",
+        IosJsx = ".ios.jsx",
+        AndroidJsx = ".android.jsx",
+        NativeJsx = ".native.jsx",
+        WebJsx = ".web.jsx",
+        NodeJsx = ".node.jsx",
+        IosJson = ".ios.json",
+        AndroidJson = ".android.json",
+        NativeJson = ".native.json",
+        WebJson = ".web.json",
+        NodeJson = ".node.json"
     }
     interface ResolvedModuleWithFailedLookupLocations {
         readonly resolvedModule: ResolvedModuleFull | undefined;
@@ -3717,8 +3742,8 @@ declare namespace ts {
     function createModuleResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string): ModuleResolutionCache;
     function resolveModuleNameFromCache(moduleName: string, containingFile: string, cache: ModuleResolutionCache): ResolvedModuleWithFailedLookupLocations | undefined;
     function resolveModuleName(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
-    function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
-    function classicNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
+    function nodeModuleNameResolver(parentFileExtension: Extension, moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
+    function classicNameResolver(parentFileExtension: Extension, moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
 }
 declare namespace ts {
     function createNodeArray<T extends Node>(elements?: ReadonlyArray<T>, hasTrailingComma?: boolean): NodeArray<T>;
diff --git a/lib/typescriptServices.js b/lib/typescriptServices.js
index 835a9569ba..ac03fb5060 100644
--- a/lib/typescriptServices.js
+++ b/lib/typescriptServices.js
@@ -3833,12 +3833,37 @@ var ts;
     var Extension;
     (function (Extension) {
         Extension["Ts"] = ".ts";
+        Extension["IosTs"] = ".ios.ts";
+        Extension["AndroidTs"] = ".android.ts";
+        Extension["NativeTs"] = ".native.ts";
+        Extension["WebTs"] = ".web.ts";
+        Extension["NodeTs"] = ".node.ts";
         Extension["Tsx"] = ".tsx";
+        Extension["IosTsx"] = ".ios.tsx";
+        Extension["AndroidTsx"] = ".android.tsx";
+        Extension["NativeTsx"] = ".native.tsx";
+        Extension["WebTsx"] = ".web.tsx";
+        Extension["NodeTsx"] = ".node.tsx";
         Extension["Dts"] = ".d.ts";
         Extension["Js"] = ".js";
+        Extension["IosJs"] = ".ios.js";
+        Extension["AndroidJs"] = ".android.js";
+        Extension["NativeJs"] = ".native.js";
+        Extension["WebJs"] = ".web.js";
+        Extension["NodeJs"] = ".node.js";
         Extension["Jsx"] = ".jsx";
         Extension["Json"] = ".json";
         Extension["TsBuildInfo"] = ".tsbuildinfo";
+        Extension["IosJsx"] = ".ios.jsx";
+        Extension["AndroidJsx"] = ".android.jsx";
+        Extension["NativeJsx"] = ".native.jsx";
+        Extension["WebJsx"] = ".web.jsx";
+        Extension["NodeJsx"] = ".node.jsx";
+        Extension["IosJson"] = ".ios.json";
+        Extension["AndroidJson"] = ".android.json";
+        Extension["NativeJson"] = ".native.json";
+        Extension["WebJson"] = ".web.json";
+        Extension["NodeJson"] = ".node.json";
     })(Extension = ts.Extension || (ts.Extension = {}));
     /* @internal */
     var TransformFlags;
@@ -5027,7 +5052,21 @@ var ts;
             }
             function realpath(path) {
                 try {
-                    return _fs.realpathSync(path);
+                    var regexp = /\.([^\/]+?)$/;
+                    var match = path.match(regexp);
+                    var rpath = _fs.realpathSync(path);
+                    if (match !== null) {
+                        var ext = match[1];
+                        var rmatch = rpath.match(regexp);
+                        if (rmatch !== null) {
+                            var rext = rmatch[1];
+                            if (ext !== rext) {
+                                return rpath.replace(new RegExp(rext + "$"), ext);
+                            }
+                            return rpath;
+                        }
+                    }
+                    return rpath;
                 }
                 catch (_a) {
                     return path;
@@ -12043,7 +12082,7 @@ var ts;
     }
     /** Return ".ts", ".d.ts", or ".tsx", if that is the extension. */
     function tryExtractTSExtension(fileName) {
-        return ts.find(ts.supportedTSExtensionsForExtractExtension, function (extension) { return ts.fileExtensionIs(fileName, extension); });
+        return ts.find(ts.supportedTSExtensions, function (extension) { return ts.fileExtensionIs(fileName, extension); });
     }
     ts.tryExtractTSExtension = tryExtractTSExtension;
     /**
@@ -16007,14 +16046,55 @@ var ts;
     /**
      *  List of supported extensions in order of file resolution precedence.
      */
-    ts.supportedTSExtensions = [".ts" /* Ts */, ".tsx" /* Tsx */, ".d.ts" /* Dts */];
-    ts.supportedTSExtensionsWithJson = [".ts" /* Ts */, ".tsx" /* Tsx */, ".d.ts" /* Dts */, ".json" /* Json */];
-    /** Must have ".d.ts" first because if ".ts" goes first, that will be detected as the extension instead of ".d.ts". */
-    ts.supportedTSExtensionsForExtractExtension = [".d.ts" /* Dts */, ".ts" /* Ts */, ".tsx" /* Tsx */];
-    ts.supportedJSExtensions = [".js" /* Js */, ".jsx" /* Jsx */];
-    ts.supportedJSAndJsonExtensions = [".js" /* Js */, ".jsx" /* Jsx */, ".json" /* Json */];
+    ts.supportedJsonExtensions = [
+        ".node.json" /* NodeJson */,
+        ".web.json" /* WebJson */,
+        ".native.json" /* NativeJson */,
+        ".ios.json" /* IosJson */,
+        ".android.json" /* AndroidJson */,
+        ".json" /* Json */
+    ];
+    ts.supportedTSExtensions = [
+        ".node.ts" /* NodeTs */,
+        ".node.tsx" /* NodeTsx */,
+        ".web.ts" /* WebTs */,
+        ".web.tsx" /* WebTsx */,
+        ".native.ts" /* NativeTs */,
+        ".native.tsx" /* NativeTsx */,
+        ".ios.ts" /* IosTs */,
+        ".ios.tsx" /* IosTsx */,
+        ".android.ts" /* AndroidTs */,
+        ".android.tsx" /* AndroidTsx */,
+        ".d.ts" /* Dts */,
+        ".ts" /* Ts */,
+        ".tsx" /* Tsx */
+    ];
+    ts.supportedTSExtensionsWithJson = ts.supportedTSExtensions.concat(ts.supportedJsonExtensions);
+    ts.supportedJSExtensions = [
+        ".node.js" /* NodeJs */,
+        ".node.jsx" /* NodeJsx */,
+        ".web.js" /* WebJs */,
+        ".web.jsx" /* WebJsx */,
+        ".native.js" /* NativeJs */,
+        ".native.jsx" /* NativeJsx */,
+        ".ios.js" /* IosJs */,
+        ".ios.jsx" /* IosJsx */,
+        ".android.js" /* AndroidJs */,
+        ".android.jsx" /* AndroidJsx */,
+        ".js" /* Js */,
+        ".jsx" /* Jsx */
+    ];
+    ts.supportedJSAndJsonExtensions = ts.supportedJSExtensions.concat(ts.supportedJsonExtensions);
     var allSupportedExtensions = ts.supportedTSExtensions.concat(ts.supportedJSExtensions);
-    var allSupportedExtensionsWithJson = ts.supportedTSExtensions.concat(ts.supportedJSExtensions, [".json" /* Json */]);
+    var allSupportedExtensionsWithJson = ts.supportedTSExtensions.concat(ts.supportedJSExtensions, ts.supportedJsonExtensions);
+    function getAllSupportedExtensions() {
+        return allSupportedExtensions;
+    }
+    ts.getAllSupportedExtensions = getAllSupportedExtensions;
+    function getAllSupportedExtensionsWithJson() {
+        return allSupportedExtensionsWithJson;
+    }
+    ts.getAllSupportedExtensionsWithJson = getAllSupportedExtensionsWithJson;
     function getSupportedExtensions(options, extraFileExtensions) {
         var needJsExtensions = options && options.allowJs;
         if (!extraFileExtensions || extraFileExtensions.length === 0) {
@@ -16186,7 +16266,7 @@ var ts;
     ts.positionIsSynthesized = positionIsSynthesized;
     /** True if an extension is one of the supported TypeScript extensions. */
     function extensionIsTS(ext) {
-        return ext === ".ts" /* Ts */ || ext === ".tsx" /* Tsx */ || ext === ".d.ts" /* Dts */;
+        return ts.supportedTSExtensions.indexOf(ext) !== -1;
     }
     ts.extensionIsTS = extensionIsTS;
     function resolutionExtensionIsTSOrJson(ext) {
@@ -16207,7 +16287,7 @@ var ts;
     }
     ts.isAnySupportedFileExtension = isAnySupportedFileExtension;
     function tryGetExtensionFromPath(path) {
-        return ts.find(extensionsToRemove, function (e) { return ts.fileExtensionIs(path, e); });
+        return ts.find(allSupportedExtensionsWithJson, function (e) { return ts.fileExtensionIs(path, e); });
     }
     ts.tryGetExtensionFromPath = tryGetExtensionFromPath;
     function getAnyExtensionFromPathWorker(path, extensions, stringEqualityComparer) {
@@ -16248,6 +16328,19 @@ var ts;
         files: ts.emptyArray,
         directories: ts.emptyArray
     };
+    function getFileExtension(filepath) {
+        if (typeof filepath === "undefined") {
+            return ".ts" /* Ts */;
+        }
+        for (var _i = 0, allSupportedExtensionsWithJson_1 = allSupportedExtensionsWithJson; _i < allSupportedExtensionsWithJson_1.length; _i++) {
+            var ext = allSupportedExtensionsWithJson_1[_i];
+            if (ts.endsWith(filepath, ext)) {
+                return ext;
+            }
+        }
+        return ".ts" /* Ts */;
+    }
+    ts.getFileExtension = getFileExtension;
     /**
      * patternStrings contains both pattern strings (containing "*") and regular strings.
      * Return an exact match if possible, or a pattern match, or undefined.
@@ -25611,7 +25704,7 @@ var ts;
             return extendedConfigPath;
         }
         // If the path isn't a rooted or relative path, resolve like a module
-        var resolved = ts.nodeModuleNameResolver(extendedConfig, ts.combinePaths(basePath, "tsconfig.json"), { moduleResolution: ts.ModuleResolutionKind.NodeJs }, host, /*cache*/ undefined, /*projectRefs*/ undefined, /*lookupConfig*/ true);
+        var resolved = ts.nodeModuleNameResolver(".ts" /* Ts */, extendedConfig, ts.combinePaths(basePath, "tsconfig.json"), { moduleResolution: ts.ModuleResolutionKind.NodeJs }, host, /*cache*/ undefined, /*projectRefs*/ undefined, /*lookupConfig*/ true);
         if (resolved.resolvedModule) {
             return resolved.resolvedModule.resolvedFileName;
         }
@@ -26190,6 +26283,12 @@ var ts;
     function readPackageJsonMainField(jsonContent, baseDirectory, state) {
         return readPackageJsonPathField(jsonContent, "main", baseDirectory, state);
     }
+    function readPackageJsonReactNativeField(jsonContent, baseDirectory, state) {
+        return readPackageJsonPathField(jsonContent, "react-native", baseDirectory, state);
+    }
+    function readPackageJsonBrowserField(jsonContent, baseDirectory, state) {
+        return readPackageJsonPathField(jsonContent, "browser", baseDirectory, state);
+    }
     function readPackageJsonTypesVersionsField(jsonContent, state) {
         var typesVersions = readPackageJsonField(jsonContent, "typesVersions", "object", state);
         if (typesVersions === undefined)
@@ -26344,7 +26443,7 @@ var ts;
                     if (!directoryExists && traceEnabled) {
                         trace(host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, candidateDirectory);
                     }
-                    return resolvedTypeScriptOnly(loadNodeModuleFromDirectory(Extensions.DtsOnly, candidate, !directoryExists, moduleResolutionState));
+                    return resolvedTypeScriptOnly(loadNodeModuleFromDirectory(".ts" /* Ts */, Extensions.DtsOnly, candidate, !directoryExists, moduleResolutionState));
                 });
             }
             else {
@@ -26362,12 +26461,12 @@ var ts;
                 }
                 var result = void 0;
                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {
-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
+                    var searchResult = loadModuleFromNearestNodeModulesDirectory(".ts" /* Ts */, Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
                     result = searchResult && searchResult.value;
                 }
                 else {
                     var candidate = ts.normalizePathAndParts(ts.combinePaths(initialLocationForSecondaryLookup, typeReferenceDirectiveName)).path;
-                    result = nodeLoadModuleByRelativeName(Extensions.DtsOnly, candidate, /*onlyRecordFailures*/ false, moduleResolutionState, /*considerPackageJson*/ true);
+                    result = nodeLoadModuleByRelativeName(".ts" /* Ts */, Extensions.DtsOnly, candidate, /*onlyRecordFailures*/ false, moduleResolutionState, /*considerPackageJson*/ true);
                 }
                 var resolvedFile = resolvedTypeScriptOnly(result);
                 if (!resolvedFile && traceEnabled) {
@@ -26549,8 +26648,9 @@ var ts;
     ts.createModuleResolutionCacheWithMaps = createModuleResolutionCacheWithMaps;
     function resolveModuleNameFromCache(moduleName, containingFile, cache) {
         var containingDirectory = ts.getDirectoryPath(containingFile);
+        var parentFileExtension = ts.getFileExtension(containingFile);
         var perFolderCache = cache && cache.getOrCreateCacheForDirectory(containingDirectory);
-        return perFolderCache && perFolderCache.get(moduleName);
+        return perFolderCache && perFolderCache.get(moduleName + "|" + parentFileExtension);
     }
     ts.resolveModuleNameFromCache = resolveModuleNameFromCache;
     function resolveModuleName(moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
@@ -26565,8 +26665,10 @@ var ts;
             }
         }
         var containingDirectory = ts.getDirectoryPath(containingFile);
+        var parentFileExtension = ts.getFileExtension(containingFile);
+        var moduleNameKey = moduleName + "|" + parentFileExtension;
         var perFolderCache = cache && cache.getOrCreateCacheForDirectory(containingDirectory, redirectedReference);
-        var result = perFolderCache && perFolderCache.get(moduleName);
+        var result = perFolderCache && perFolderCache.get(moduleNameKey);
         if (result) {
             if (traceEnabled) {
                 trace(host, ts.Diagnostics.Resolution_for_module_0_was_found_in_cache_from_location_1, moduleName, containingDirectory);
@@ -26587,19 +26689,19 @@ var ts;
             }
             switch (moduleResolution) {
                 case ts.ModuleResolutionKind.NodeJs:
-                    result = nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
+                    result = nodeModuleNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
                     break;
                 case ts.ModuleResolutionKind.Classic:
-                    result = classicNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
+                    result = classicNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
                     break;
                 default:
                     return ts.Debug.fail("Unexpected moduleResolution: " + moduleResolution);
             }
             if (perFolderCache) {
-                perFolderCache.set(moduleName, result);
+                perFolderCache.set(moduleNameKey, result);
                 if (!ts.isExternalModuleNameRelative(moduleName)) {
                     // put result in per-module name cache
-                    cache.getOrCreateCacheForModuleName(moduleName, redirectedReference).set(containingDirectory, result);
+                    cache.getOrCreateCacheForModuleName(moduleNameKey, redirectedReference).set(containingDirectory, result);
                 }
             }
         }
@@ -26674,28 +26776,28 @@ var ts;
      * be converted to a path relative to found rootDir entry './content/protocols/file2' (*). As a last step compiler will check all remaining
      * entries in 'rootDirs', use them to build absolute path out of (*) and try to resolve module from this location.
      */
-    function tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loader, state) {
-        var resolved = tryLoadModuleUsingPathsIfEligible(extensions, moduleName, loader, state);
+    function tryLoadModuleUsingOptionalResolutionSettings(parentFileExtension, extensions, moduleName, containingDirectory, loader, state) {
+        var resolved = tryLoadModuleUsingPathsIfEligible(parentFileExtension, extensions, moduleName, loader, state);
         if (resolved)
             return resolved.value;
         if (!ts.isExternalModuleNameRelative(moduleName)) {
-            return tryLoadModuleUsingBaseUrl(extensions, moduleName, loader, state);
+            return tryLoadModuleUsingBaseUrl(parentFileExtension, extensions, moduleName, loader, state);
         }
         else {
-            return tryLoadModuleUsingRootDirs(extensions, moduleName, containingDirectory, loader, state);
+            return tryLoadModuleUsingRootDirs(parentFileExtension, extensions, moduleName, containingDirectory, loader, state);
         }
     }
-    function tryLoadModuleUsingPathsIfEligible(extensions, moduleName, loader, state) {
+    function tryLoadModuleUsingPathsIfEligible(parentFileExtension, extensions, moduleName, loader, state) {
         var _a = state.compilerOptions, baseUrl = _a.baseUrl, paths = _a.paths;
         if (baseUrl && paths && !ts.pathIsRelative(moduleName)) {
             if (state.traceEnabled) {
                 trace(state.host, ts.Diagnostics.baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1, baseUrl, moduleName);
                 trace(state.host, ts.Diagnostics.paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0, moduleName);
             }
-            return tryLoadModuleUsingPaths(extensions, moduleName, baseUrl, paths, loader, /*onlyRecordFailures*/ false, state);
+            return tryLoadModuleUsingPaths(parentFileExtension, extensions, moduleName, baseUrl, paths, loader, /*onlyRecordFailures*/ false, state);
         }
     }
-    function tryLoadModuleUsingRootDirs(extensions, moduleName, containingDirectory, loader, state) {
+    function tryLoadModuleUsingRootDirs(parentFileExtension, extensions, moduleName, containingDirectory, loader, state) {
         if (!state.compilerOptions.rootDirs) {
             return undefined;
         }
@@ -26733,7 +26835,7 @@ var ts;
             if (state.traceEnabled) {
                 trace(state.host, ts.Diagnostics.Loading_0_from_the_root_dir_1_candidate_location_2, suffix, matchedNormalizedPrefix, candidate);
             }
-            var resolvedFileName = loader(extensions, candidate, !ts.directoryProbablyExists(containingDirectory, state.host), state);
+            var resolvedFileName = loader(parentFileExtension, extensions, candidate, !ts.directoryProbablyExists(containingDirectory, state.host), state);
             if (resolvedFileName) {
                 return resolvedFileName;
             }
@@ -26752,7 +26854,7 @@ var ts;
                     trace(state.host, ts.Diagnostics.Loading_0_from_the_root_dir_1_candidate_location_2, suffix, rootDir, candidate_1);
                 }
                 var baseDirectory = ts.getDirectoryPath(candidate_1);
-                var resolvedFileName_1 = loader(extensions, candidate_1, !ts.directoryProbablyExists(baseDirectory, state.host), state);
+                var resolvedFileName_1 = loader(parentFileExtension, extensions, candidate_1, !ts.directoryProbablyExists(baseDirectory, state.host), state);
                 if (resolvedFileName_1) {
                     return resolvedFileName_1;
                 }
@@ -26763,7 +26865,7 @@ var ts;
         }
         return undefined;
     }
-    function tryLoadModuleUsingBaseUrl(extensions, moduleName, loader, state) {
+    function tryLoadModuleUsingBaseUrl(parentFileExtension, extensions, moduleName, loader, state) {
         var baseUrl = state.compilerOptions.baseUrl;
         if (!baseUrl) {
             return undefined;
@@ -26775,7 +26877,7 @@ var ts;
         if (state.traceEnabled) {
             trace(state.host, ts.Diagnostics.Resolving_module_name_0_relative_to_base_url_1_2, moduleName, baseUrl, candidate);
         }
-        return loader(extensions, candidate, !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
+        return loader(parentFileExtension, extensions, candidate, !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
     }
     /**
      * Expose resolution logic to allow us to use Node module resolution logic from arbitrary locations.
@@ -26784,7 +26886,7 @@ var ts;
      */
     /* @internal */
     function resolveJSModule(moduleName, initialDir, host) {
-        var _a = tryResolveJSModuleWorker(moduleName, initialDir, host), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
+        var _a = tryResolveJSModuleWorker(".ts" /* Ts */, moduleName, initialDir, host), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
         if (!resolvedModule) {
             throw new Error("Could not resolve JS module '" + moduleName + "' starting at '" + initialDir + "'. Looked in: " + failedLookupLocations.join(", "));
         }
@@ -26793,7 +26895,7 @@ var ts;
     ts.resolveJSModule = resolveJSModule;
     /* @internal */
     function tryResolveJSModule(moduleName, initialDir, host) {
-        var resolvedModule = tryResolveJSModuleWorker(moduleName, initialDir, host).resolvedModule;
+        var resolvedModule = tryResolveJSModuleWorker(".ts" /* Ts */, moduleName, initialDir, host).resolvedModule;
         return resolvedModule && resolvedModule.resolvedFileName;
     }
     ts.tryResolveJSModule = tryResolveJSModule;
@@ -26801,14 +26903,14 @@ var ts;
     var tsExtensions = [Extensions.TypeScript, Extensions.JavaScript];
     var tsPlusJsonExtensions = tsExtensions.concat([Extensions.Json]);
     var tsconfigExtensions = [Extensions.TSConfig];
-    function tryResolveJSModuleWorker(moduleName, initialDir, host) {
-        return nodeModuleNameResolverWorker(moduleName, initialDir, { moduleResolution: ts.ModuleResolutionKind.NodeJs, allowJs: true }, host, /*cache*/ undefined, jsOnlyExtensions, /*redirectedReferences*/ undefined);
+    function tryResolveJSModuleWorker(parentFileExtension, moduleName, initialDir, host) {
+        return nodeModuleNameResolverWorker(parentFileExtension, moduleName, initialDir, { moduleResolution: ts.ModuleResolutionKind.NodeJs, allowJs: true }, host, /*cache*/ undefined, jsOnlyExtensions, /*redirectedReferences*/ undefined);
     }
-    function nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference, lookupConfig) {
-        return nodeModuleNameResolverWorker(moduleName, ts.getDirectoryPath(containingFile), compilerOptions, host, cache, lookupConfig ? tsconfigExtensions : (compilerOptions.resolveJsonModule ? tsPlusJsonExtensions : tsExtensions), redirectedReference);
+    function nodeModuleNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference, lookupConfig) {
+        return nodeModuleNameResolverWorker(parentFileExtension, moduleName, ts.getDirectoryPath(containingFile), compilerOptions, host, cache, lookupConfig ? tsconfigExtensions : (compilerOptions.resolveJsonModule ? tsPlusJsonExtensions : tsExtensions), redirectedReference);
     }
     ts.nodeModuleNameResolver = nodeModuleNameResolver;
-    function nodeModuleNameResolverWorker(moduleName, containingDirectory, compilerOptions, host, cache, extensions, redirectedReference) {
+    function nodeModuleNameResolverWorker(parentFileExtension, moduleName, containingDirectory, compilerOptions, host, cache, extensions, redirectedReference) {
         var traceEnabled = isTraceEnabled(compilerOptions, host);
         var failedLookupLocations = [];
         var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations };
@@ -26819,8 +26921,8 @@ var ts;
         }
         return { resolvedModule: undefined, failedLookupLocations: failedLookupLocations };
         function tryResolve(extensions) {
-            var loader = function (extensions, candidate, onlyRecordFailures, state) { return nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ true); };
-            var resolved = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loader, state);
+            var loader = function (parentFileExtension, extensions, candidate, onlyRecordFailures, state) { return nodeLoadModuleByRelativeName(parentFileExtension, extensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ true); };
+            var resolved = tryLoadModuleUsingOptionalResolutionSettings(parentFileExtension, extensions, moduleName, containingDirectory, loader, state);
             if (resolved) {
                 return toSearchResult({ resolved: resolved, isExternalLibraryImport: pathContainsNodeModules(resolved.path) });
             }
@@ -26828,7 +26930,7 @@ var ts;
                 if (traceEnabled) {
                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);
                 }
-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
+                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(parentFileExtension, extensions, moduleName, containingDirectory, state, cache, redirectedReference);
                 if (!resolved_1)
                     return undefined;
                 var resolvedValue = resolved_1.value;
@@ -26842,7 +26944,7 @@ var ts;
             }
             else {
                 var _a = ts.normalizePathAndParts(ts.combinePaths(containingDirectory, moduleName)), candidate = _a.path, parts = _a.parts;
-                var resolved_2 = nodeLoadModuleByRelativeName(extensions, candidate, /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true);
+                var resolved_2 = nodeLoadModuleByRelativeName(parentFileExtension, extensions, candidate, /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true);
                 // Treat explicit "node_modules" import as an external library import.
                 return resolved_2 && toSearchResult({ resolved: resolved_2, isExternalLibraryImport: ts.contains(parts, "node_modules") });
             }
@@ -26859,7 +26961,7 @@ var ts;
         ts.Debug.assert(host.fileExists(real), path + " linked to nonexistent file " + real); // tslint:disable-line
         return real;
     }
-    function nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
+    function nodeLoadModuleByRelativeName(parentFileExtension, extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
         if (state.traceEnabled) {
             trace(state.host, ts.Diagnostics.Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1, candidate, Extensions[extensions]);
         }
@@ -26873,10 +26975,10 @@ var ts;
                     onlyRecordFailures = true;
                 }
             }
-            var resolvedFromFile = loadModuleFromFile(extensions, candidate, onlyRecordFailures, state);
+            var resolvedFromFile = loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state);
             if (resolvedFromFile) {
                 var nm = considerPackageJson ? parseNodeModuleFromPath(resolvedFromFile) : undefined;
-                var packageInfo = nm && getPackageJsonInfo(nm.packageDirectory, nm.subModuleName, /*onlyRecordFailures*/ false, state);
+                var packageInfo = nm && getPackageJsonInfo(parentFileExtension, nm.packageDirectory, nm.subModuleName, /*onlyRecordFailures*/ false, state);
                 var packageId = packageInfo && packageInfo.packageId;
                 return withPackageId(packageId, resolvedFromFile);
             }
@@ -26890,7 +26992,7 @@ var ts;
                 onlyRecordFailures = true;
             }
         }
-        return loadNodeModuleFromDirectory(extensions, candidate, onlyRecordFailures, state, considerPackageJson);
+        return loadNodeModuleFromDirectory(parentFileExtension, extensions, candidate, onlyRecordFailures, state, considerPackageJson);
     }
     /*@internal*/
     ts.nodeModulesPathPart = "/node_modules/";
@@ -26941,20 +27043,20 @@ var ts;
         }
         return path + "/index.d.ts";
     }
-    function loadModuleFromFileNoPackageId(extensions, candidate, onlyRecordFailures, state) {
-        return noPackageId(loadModuleFromFile(extensions, candidate, onlyRecordFailures, state));
+    function loadModuleFromFileNoPackageId(parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
+        return noPackageId(loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state));
     }
     /**
      * @param {boolean} onlyRecordFailures - if true then function won't try to actually load files but instead record all attempts as failures. This flag is necessary
      * in cases when we know upfront that all load attempts will fail (because containing folder does not exists) however we still need to record all failed lookup locations.
      */
-    function loadModuleFromFile(extensions, candidate, onlyRecordFailures, state) {
+    function loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
         if (extensions === Extensions.Json || extensions === Extensions.TSConfig) {
             var extensionLess = ts.tryRemoveExtension(candidate, ".json" /* Json */);
-            return (extensionLess === undefined && extensions === Extensions.Json) ? undefined : tryAddingExtensions(extensionLess || candidate, extensions, onlyRecordFailures, state);
+            return (extensionLess === undefined && extensions === Extensions.Json) ? undefined : tryAddingExtensions(parentFileExtension, extensionLess || candidate, extensions, onlyRecordFailures, state);
         }
         // First, try adding an extension. An import of "foo" could be matched by a file "foo.ts", or "foo.js" by "foo.js.ts"
-        var resolvedByAddingExtension = tryAddingExtensions(candidate, extensions, onlyRecordFailures, state);
+        var resolvedByAddingExtension = tryAddingExtensions(parentFileExtension, candidate, extensions, onlyRecordFailures, state);
         if (resolvedByAddingExtension) {
             return resolvedByAddingExtension;
         }
@@ -26966,11 +27068,11 @@ var ts;
                 var extension = candidate.substring(extensionless.length);
                 trace(state.host, ts.Diagnostics.File_name_0_has_a_1_extension_stripping_it, candidate, extension);
             }
-            return tryAddingExtensions(extensionless, extensions, onlyRecordFailures, state);
+            return tryAddingExtensions(parentFileExtension, extensionless, extensions, onlyRecordFailures, state);
         }
     }
     /** Try to return an existing file that adds one of the `extensions` to `candidate`. */
-    function tryAddingExtensions(candidate, extensions, onlyRecordFailures, state) {
+    function tryAddingExtensions(parentFileExtension, candidate, extensions, onlyRecordFailures, state) {
         if (!onlyRecordFailures) {
             // check if containing folder exists - if it doesn't then just record failures for all supported extensions without disk probing
             var directory = ts.getDirectoryPath(candidate);
@@ -26978,16 +27080,212 @@ var ts;
                 onlyRecordFailures = !ts.directoryProbablyExists(directory, state.host);
             }
         }
-        switch (extensions) {
-            case Extensions.DtsOnly:
-                return tryExtension(".d.ts" /* Dts */);
-            case Extensions.TypeScript:
-                return tryExtension(".ts" /* Ts */) || tryExtension(".tsx" /* Tsx */) || tryExtension(".d.ts" /* Dts */);
-            case Extensions.JavaScript:
-                return tryExtension(".js" /* Js */) || tryExtension(".jsx" /* Jsx */);
-            case Extensions.TSConfig:
-            case Extensions.Json:
-                return tryExtension(".json" /* Json */);
+        switch (parentFileExtension) {
+            case ".web.ts" /* WebTs */:
+            case ".web.tsx" /* WebTsx */:
+            case ".web.js" /* WebJs */:
+            case ".web.jsx" /* WebJsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".web.json" /* WebJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".web.js" /* WebJs */) ||
+                            tryExtension(".web.jsx" /* WebJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".web.ts" /* WebTs */) ||
+                            tryExtension(".web.tsx" /* WebTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".native.js" /* NativeJs */:
+            case ".native.jsx" /* NativeJsx */:
+            case ".native.ts" /* NativeTs */:
+            case ".native.tsx" /* NativeTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".json" /* Json */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".ios.json" /* IosJson */) ||
+                            tryExtension(".android.json" /* AndroidJson */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".ios.js" /* IosJs */) ||
+                            tryExtension(".ios.jsx" /* IosJsx */) ||
+                            tryExtension(".android.js" /* AndroidJs */) ||
+                            tryExtension(".android.jsx" /* AndroidJsx */));
+                    }
+                    default: {
+                        return (tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ios.ts" /* IosTs */) ||
+                            tryExtension(".ios.tsx" /* IosTsx */) ||
+                            tryExtension(".android.ts" /* AndroidTs */) ||
+                            tryExtension(".android.tsx" /* AndroidTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".ios.js" /* IosJs */:
+            case ".ios.jsx" /* IosJsx */:
+            case ".ios.ts" /* IosTs */:
+            case ".ios.tsx" /* IosTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".ios.json" /* IosJson */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".ios.js" /* IosJs */) ||
+                            tryExtension(".ios.jsx" /* IosJsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".ios.ts" /* IosTs */) ||
+                            tryExtension(".ios.tsx" /* IosTsx */) ||
+                            tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".android.js" /* AndroidJs */:
+            case ".android.jsx" /* AndroidJsx */:
+            case ".android.ts" /* AndroidTs */:
+            case ".android.tsx" /* AndroidTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".android.json" /* AndroidJson */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".android.js" /* AndroidJs */) ||
+                            tryExtension(".android.jsx" /* AndroidJsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".android.ts" /* AndroidTs */) ||
+                            tryExtension(".android.tsx" /* AndroidTsx */) ||
+                            tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".node.js" /* NodeJs */:
+            case ".node.jsx" /* NodeJsx */:
+            case ".node.ts" /* NodeTs */:
+            case ".node.tsx" /* NodeTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".node.json" /* NodeJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".node.js" /* NodeJs */) ||
+                            tryExtension(".node.jsx" /* NodeJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".node.ts" /* NodeTs */) ||
+                            tryExtension(".node.tsx" /* NodeTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            default: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".json" /* Json */) ||
+                            tryExtension(".node.json" /* NodeJson */) ||
+                            tryExtension(".web.json" /* WebJson */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".ios.json" /* IosJson */) ||
+                            tryExtension(".android.json" /* AndroidJson */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */) ||
+                            tryExtension(".node.js" /* NodeJs */) ||
+                            tryExtension(".node.jsx" /* NodeJsx */) ||
+                            tryExtension(".web.js" /* WebJs */) ||
+                            tryExtension(".web.jsx" /* WebJsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".ios.js" /* IosJs */) ||
+                            tryExtension(".ios.jsx" /* IosJsx */) ||
+                            tryExtension(".android.js" /* AndroidJs */) ||
+                            tryExtension(".android.jsx" /* AndroidJsx */));
+                    }
+                    default: {
+                        return (tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */) ||
+                            tryExtension(".node.ts" /* NodeTs */) ||
+                            tryExtension(".node.tsx" /* NodeTsx */) ||
+                            tryExtension(".web.ts" /* WebTs */) ||
+                            tryExtension(".web.tsx" /* WebTsx */) ||
+                            tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ios.ts" /* IosTs */) ||
+                            tryExtension(".ios.tsx" /* IosTsx */) ||
+                            tryExtension(".android.ts" /* AndroidTs */) ||
+                            tryExtension(".android.tsx" /* AndroidTsx */));
+                    }
+                }
+            }
         }
         function tryExtension(ext) {
             var path = tryFile(candidate + ext, onlyRecordFailures, state);
@@ -27012,15 +27310,15 @@ var ts;
         state.failedLookupLocations.push(fileName);
         return undefined;
     }
-    function loadNodeModuleFromDirectory(extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
+    function loadNodeModuleFromDirectory(parentFileExtension, extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
         if (considerPackageJson === void 0) { considerPackageJson = true; }
-        var packageInfo = considerPackageJson ? getPackageJsonInfo(candidate, "", onlyRecordFailures, state) : undefined;
+        var packageInfo = considerPackageJson ? getPackageJsonInfo(parentFileExtension, candidate, "", onlyRecordFailures, state) : undefined;
         var packageId = packageInfo && packageInfo.packageId;
         var packageJsonContent = packageInfo && packageInfo.packageJsonContent;
         var versionPaths = packageJsonContent && readPackageJsonTypesVersionPaths(packageJsonContent, state);
-        return withPackageId(packageId, loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths));
+        return withPackageId(packageId, loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths));
     }
-    function getPackageJsonInfo(packageDirectory, subModuleName, onlyRecordFailures, state) {
+    function getPackageJsonInfo(parentFileExtension, packageDirectory, subModuleName, onlyRecordFailures, state) {
         var host = state.host, traceEnabled = state.traceEnabled;
         var directoryExists = !onlyRecordFailures && ts.directoryProbablyExists(packageDirectory, host);
         var packageJsonPath = ts.combinePaths(packageDirectory, "package.json");
@@ -27032,7 +27330,34 @@ var ts;
                     subModuleName = addExtensionAndIndex(path.substring(packageDirectory.length + 1));
                 }
                 else {
-                    var jsPath = readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                    var jsPath = void 0;
+                    switch (parentFileExtension) {
+                        case ".android.js" /* AndroidJs */:
+                        case ".ios.js" /* IosJs */:
+                        case ".native.js" /* NativeJs */:
+                        case ".android.jsx" /* AndroidJsx */:
+                        case ".ios.jsx" /* IosJsx */:
+                        case ".native.jsx" /* NativeJsx */:
+                        case ".android.ts" /* AndroidTs */:
+                        case ".ios.ts" /* IosTs */:
+                        case ".native.ts" /* NativeTs */:
+                        case ".android.tsx" /* AndroidTsx */:
+                        case ".ios.tsx" /* IosTsx */:
+                        case ".native.tsx" /* NativeTsx */: {
+                            jsPath = readPackageJsonReactNativeField(packageJsonContent, packageDirectory, state) || readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                            break;
+                        }
+                        case ".web.js" /* WebJs */:
+                        case ".web.jsx" /* WebJsx */:
+                        case ".web.ts" /* WebTs */:
+                        case ".web.tsx" /* WebTsx */: {
+                            jsPath = readPackageJsonBrowserField(packageJsonContent, packageDirectory, state) || readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                            break;
+                        }
+                        default: {
+                            jsPath = readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                        }
+                    }
                     if (typeof jsPath === "string" && jsPath.length > packageDirectory.length) {
                         var potentialSubModule_1 = jsPath.substring(packageDirectory.length + 1);
                         subModuleName = (ts.forEach(ts.supportedJSExtensions, function (extension) {
@@ -27049,7 +27374,7 @@ var ts;
             }
             var versionPaths = readPackageJsonTypesVersionPaths(packageJsonContent, state);
             var packageId = typeof packageJsonContent.name === "string" && typeof packageJsonContent.version === "string"
-                ? { name: packageJsonContent.name, subModuleName: subModuleName, version: packageJsonContent.version }
+                ? { name: packageJsonContent.name + "|" + parentFileExtension, subModuleName: subModuleName, version: packageJsonContent.version }
                 : undefined;
             if (traceEnabled) {
                 if (packageId) {
@@ -27069,18 +27394,79 @@ var ts;
             state.failedLookupLocations.push(packageJsonPath);
         }
     }
-    function loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, jsonContent, versionPaths) {
+    function loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, onlyRecordFailures, state, jsonContent, versionPaths) {
         var packageFile;
         if (jsonContent) {
             switch (extensions) {
                 case Extensions.JavaScript:
-                case Extensions.Json:
-                    packageFile = readPackageJsonMainField(jsonContent, candidate, state);
+                case Extensions.Json: {
+                    switch (parentFileExtension) {
+                        case ".android.js" /* AndroidJs */:
+                        case ".ios.js" /* IosJs */:
+                        case ".native.js" /* NativeJs */:
+                        case ".android.jsx" /* AndroidJsx */:
+                        case ".ios.jsx" /* IosJsx */:
+                        case ".native.jsx" /* NativeJsx */:
+                        case ".android.ts" /* AndroidTs */:
+                        case ".ios.ts" /* IosTs */:
+                        case ".native.ts" /* NativeTs */:
+                        case ".android.tsx" /* AndroidTsx */:
+                        case ".ios.tsx" /* IosTsx */:
+                        case ".native.tsx" /* NativeTsx */: {
+                            packageFile = readPackageJsonReactNativeField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        case ".web.js" /* WebJs */:
+                        case ".web.jsx" /* WebJsx */:
+                        case ".web.ts" /* WebTs */:
+                        case ".web.tsx" /* WebTsx */: {
+                            packageFile = readPackageJsonBrowserField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        default: {
+                            packageFile = readPackageJsonMainField(jsonContent, candidate, state);
+                        }
+                    }
                     break;
-                case Extensions.TypeScript:
-                    // When resolving typescript modules, try resolving using main field as well
-                    packageFile = readPackageJsonTypesFields(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                }
+                case Extensions.TypeScript: {
+                    switch (parentFileExtension) {
+                        case ".android.js" /* AndroidJs */:
+                        case ".ios.js" /* IosJs */:
+                        case ".native.js" /* NativeJs */:
+                        case ".android.jsx" /* AndroidJsx */:
+                        case ".ios.jsx" /* IosJsx */:
+                        case ".native.jsx" /* NativeJsx */:
+                        case ".android.ts" /* AndroidTs */:
+                        case ".ios.ts" /* IosTs */:
+                        case ".native.ts" /* NativeTs */:
+                        case ".android.tsx" /* AndroidTsx */:
+                        case ".ios.tsx" /* IosTsx */:
+                        case ".native.tsx" /* NativeTsx */: {
+                            packageFile = readPackageJsonReactNativeField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        case ".web.js" /* WebJs */:
+                        case ".web.jsx" /* WebJsx */:
+                        case ".web.ts" /* WebTs */:
+                        case ".web.tsx" /* WebTsx */: {
+                            packageFile = readPackageJsonBrowserField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        case ".node.js" /* NodeJs */:
+                        case ".node.jsx" /* NodeJsx */:
+                        case ".node.ts" /* NodeTs */:
+                        case ".node.tsx" /* NodeTsx */: {
+                            packageFile = readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        default: {
+                            // When resolving typescript modules, try resolving using main field as well
+                            packageFile = readPackageJsonTypesFields(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                        }
+                    }
                     break;
+                }
                 case Extensions.DtsOnly:
                     packageFile = readPackageJsonTypesFields(jsonContent, candidate, state);
                     break;
@@ -27091,7 +27477,7 @@ var ts;
                     return ts.Debug.assertNever(extensions);
             }
         }
-        var loader = function (extensions, candidate, onlyRecordFailures, state) {
+        var loader = function (parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
             var fromFile = tryFile(candidate, onlyRecordFailures, state);
             if (fromFile) {
                 var resolved = resolvedIfExtensionMatches(extensions, fromFile);
@@ -27105,7 +27491,7 @@ var ts;
             // Even if extensions is DtsOnly, we can still look up a .ts file as a result of package.json "types"
             var nextExtensions = extensions === Extensions.DtsOnly ? Extensions.TypeScript : extensions;
             // Don't do package.json lookup recursively, because Node.js' package lookup doesn't.
-            return nodeLoadModuleByRelativeName(nextExtensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ false);
+            return nodeLoadModuleByRelativeName(parentFileExtension, nextExtensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ false);
         };
         var onlyRecordFailuresForPackageFile = packageFile ? !ts.directoryProbablyExists(ts.getDirectoryPath(packageFile), state.host) : undefined;
         var onlyRecordFailuresForIndex = onlyRecordFailures || !ts.directoryProbablyExists(candidate, state.host);
@@ -27115,16 +27501,16 @@ var ts;
             if (state.traceEnabled) {
                 trace(state.host, ts.Diagnostics.package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2, versionPaths.version, ts.version, moduleName);
             }
-            var result = tryLoadModuleUsingPaths(extensions, moduleName, candidate, versionPaths.paths, loader, onlyRecordFailuresForPackageFile || onlyRecordFailuresForIndex, state);
+            var result = tryLoadModuleUsingPaths(parentFileExtension, extensions, moduleName, candidate, versionPaths.paths, loader, onlyRecordFailuresForPackageFile || onlyRecordFailuresForIndex, state);
             if (result) {
                 return removeIgnoredPackageId(result.value);
             }
         }
         // It won't have a `packageId` set, because we disabled `considerPackageJson`.
-        var packageFileResult = packageFile && removeIgnoredPackageId(loader(extensions, packageFile, onlyRecordFailuresForPackageFile, state));
+        var packageFileResult = packageFile && removeIgnoredPackageId(loader(parentFileExtension, extensions, packageFile, onlyRecordFailuresForPackageFile, state));
         if (packageFileResult)
             return packageFileResult;
-        return loadModuleFromFile(extensions, indexPath, onlyRecordFailuresForIndex, state);
+        return loadModuleFromFile(parentFileExtension, extensions, indexPath, onlyRecordFailuresForIndex, state);
     }
     /** Resolve from an arbitrarily specified file. Return `undefined` if it has an unsupported extension. */
     function resolvedIfExtensionMatches(extensions, path) {
@@ -27135,12 +27521,40 @@ var ts;
     function extensionIsOk(extensions, extension) {
         switch (extensions) {
             case Extensions.JavaScript:
-                return extension === ".js" /* Js */ || extension === ".jsx" /* Jsx */;
+                return (extension === ".js" /* Js */ ||
+                    extension === ".jsx" /* Jsx */ ||
+                    extension === ".node.js" /* NodeJs */ ||
+                    extension === ".node.jsx" /* NodeJsx */ ||
+                    extension === ".web.js" /* WebJs */ ||
+                    extension === ".web.jsx" /* WebJsx */ ||
+                    extension === ".native.js" /* NativeJs */ ||
+                    extension === ".native.jsx" /* NativeJsx */ ||
+                    extension === ".ios.js" /* IosJs */ ||
+                    extension === ".ios.jsx" /* IosJsx */ ||
+                    extension === ".android.js" /* AndroidJs */ ||
+                    extension === ".android.jsx" /* AndroidJsx */);
             case Extensions.TSConfig:
             case Extensions.Json:
-                return extension === ".json" /* Json */;
+                return (extension === ".json" /* Json */ ||
+                    extension === ".node.json" /* NodeJson */ ||
+                    extension === ".web.json" /* WebJson */ ||
+                    extension === ".native.json" /* NativeJson */ ||
+                    extension === ".ios.json" /* IosJson */ ||
+                    extension === ".android.json" /* AndroidJson */);
             case Extensions.TypeScript:
-                return extension === ".ts" /* Ts */ || extension === ".tsx" /* Tsx */ || extension === ".d.ts" /* Dts */;
+                return (extension === ".ts" /* Ts */ ||
+                    extension === ".tsx" /* Tsx */ ||
+                    extension === ".d.ts" /* Dts */ ||
+                    extension === ".node.ts" /* NodeTs */ ||
+                    extension === ".node.tsx" /* NodeTsx */ ||
+                    extension === ".web.ts" /* WebTs */ ||
+                    extension === ".web.tsx" /* WebTsx */ ||
+                    extension === ".native.ts" /* NativeTs */ ||
+                    extension === ".native.tsx" /* NativeTsx */ ||
+                    extension === ".ios.ts" /* IosTs */ ||
+                    extension === ".ios.tsx" /* IosTsx */ ||
+                    extension === ".android.ts" /* AndroidTs */ ||
+                    extension === ".android.tsx" /* AndroidTsx */);
             case Extensions.DtsOnly:
                 return extension === ".d.ts" /* Dts */;
         }
@@ -27154,32 +27568,33 @@ var ts;
         return idx === -1 ? { packageName: moduleName, rest: "" } : { packageName: moduleName.slice(0, idx), rest: moduleName.slice(idx + 1) };
     }
     ts.parsePackageName = parsePackageName;
-    function loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, directory, state, cache, redirectedReference) {
-        return loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName, directory, state, /*typesScopeOnly*/ false, cache, redirectedReference);
+    function loadModuleFromNearestNodeModulesDirectory(parentFileExtension, extensions, moduleName, directory, state, cache, redirectedReference) {
+        return loadModuleFromNearestNodeModulesDirectoryWorker(parentFileExtension, extensions, moduleName, directory, state, /*typesScopeOnly*/ false, cache, redirectedReference);
     }
     function loadModuleFromNearestNodeModulesDirectoryTypesScope(moduleName, directory, state) {
         // Extensions parameter here doesn't actually matter, because typesOnly ensures we're just doing @types lookup, which is always DtsOnly.
-        return loadModuleFromNearestNodeModulesDirectoryWorker(Extensions.DtsOnly, moduleName, directory, state, /*typesScopeOnly*/ true, /*cache*/ undefined, /*redirectedReference*/ undefined);
+        return loadModuleFromNearestNodeModulesDirectoryWorker(".ts" /* Ts */, Extensions.DtsOnly, moduleName, directory, state, /*typesScopeOnly*/ true, /*cache*/ undefined, /*redirectedReference*/ undefined);
     }
-    function loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
-        var perModuleNameCache = cache && cache.getOrCreateCacheForModuleName(moduleName, redirectedReference);
+    function loadModuleFromNearestNodeModulesDirectoryWorker(parentFileExtension, extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
+        var moduleNameKey = moduleName + "|" + parentFileExtension;
+        var perModuleNameCache = cache && cache.getOrCreateCacheForModuleName(moduleNameKey, redirectedReference);
         return ts.forEachAncestorDirectory(ts.normalizeSlashes(directory), function (ancestorDirectory) {
             if (ts.getBaseFileName(ancestorDirectory) !== "node_modules") {
                 var resolutionFromCache = tryFindNonRelativeModuleNameInCache(perModuleNameCache, moduleName, ancestorDirectory, state);
                 if (resolutionFromCache) {
                     return resolutionFromCache;
                 }
-                return toSearchResult(loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, ancestorDirectory, state, typesScopeOnly));
+                return toSearchResult(loadModuleFromImmediateNodeModulesDirectory(parentFileExtension, extensions, moduleName, ancestorDirectory, state, typesScopeOnly));
             }
         });
     }
-    function loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, directory, state, typesScopeOnly) {
+    function loadModuleFromImmediateNodeModulesDirectory(parentFileExtension, extensions, moduleName, directory, state, typesScopeOnly) {
         var nodeModulesFolder = ts.combinePaths(directory, "node_modules");
         var nodeModulesFolderExists = ts.directoryProbablyExists(nodeModulesFolder, state.host);
         if (!nodeModulesFolderExists && state.traceEnabled) {
             trace(state.host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, nodeModulesFolder);
         }
-        var packageResult = typesScopeOnly ? undefined : loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesFolder, nodeModulesFolderExists, state);
+        var packageResult = typesScopeOnly ? undefined : loadModuleFromSpecificNodeModulesDirectory(parentFileExtension, extensions, moduleName, nodeModulesFolder, nodeModulesFolderExists, state);
         if (packageResult) {
             return packageResult;
         }
@@ -27192,35 +27607,35 @@ var ts;
                 }
                 nodeModulesAtTypesExists = false;
             }
-            return loadModuleFromSpecificNodeModulesDirectory(Extensions.DtsOnly, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes_1, nodeModulesAtTypesExists, state);
+            return loadModuleFromSpecificNodeModulesDirectory(parentFileExtension, Extensions.DtsOnly, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes_1, nodeModulesAtTypesExists, state);
         }
     }
-    function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state) {
+    function loadModuleFromSpecificNodeModulesDirectory(parentFileExtension, extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state) {
         var candidate = ts.normalizePath(ts.combinePaths(nodeModulesDirectory, moduleName));
         // First look for a nested package.json, as in `node_modules/foo/bar/package.json`.
         var packageJsonContent;
         var packageId;
         var versionPaths;
-        var packageInfo = getPackageJsonInfo(candidate, "", !nodeModulesDirectoryExists, state);
+        var packageInfo = getPackageJsonInfo(parentFileExtension, candidate, "", !nodeModulesDirectoryExists, state);
         if (packageInfo) {
             (packageJsonContent = packageInfo.packageJsonContent, packageId = packageInfo.packageId, versionPaths = packageInfo.versionPaths);
-            var fromFile = loadModuleFromFile(extensions, candidate, !nodeModulesDirectoryExists, state);
+            var fromFile = loadModuleFromFile(parentFileExtension, extensions, candidate, !nodeModulesDirectoryExists, state);
             if (fromFile) {
                 return noPackageId(fromFile);
             }
-            var fromDirectory = loadNodeModuleFromDirectoryWorker(extensions, candidate, !nodeModulesDirectoryExists, state, packageJsonContent, versionPaths);
+            var fromDirectory = loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, !nodeModulesDirectoryExists, state, packageJsonContent, versionPaths);
             return withPackageId(packageId, fromDirectory);
         }
-        var loader = function (extensions, candidate, onlyRecordFailures, state) {
-            var pathAndExtension = loadModuleFromFile(extensions, candidate, onlyRecordFailures, state) ||
-                loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths);
+        var loader = function (parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
+            var pathAndExtension = loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state) ||
+                loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths);
             return withPackageId(packageId, pathAndExtension);
         };
         var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;
         if (rest !== "") { // If "rest" is empty, we just did this search above.
             var packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
             // Don't use a "types" or "main" from here because we're not loading the root, but a subdirectory -- just here for the packageId and path mappings.
-            var packageInfo_1 = getPackageJsonInfo(packageDirectory, rest, !nodeModulesDirectoryExists, state);
+            var packageInfo_1 = getPackageJsonInfo(parentFileExtension, packageDirectory, rest, !nodeModulesDirectoryExists, state);
             if (packageInfo_1)
                 (packageId = packageInfo_1.packageId, versionPaths = packageInfo_1.versionPaths);
             if (versionPaths) {
@@ -27228,15 +27643,15 @@ var ts;
                     trace(state.host, ts.Diagnostics.package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2, versionPaths.version, ts.version, rest);
                 }
                 var packageDirectoryExists = nodeModulesDirectoryExists && ts.directoryProbablyExists(packageDirectory, state.host);
-                var fromPaths = tryLoadModuleUsingPaths(extensions, rest, packageDirectory, versionPaths.paths, loader, !packageDirectoryExists, state);
+                var fromPaths = tryLoadModuleUsingPaths(parentFileExtension, extensions, rest, packageDirectory, versionPaths.paths, loader, !packageDirectoryExists, state);
                 if (fromPaths) {
                     return fromPaths.value;
                 }
             }
         }
-        return loader(extensions, candidate, !nodeModulesDirectoryExists, state);
+        return loader(parentFileExtension, extensions, candidate, !nodeModulesDirectoryExists, state);
     }
-    function tryLoadModuleUsingPaths(extensions, moduleName, baseDirectory, paths, loader, onlyRecordFailures, state) {
+    function tryLoadModuleUsingPaths(parentFileExtension, extensions, moduleName, baseDirectory, paths, loader, onlyRecordFailures, state) {
         var matchedPattern = ts.matchPatternOrExact(ts.getOwnKeys(paths), moduleName);
         if (matchedPattern) {
             var matchedStar_1 = ts.isString(matchedPattern) ? undefined : ts.matchedText(matchedPattern, moduleName);
@@ -27258,7 +27673,7 @@ var ts;
                         return noPackageId({ path: path_1, ext: extension });
                     }
                 }
-                return loader(extensions, candidate, onlyRecordFailures || !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
+                return loader(parentFileExtension, extensions, candidate, onlyRecordFailures || !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
             });
             return { value: resolved };
         }
@@ -27316,7 +27731,7 @@ var ts;
             return { value: result.resolvedModule && { path: result.resolvedModule.resolvedFileName, originalPath: result.resolvedModule.originalPath || true, extension: result.resolvedModule.extension, packageId: result.resolvedModule.packageId } };
         }
     }
-    function classicNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
+    function classicNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
         var traceEnabled = isTraceEnabled(compilerOptions, host);
         var failedLookupLocations = [];
         var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations };
@@ -27325,7 +27740,7 @@ var ts;
         // No originalPath because classic resolution doesn't resolve realPath
         return createResolvedModuleWithFailedLookupLocations(resolved && resolved.value, /*isExternalLibraryImport*/ false, failedLookupLocations);
         function tryResolve(extensions) {
-            var resolvedUsingSettings = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loadModuleFromFileNoPackageId, state);
+            var resolvedUsingSettings = tryLoadModuleUsingOptionalResolutionSettings(parentFileExtension, extensions, moduleName, containingDirectory, loadModuleFromFileNoPackageId, state);
             if (resolvedUsingSettings) {
                 return { value: resolvedUsingSettings };
             }
@@ -27338,7 +27753,7 @@ var ts;
                         return resolutionFromCache;
                     }
                     var searchName = ts.normalizePath(ts.combinePaths(directory, moduleName));
-                    return toSearchResult(loadModuleFromFileNoPackageId(extensions, searchName, /*onlyRecordFailures*/ false, state));
+                    return toSearchResult(loadModuleFromFileNoPackageId(parentFileExtension, extensions, searchName, /*onlyRecordFailures*/ false, state));
                 });
                 if (resolved_3) {
                     return resolved_3;
@@ -27350,7 +27765,7 @@ var ts;
             }
             else {
                 var candidate = ts.normalizePath(ts.combinePaths(containingDirectory, moduleName));
-                return toSearchResult(loadModuleFromFileNoPackageId(extensions, candidate, /*onlyRecordFailures*/ false, state));
+                return toSearchResult(loadModuleFromFileNoPackageId(parentFileExtension, extensions, candidate, /*onlyRecordFailures*/ false, state));
             }
         }
     }
@@ -27360,14 +27775,15 @@ var ts;
      * This is the minumum code needed to expose that functionality; the rest is in LSHost.
      */
     /* @internal */
-    function loadModuleFromGlobalCache(moduleName, projectName, compilerOptions, host, globalCache) {
+    function loadModuleFromGlobalCache(moduleName, containingFile, projectName, compilerOptions, host, globalCache) {
         var traceEnabled = isTraceEnabled(compilerOptions, host);
         if (traceEnabled) {
             trace(host, ts.Diagnostics.Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2, projectName, moduleName, globalCache);
         }
         var failedLookupLocations = [];
         var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations };
-        var resolved = loadModuleFromImmediateNodeModulesDirectory(Extensions.DtsOnly, moduleName, globalCache, state, /*typesScopeOnly*/ false);
+        var parentFileContext = ts.getFileExtension(containingFile);
+        var resolved = loadModuleFromImmediateNodeModulesDirectory(parentFileContext, Extensions.DtsOnly, moduleName, globalCache, state, /*typesScopeOnly*/ false);
         return createResolvedModuleWithFailedLookupLocations(resolved, /*isExternalLibraryImport*/ true, failedLookupLocations);
     }
     ts.loadModuleFromGlobalCache = loadModuleFromGlobalCache;
@@ -90434,16 +90850,41 @@ var ts;
         var extension = _a.extension;
         switch (extension) {
             case ".ts" /* Ts */:
+            case ".node.ts" /* NodeTs */:
+            case ".web.ts" /* WebTs */:
+            case ".native.ts" /* NativeTs */:
+            case ".ios.ts" /* IosTs */:
+            case ".android.ts" /* AndroidTs */:
             case ".d.ts" /* Dts */:
                 // These are always allowed.
                 return undefined;
             case ".tsx" /* Tsx */:
+            case ".node.tsx" /* NodeTsx */:
+            case ".web.tsx" /* WebTsx */:
+            case ".native.tsx" /* NativeTsx */:
+            case ".ios.tsx" /* IosTsx */:
+            case ".android.tsx" /* AndroidTsx */:
                 return needJsx();
             case ".jsx" /* Jsx */:
+            case ".node.jsx" /* NodeJsx */:
+            case ".web.jsx" /* WebJsx */:
+            case ".native.jsx" /* NativeJsx */:
+            case ".ios.jsx" /* IosJsx */:
+            case ".android.jsx" /* AndroidJsx */:
                 return needJsx() || needAllowJs();
             case ".js" /* Js */:
+            case ".node.js" /* NodeJs */:
+            case ".web.js" /* WebJs */:
+            case ".native.js" /* NativeJs */:
+            case ".ios.js" /* IosJs */:
+            case ".android.js" /* AndroidJs */:
                 return needAllowJs();
             case ".json" /* Json */:
+            case ".node.json" /* NodeJson */:
+            case ".web.json" /* WebJson */:
+            case ".native.json" /* NativeJson */:
+            case ".ios.json" /* IosJson */:
+            case ".android.json" /* AndroidJson */:
                 return needResolveJsonModule();
         }
         function needJsx() {
@@ -91854,7 +92295,7 @@ var ts;
             if (globalCache !== undefined && !ts.isExternalModuleNameRelative(moduleName) && !(primaryResult.resolvedModule && ts.extensionIsTS(primaryResult.resolvedModule.extension))) {
                 // create different collection of failed lookup locations for second pass
                 // if it will fail and we've already found something during the first pass - we don't want to pollute its results
-                var _a = ts.loadModuleFromGlobalCache(moduleName, resolutionHost.projectName, compilerOptions, host, globalCache), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
+                var _a = ts.loadModuleFromGlobalCache(moduleName, containingFile, resolutionHost.projectName, compilerOptions, host, globalCache), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
                 if (resolvedModule) {
                     return { resolvedModule: resolvedModule, failedLookupLocations: ts.addRange(primaryResult.failedLookupLocations, failedLookupLocations) };
                 }
@@ -91864,7 +92305,9 @@ var ts;
         }
         function resolveNamesWithLocalCache(names, containingFile, redirectedReference, cache, perDirectoryCacheWithRedirects, loader, getResolutionWithResolvedFileName, shouldRetryResolution, reusedNames, logChanges) {
             var path = resolutionHost.toPath(containingFile);
-            var resolutionsInFile = cache.get(path) || cache.set(path, ts.createMap()).get(path);
+            var context = ts.getFileExtension(containingFile);
+            var pathKey = path + "|" + context;
+            var resolutionsInFile = cache.get(pathKey) || cache.set(pathKey, ts.createMap()).get(pathKey);
             var dirPath = ts.getDirectoryPath(path);
             var perDirectoryCache = perDirectoryCacheWithRedirects.getOrCreateMapOfCacheRedirects(redirectedReference);
             var perDirectoryResolution = perDirectoryCache.get(dirPath);
@@ -91884,22 +92327,23 @@ var ts;
             var seenNamesInFile = ts.createMap();
             for (var _i = 0, names_2 = names; _i < names_2.length; _i++) {
                 var name = names_2[_i];
-                var resolution = resolutionsInFile.get(name);
+                var nameKey = name + "|" + context;
+                var resolution = resolutionsInFile.get(nameKey);
                 // Resolution is valid if it is present and not invalidated
-                if (!seenNamesInFile.has(name) &&
+                if (!seenNamesInFile.has(nameKey) &&
                     allFilesHaveInvalidatedResolution || unmatchedRedirects || !resolution || resolution.isInvalidated ||
                     // If the name is unresolved import that was invalidated, recalculate
                     (hasInvalidatedNonRelativeUnresolvedImport && !ts.isExternalModuleNameRelative(name) && shouldRetryResolution(resolution))) {
                     var existingResolution = resolution;
-                    var resolutionInDirectory = perDirectoryResolution.get(name);
+                    var resolutionInDirectory = perDirectoryResolution.get(nameKey);
                     if (resolutionInDirectory) {
                         resolution = resolutionInDirectory;
                     }
                     else {
                         resolution = loader(name, containingFile, compilerOptions, resolutionHost, redirectedReference);
-                        perDirectoryResolution.set(name, resolution);
+                        perDirectoryResolution.set(nameKey, resolution);
                     }
-                    resolutionsInFile.set(name, resolution);
+                    resolutionsInFile.set(nameKey, resolution);
                     watchFailedLookupLocationsOfExternalModuleResolutions(name, resolution);
                     if (existingResolution) {
                         stopWatchFailedLookupLocationOfResolution(existingResolution);
@@ -91911,14 +92355,15 @@ var ts;
                     }
                 }
                 ts.Debug.assert(resolution !== undefined && !resolution.isInvalidated);
-                seenNamesInFile.set(name, true);
+                seenNamesInFile.set(nameKey, true);
                 resolvedModules.push(getResolutionWithResolvedFileName(resolution));
             }
             // Stop watching and remove the unused name
-            resolutionsInFile.forEach(function (resolution, name) {
-                if (!seenNamesInFile.has(name) && !ts.contains(reusedNames, name)) {
+            resolutionsInFile.forEach(function (resolution, nameKey) {
+                var name = nameKey.split('|')[0];
+                if (!seenNamesInFile.has(nameKey) && !ts.contains(reusedNames, name)) {
                     stopWatchFailedLookupLocationOfResolution(resolution);
-                    resolutionsInFile.delete(name);
+                    resolutionsInFile.delete(nameKey);
                 }
             });
             return resolvedModules;
@@ -92716,11 +93161,46 @@ var ts;
                 case ".ts" /* Ts */:
                 case ".d.ts" /* Dts */:
                     return ".js" /* Js */;
+                case ".node.ts" /* NodeTs */:
+                    return ".node.js" /* NodeJs */;
+                case ".web.ts" /* WebTs */:
+                    return ".web.js" /* WebJs */;
+                case ".native.ts" /* NativeTs */:
+                    return ".native.js" /* NativeJs */;
+                case ".ios.ts" /* IosTs */:
+                    return ".ios.js" /* IosJs */;
+                case ".android.ts" /* AndroidTs */:
+                    return ".android.js" /* AndroidJs */;
                 case ".tsx" /* Tsx */:
                     return options.jsx === 1 /* Preserve */ ? ".jsx" /* Jsx */ : ".js" /* Js */;
+                case ".node.tsx" /* NodeTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".node.jsx" /* NodeJsx */ : ".node.js" /* NodeJs */;
+                case ".web.tsx" /* WebTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".web.jsx" /* WebJsx */ : ".web.js" /* WebJs */;
+                case ".native.tsx" /* NativeTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".native.jsx" /* NativeJsx */ : ".native.js" /* NativeJs */;
+                case ".ios.tsx" /* IosTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".ios.jsx" /* IosJsx */ : ".ios.js" /* IosJs */;
+                case ".android.tsx" /* AndroidTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".android.jsx" /* AndroidJsx */ : ".android.js" /* AndroidJs */;
                 case ".js" /* Js */:
                 case ".jsx" /* Jsx */:
+                case ".node.js" /* NodeJs */:
+                case ".node.jsx" /* NodeJsx */:
+                case ".web.js" /* WebJs */:
+                case ".web.jsx" /* WebJsx */:
+                case ".native.js" /* NativeJs */:
+                case ".native.jsx" /* NativeJsx */:
+                case ".ios.js" /* IosJs */:
+                case ".ios.jsx" /* IosJsx */:
+                case ".android.js" /* AndroidJs */:
+                case ".android.jsx" /* AndroidJsx */:
                 case ".json" /* Json */:
+                case ".node.json" /* NodeJson */:
+                case ".web.json" /* WebJson */:
+                case ".native.json" /* NativeJson */:
+                case ".ios.json" /* IosJson */:
+                case ".android.json" /* AndroidJson */:
                     return ext;
                 case ".tsbuildinfo" /* TsBuildInfo */:
                     return ts.Debug.fail("Extension " + ".tsbuildinfo" /* TsBuildInfo */ + " is unsupported:: FileName:: " + fileName);
@@ -98267,14 +98747,47 @@ var ts;
             }
             function kindModifiersFromExtension(extension) {
                 switch (extension) {
-                    case ".d.ts" /* Dts */: return ".d.ts" /* dtsModifier */;
-                    case ".js" /* Js */: return ".js" /* jsModifier */;
-                    case ".json" /* Json */: return ".json" /* jsonModifier */;
-                    case ".jsx" /* Jsx */: return ".jsx" /* jsxModifier */;
-                    case ".ts" /* Ts */: return ".ts" /* tsModifier */;
-                    case ".tsx" /* Tsx */: return ".tsx" /* tsxModifier */;
-                    case ".tsbuildinfo" /* TsBuildInfo */: return ts.Debug.fail("Extension " + ".tsbuildinfo" /* TsBuildInfo */ + " is unsupported.");
-                    case undefined: return "" /* none */;
+                    case ".d.ts" /* Dts */:
+                        return ".d.ts" /* dtsModifier */;
+                    case ".js" /* Js */:
+                    case ".node.js" /* NodeJs */:
+                    case ".web.js" /* WebJs */:
+                    case ".native.js" /* NativeJs */:
+                    case ".ios.js" /* IosJs */:
+                    case ".android.js" /* AndroidJs */:
+                        return ".js" /* jsModifier */;
+                    case ".json" /* Json */:
+                    case ".node.json" /* NodeJson */:
+                    case ".web.json" /* WebJson */:
+                    case ".native.json" /* NativeJson */:
+                    case ".ios.json" /* IosJson */:
+                    case ".android.json" /* AndroidJson */:
+                        return ".json" /* jsonModifier */;
+                    case ".jsx" /* Jsx */:
+                    case ".node.jsx" /* NodeJsx */:
+                    case ".web.jsx" /* WebJsx */:
+                    case ".native.jsx" /* NativeJsx */:
+                    case ".ios.jsx" /* IosJsx */:
+                    case ".android.jsx" /* AndroidJsx */:
+                        return ".jsx" /* jsxModifier */;
+                    case ".ts" /* Ts */:
+                    case ".node.ts" /* NodeTs */:
+                    case ".web.ts" /* WebTs */:
+                    case ".native.ts" /* NativeTs */:
+                    case ".ios.ts" /* IosTs */:
+                    case ".android.ts" /* AndroidTs */:
+                        return ".ts" /* tsModifier */;
+                    case ".tsx" /* Tsx */:
+                    case ".node.tsx" /* NodeTsx */:
+                    case ".web.tsx" /* WebTsx */:
+                    case ".native.tsx" /* NativeTsx */:
+                    case ".ios.tsx" /* IosTsx */:
+                    case ".android.tsx" /* AndroidTsx */:
+                        return ".tsx" /* tsxModifier */;
+                    case ".tsbuildinfo" /* TsBuildInfo */:
+                        return ts.Debug.fail("Extension " + ".tsbuildinfo" /* TsBuildInfo */ + " is unsupported.");
+                    case undefined:
+                        return "" /* none */;
                     default:
                         return ts.Debug.assertNever(extension);
                 }
diff --git a/lib/typingsInstaller.js b/lib/typingsInstaller.js
index 2a959a8a41..f5ee23caa8 100644
--- a/lib/typingsInstaller.js
+++ b/lib/typingsInstaller.js
@@ -3834,12 +3834,37 @@ var ts;
     var Extension;
     (function (Extension) {
         Extension["Ts"] = ".ts";
+        Extension["IosTs"] = ".ios.ts";
+        Extension["AndroidTs"] = ".android.ts";
+        Extension["NativeTs"] = ".native.ts";
+        Extension["WebTs"] = ".web.ts";
+        Extension["NodeTs"] = ".node.ts";
         Extension["Tsx"] = ".tsx";
+        Extension["IosTsx"] = ".ios.tsx";
+        Extension["AndroidTsx"] = ".android.tsx";
+        Extension["NativeTsx"] = ".native.tsx";
+        Extension["WebTsx"] = ".web.tsx";
+        Extension["NodeTsx"] = ".node.tsx";
         Extension["Dts"] = ".d.ts";
         Extension["Js"] = ".js";
+        Extension["IosJs"] = ".ios.js";
+        Extension["AndroidJs"] = ".android.js";
+        Extension["NativeJs"] = ".native.js";
+        Extension["WebJs"] = ".web.js";
+        Extension["NodeJs"] = ".node.js";
         Extension["Jsx"] = ".jsx";
         Extension["Json"] = ".json";
         Extension["TsBuildInfo"] = ".tsbuildinfo";
+        Extension["IosJsx"] = ".ios.jsx";
+        Extension["AndroidJsx"] = ".android.jsx";
+        Extension["NativeJsx"] = ".native.jsx";
+        Extension["WebJsx"] = ".web.jsx";
+        Extension["NodeJsx"] = ".node.jsx";
+        Extension["IosJson"] = ".ios.json";
+        Extension["AndroidJson"] = ".android.json";
+        Extension["NativeJson"] = ".native.json";
+        Extension["WebJson"] = ".web.json";
+        Extension["NodeJson"] = ".node.json";
     })(Extension = ts.Extension || (ts.Extension = {}));
     /* @internal */
     var TransformFlags;
@@ -5028,7 +5053,21 @@ var ts;
             }
             function realpath(path) {
                 try {
-                    return _fs.realpathSync(path);
+                    var regexp = /\.([^\/]+?)$/;
+                    var match = path.match(regexp);
+                    var rpath = _fs.realpathSync(path);
+                    if (match !== null) {
+                        var ext = match[1];
+                        var rmatch = rpath.match(regexp);
+                        if (rmatch !== null) {
+                            var rext = rmatch[1];
+                            if (ext !== rext) {
+                                return rpath.replace(new RegExp(rext + "$"), ext);
+                            }
+                            return rpath;
+                        }
+                    }
+                    return rpath;
                 }
                 catch (_a) {
                     return path;
@@ -12044,7 +12083,7 @@ var ts;
     }
     /** Return ".ts", ".d.ts", or ".tsx", if that is the extension. */
     function tryExtractTSExtension(fileName) {
-        return ts.find(ts.supportedTSExtensionsForExtractExtension, function (extension) { return ts.fileExtensionIs(fileName, extension); });
+        return ts.find(ts.supportedTSExtensions, function (extension) { return ts.fileExtensionIs(fileName, extension); });
     }
     ts.tryExtractTSExtension = tryExtractTSExtension;
     /**
@@ -16008,14 +16047,55 @@ var ts;
     /**
      *  List of supported extensions in order of file resolution precedence.
      */
-    ts.supportedTSExtensions = [".ts" /* Ts */, ".tsx" /* Tsx */, ".d.ts" /* Dts */];
-    ts.supportedTSExtensionsWithJson = [".ts" /* Ts */, ".tsx" /* Tsx */, ".d.ts" /* Dts */, ".json" /* Json */];
-    /** Must have ".d.ts" first because if ".ts" goes first, that will be detected as the extension instead of ".d.ts". */
-    ts.supportedTSExtensionsForExtractExtension = [".d.ts" /* Dts */, ".ts" /* Ts */, ".tsx" /* Tsx */];
-    ts.supportedJSExtensions = [".js" /* Js */, ".jsx" /* Jsx */];
-    ts.supportedJSAndJsonExtensions = [".js" /* Js */, ".jsx" /* Jsx */, ".json" /* Json */];
+    ts.supportedJsonExtensions = [
+        ".node.json" /* NodeJson */,
+        ".web.json" /* WebJson */,
+        ".native.json" /* NativeJson */,
+        ".ios.json" /* IosJson */,
+        ".android.json" /* AndroidJson */,
+        ".json" /* Json */
+    ];
+    ts.supportedTSExtensions = [
+        ".node.ts" /* NodeTs */,
+        ".node.tsx" /* NodeTsx */,
+        ".web.ts" /* WebTs */,
+        ".web.tsx" /* WebTsx */,
+        ".native.ts" /* NativeTs */,
+        ".native.tsx" /* NativeTsx */,
+        ".ios.ts" /* IosTs */,
+        ".ios.tsx" /* IosTsx */,
+        ".android.ts" /* AndroidTs */,
+        ".android.tsx" /* AndroidTsx */,
+        ".d.ts" /* Dts */,
+        ".ts" /* Ts */,
+        ".tsx" /* Tsx */
+    ];
+    ts.supportedTSExtensionsWithJson = ts.supportedTSExtensions.concat(ts.supportedJsonExtensions);
+    ts.supportedJSExtensions = [
+        ".node.js" /* NodeJs */,
+        ".node.jsx" /* NodeJsx */,
+        ".web.js" /* WebJs */,
+        ".web.jsx" /* WebJsx */,
+        ".native.js" /* NativeJs */,
+        ".native.jsx" /* NativeJsx */,
+        ".ios.js" /* IosJs */,
+        ".ios.jsx" /* IosJsx */,
+        ".android.js" /* AndroidJs */,
+        ".android.jsx" /* AndroidJsx */,
+        ".js" /* Js */,
+        ".jsx" /* Jsx */
+    ];
+    ts.supportedJSAndJsonExtensions = ts.supportedJSExtensions.concat(ts.supportedJsonExtensions);
     var allSupportedExtensions = ts.supportedTSExtensions.concat(ts.supportedJSExtensions);
-    var allSupportedExtensionsWithJson = ts.supportedTSExtensions.concat(ts.supportedJSExtensions, [".json" /* Json */]);
+    var allSupportedExtensionsWithJson = ts.supportedTSExtensions.concat(ts.supportedJSExtensions, ts.supportedJsonExtensions);
+    function getAllSupportedExtensions() {
+        return allSupportedExtensions;
+    }
+    ts.getAllSupportedExtensions = getAllSupportedExtensions;
+    function getAllSupportedExtensionsWithJson() {
+        return allSupportedExtensionsWithJson;
+    }
+    ts.getAllSupportedExtensionsWithJson = getAllSupportedExtensionsWithJson;
     function getSupportedExtensions(options, extraFileExtensions) {
         var needJsExtensions = options && options.allowJs;
         if (!extraFileExtensions || extraFileExtensions.length === 0) {
@@ -16187,7 +16267,7 @@ var ts;
     ts.positionIsSynthesized = positionIsSynthesized;
     /** True if an extension is one of the supported TypeScript extensions. */
     function extensionIsTS(ext) {
-        return ext === ".ts" /* Ts */ || ext === ".tsx" /* Tsx */ || ext === ".d.ts" /* Dts */;
+        return ts.supportedTSExtensions.indexOf(ext) !== -1;
     }
     ts.extensionIsTS = extensionIsTS;
     function resolutionExtensionIsTSOrJson(ext) {
@@ -16208,7 +16288,7 @@ var ts;
     }
     ts.isAnySupportedFileExtension = isAnySupportedFileExtension;
     function tryGetExtensionFromPath(path) {
-        return ts.find(extensionsToRemove, function (e) { return ts.fileExtensionIs(path, e); });
+        return ts.find(allSupportedExtensionsWithJson, function (e) { return ts.fileExtensionIs(path, e); });
     }
     ts.tryGetExtensionFromPath = tryGetExtensionFromPath;
     function getAnyExtensionFromPathWorker(path, extensions, stringEqualityComparer) {
@@ -16249,6 +16329,19 @@ var ts;
         files: ts.emptyArray,
         directories: ts.emptyArray
     };
+    function getFileExtension(filepath) {
+        if (typeof filepath === "undefined") {
+            return ".ts" /* Ts */;
+        }
+        for (var _i = 0, allSupportedExtensionsWithJson_1 = allSupportedExtensionsWithJson; _i < allSupportedExtensionsWithJson_1.length; _i++) {
+            var ext = allSupportedExtensionsWithJson_1[_i];
+            if (ts.endsWith(filepath, ext)) {
+                return ext;
+            }
+        }
+        return ".ts" /* Ts */;
+    }
+    ts.getFileExtension = getFileExtension;
     /**
      * patternStrings contains both pattern strings (containing "*") and regular strings.
      * Return an exact match if possible, or a pattern match, or undefined.
@@ -25612,7 +25705,7 @@ var ts;
             return extendedConfigPath;
         }
         // If the path isn't a rooted or relative path, resolve like a module
-        var resolved = ts.nodeModuleNameResolver(extendedConfig, ts.combinePaths(basePath, "tsconfig.json"), { moduleResolution: ts.ModuleResolutionKind.NodeJs }, host, /*cache*/ undefined, /*projectRefs*/ undefined, /*lookupConfig*/ true);
+        var resolved = ts.nodeModuleNameResolver(".ts" /* Ts */, extendedConfig, ts.combinePaths(basePath, "tsconfig.json"), { moduleResolution: ts.ModuleResolutionKind.NodeJs }, host, /*cache*/ undefined, /*projectRefs*/ undefined, /*lookupConfig*/ true);
         if (resolved.resolvedModule) {
             return resolved.resolvedModule.resolvedFileName;
         }
@@ -26191,6 +26284,12 @@ var ts;
     function readPackageJsonMainField(jsonContent, baseDirectory, state) {
         return readPackageJsonPathField(jsonContent, "main", baseDirectory, state);
     }
+    function readPackageJsonReactNativeField(jsonContent, baseDirectory, state) {
+        return readPackageJsonPathField(jsonContent, "react-native", baseDirectory, state);
+    }
+    function readPackageJsonBrowserField(jsonContent, baseDirectory, state) {
+        return readPackageJsonPathField(jsonContent, "browser", baseDirectory, state);
+    }
     function readPackageJsonTypesVersionsField(jsonContent, state) {
         var typesVersions = readPackageJsonField(jsonContent, "typesVersions", "object", state);
         if (typesVersions === undefined)
@@ -26345,7 +26444,7 @@ var ts;
                     if (!directoryExists && traceEnabled) {
                         trace(host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, candidateDirectory);
                     }
-                    return resolvedTypeScriptOnly(loadNodeModuleFromDirectory(Extensions.DtsOnly, candidate, !directoryExists, moduleResolutionState));
+                    return resolvedTypeScriptOnly(loadNodeModuleFromDirectory(".ts" /* Ts */, Extensions.DtsOnly, candidate, !directoryExists, moduleResolutionState));
                 });
             }
             else {
@@ -26363,12 +26462,12 @@ var ts;
                 }
                 var result = void 0;
                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {
-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
+                    var searchResult = loadModuleFromNearestNodeModulesDirectory(".ts" /* Ts */, Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
                     result = searchResult && searchResult.value;
                 }
                 else {
                     var candidate = ts.normalizePathAndParts(ts.combinePaths(initialLocationForSecondaryLookup, typeReferenceDirectiveName)).path;
-                    result = nodeLoadModuleByRelativeName(Extensions.DtsOnly, candidate, /*onlyRecordFailures*/ false, moduleResolutionState, /*considerPackageJson*/ true);
+                    result = nodeLoadModuleByRelativeName(".ts" /* Ts */, Extensions.DtsOnly, candidate, /*onlyRecordFailures*/ false, moduleResolutionState, /*considerPackageJson*/ true);
                 }
                 var resolvedFile = resolvedTypeScriptOnly(result);
                 if (!resolvedFile && traceEnabled) {
@@ -26550,8 +26649,9 @@ var ts;
     ts.createModuleResolutionCacheWithMaps = createModuleResolutionCacheWithMaps;
     function resolveModuleNameFromCache(moduleName, containingFile, cache) {
         var containingDirectory = ts.getDirectoryPath(containingFile);
+        var parentFileExtension = ts.getFileExtension(containingFile);
         var perFolderCache = cache && cache.getOrCreateCacheForDirectory(containingDirectory);
-        return perFolderCache && perFolderCache.get(moduleName);
+        return perFolderCache && perFolderCache.get(moduleName + "|" + parentFileExtension);
     }
     ts.resolveModuleNameFromCache = resolveModuleNameFromCache;
     function resolveModuleName(moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
@@ -26566,8 +26666,10 @@ var ts;
             }
         }
         var containingDirectory = ts.getDirectoryPath(containingFile);
+        var parentFileExtension = ts.getFileExtension(containingFile);
+        var moduleNameKey = moduleName + "|" + parentFileExtension;
         var perFolderCache = cache && cache.getOrCreateCacheForDirectory(containingDirectory, redirectedReference);
-        var result = perFolderCache && perFolderCache.get(moduleName);
+        var result = perFolderCache && perFolderCache.get(moduleNameKey);
         if (result) {
             if (traceEnabled) {
                 trace(host, ts.Diagnostics.Resolution_for_module_0_was_found_in_cache_from_location_1, moduleName, containingDirectory);
@@ -26588,19 +26690,19 @@ var ts;
             }
             switch (moduleResolution) {
                 case ts.ModuleResolutionKind.NodeJs:
-                    result = nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
+                    result = nodeModuleNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
                     break;
                 case ts.ModuleResolutionKind.Classic:
-                    result = classicNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
+                    result = classicNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference);
                     break;
                 default:
                     return ts.Debug.fail("Unexpected moduleResolution: " + moduleResolution);
             }
             if (perFolderCache) {
-                perFolderCache.set(moduleName, result);
+                perFolderCache.set(moduleNameKey, result);
                 if (!ts.isExternalModuleNameRelative(moduleName)) {
                     // put result in per-module name cache
-                    cache.getOrCreateCacheForModuleName(moduleName, redirectedReference).set(containingDirectory, result);
+                    cache.getOrCreateCacheForModuleName(moduleNameKey, redirectedReference).set(containingDirectory, result);
                 }
             }
         }
@@ -26675,28 +26777,28 @@ var ts;
      * be converted to a path relative to found rootDir entry './content/protocols/file2' (*). As a last step compiler will check all remaining
      * entries in 'rootDirs', use them to build absolute path out of (*) and try to resolve module from this location.
      */
-    function tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loader, state) {
-        var resolved = tryLoadModuleUsingPathsIfEligible(extensions, moduleName, loader, state);
+    function tryLoadModuleUsingOptionalResolutionSettings(parentFileExtension, extensions, moduleName, containingDirectory, loader, state) {
+        var resolved = tryLoadModuleUsingPathsIfEligible(parentFileExtension, extensions, moduleName, loader, state);
         if (resolved)
             return resolved.value;
         if (!ts.isExternalModuleNameRelative(moduleName)) {
-            return tryLoadModuleUsingBaseUrl(extensions, moduleName, loader, state);
+            return tryLoadModuleUsingBaseUrl(parentFileExtension, extensions, moduleName, loader, state);
         }
         else {
-            return tryLoadModuleUsingRootDirs(extensions, moduleName, containingDirectory, loader, state);
+            return tryLoadModuleUsingRootDirs(parentFileExtension, extensions, moduleName, containingDirectory, loader, state);
         }
     }
-    function tryLoadModuleUsingPathsIfEligible(extensions, moduleName, loader, state) {
+    function tryLoadModuleUsingPathsIfEligible(parentFileExtension, extensions, moduleName, loader, state) {
         var _a = state.compilerOptions, baseUrl = _a.baseUrl, paths = _a.paths;
         if (baseUrl && paths && !ts.pathIsRelative(moduleName)) {
             if (state.traceEnabled) {
                 trace(state.host, ts.Diagnostics.baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1, baseUrl, moduleName);
                 trace(state.host, ts.Diagnostics.paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0, moduleName);
             }
-            return tryLoadModuleUsingPaths(extensions, moduleName, baseUrl, paths, loader, /*onlyRecordFailures*/ false, state);
+            return tryLoadModuleUsingPaths(parentFileExtension, extensions, moduleName, baseUrl, paths, loader, /*onlyRecordFailures*/ false, state);
         }
     }
-    function tryLoadModuleUsingRootDirs(extensions, moduleName, containingDirectory, loader, state) {
+    function tryLoadModuleUsingRootDirs(parentFileExtension, extensions, moduleName, containingDirectory, loader, state) {
         if (!state.compilerOptions.rootDirs) {
             return undefined;
         }
@@ -26734,7 +26836,7 @@ var ts;
             if (state.traceEnabled) {
                 trace(state.host, ts.Diagnostics.Loading_0_from_the_root_dir_1_candidate_location_2, suffix, matchedNormalizedPrefix, candidate);
             }
-            var resolvedFileName = loader(extensions, candidate, !ts.directoryProbablyExists(containingDirectory, state.host), state);
+            var resolvedFileName = loader(parentFileExtension, extensions, candidate, !ts.directoryProbablyExists(containingDirectory, state.host), state);
             if (resolvedFileName) {
                 return resolvedFileName;
             }
@@ -26753,7 +26855,7 @@ var ts;
                     trace(state.host, ts.Diagnostics.Loading_0_from_the_root_dir_1_candidate_location_2, suffix, rootDir, candidate_1);
                 }
                 var baseDirectory = ts.getDirectoryPath(candidate_1);
-                var resolvedFileName_1 = loader(extensions, candidate_1, !ts.directoryProbablyExists(baseDirectory, state.host), state);
+                var resolvedFileName_1 = loader(parentFileExtension, extensions, candidate_1, !ts.directoryProbablyExists(baseDirectory, state.host), state);
                 if (resolvedFileName_1) {
                     return resolvedFileName_1;
                 }
@@ -26764,7 +26866,7 @@ var ts;
         }
         return undefined;
     }
-    function tryLoadModuleUsingBaseUrl(extensions, moduleName, loader, state) {
+    function tryLoadModuleUsingBaseUrl(parentFileExtension, extensions, moduleName, loader, state) {
         var baseUrl = state.compilerOptions.baseUrl;
         if (!baseUrl) {
             return undefined;
@@ -26776,7 +26878,7 @@ var ts;
         if (state.traceEnabled) {
             trace(state.host, ts.Diagnostics.Resolving_module_name_0_relative_to_base_url_1_2, moduleName, baseUrl, candidate);
         }
-        return loader(extensions, candidate, !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
+        return loader(parentFileExtension, extensions, candidate, !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
     }
     /**
      * Expose resolution logic to allow us to use Node module resolution logic from arbitrary locations.
@@ -26785,7 +26887,7 @@ var ts;
      */
     /* @internal */
     function resolveJSModule(moduleName, initialDir, host) {
-        var _a = tryResolveJSModuleWorker(moduleName, initialDir, host), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
+        var _a = tryResolveJSModuleWorker(".ts" /* Ts */, moduleName, initialDir, host), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
         if (!resolvedModule) {
             throw new Error("Could not resolve JS module '" + moduleName + "' starting at '" + initialDir + "'. Looked in: " + failedLookupLocations.join(", "));
         }
@@ -26794,7 +26896,7 @@ var ts;
     ts.resolveJSModule = resolveJSModule;
     /* @internal */
     function tryResolveJSModule(moduleName, initialDir, host) {
-        var resolvedModule = tryResolveJSModuleWorker(moduleName, initialDir, host).resolvedModule;
+        var resolvedModule = tryResolveJSModuleWorker(".ts" /* Ts */, moduleName, initialDir, host).resolvedModule;
         return resolvedModule && resolvedModule.resolvedFileName;
     }
     ts.tryResolveJSModule = tryResolveJSModule;
@@ -26802,14 +26904,14 @@ var ts;
     var tsExtensions = [Extensions.TypeScript, Extensions.JavaScript];
     var tsPlusJsonExtensions = tsExtensions.concat([Extensions.Json]);
     var tsconfigExtensions = [Extensions.TSConfig];
-    function tryResolveJSModuleWorker(moduleName, initialDir, host) {
-        return nodeModuleNameResolverWorker(moduleName, initialDir, { moduleResolution: ts.ModuleResolutionKind.NodeJs, allowJs: true }, host, /*cache*/ undefined, jsOnlyExtensions, /*redirectedReferences*/ undefined);
+    function tryResolveJSModuleWorker(parentFileExtension, moduleName, initialDir, host) {
+        return nodeModuleNameResolverWorker(parentFileExtension, moduleName, initialDir, { moduleResolution: ts.ModuleResolutionKind.NodeJs, allowJs: true }, host, /*cache*/ undefined, jsOnlyExtensions, /*redirectedReferences*/ undefined);
     }
-    function nodeModuleNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference, lookupConfig) {
-        return nodeModuleNameResolverWorker(moduleName, ts.getDirectoryPath(containingFile), compilerOptions, host, cache, lookupConfig ? tsconfigExtensions : (compilerOptions.resolveJsonModule ? tsPlusJsonExtensions : tsExtensions), redirectedReference);
+    function nodeModuleNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference, lookupConfig) {
+        return nodeModuleNameResolverWorker(parentFileExtension, moduleName, ts.getDirectoryPath(containingFile), compilerOptions, host, cache, lookupConfig ? tsconfigExtensions : (compilerOptions.resolveJsonModule ? tsPlusJsonExtensions : tsExtensions), redirectedReference);
     }
     ts.nodeModuleNameResolver = nodeModuleNameResolver;
-    function nodeModuleNameResolverWorker(moduleName, containingDirectory, compilerOptions, host, cache, extensions, redirectedReference) {
+    function nodeModuleNameResolverWorker(parentFileExtension, moduleName, containingDirectory, compilerOptions, host, cache, extensions, redirectedReference) {
         var traceEnabled = isTraceEnabled(compilerOptions, host);
         var failedLookupLocations = [];
         var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations };
@@ -26820,8 +26922,8 @@ var ts;
         }
         return { resolvedModule: undefined, failedLookupLocations: failedLookupLocations };
         function tryResolve(extensions) {
-            var loader = function (extensions, candidate, onlyRecordFailures, state) { return nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ true); };
-            var resolved = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loader, state);
+            var loader = function (parentFileExtension, extensions, candidate, onlyRecordFailures, state) { return nodeLoadModuleByRelativeName(parentFileExtension, extensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ true); };
+            var resolved = tryLoadModuleUsingOptionalResolutionSettings(parentFileExtension, extensions, moduleName, containingDirectory, loader, state);
             if (resolved) {
                 return toSearchResult({ resolved: resolved, isExternalLibraryImport: pathContainsNodeModules(resolved.path) });
             }
@@ -26829,7 +26931,7 @@ var ts;
                 if (traceEnabled) {
                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);
                 }
-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
+                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(parentFileExtension, extensions, moduleName, containingDirectory, state, cache, redirectedReference);
                 if (!resolved_1)
                     return undefined;
                 var resolvedValue = resolved_1.value;
@@ -26843,7 +26945,7 @@ var ts;
             }
             else {
                 var _a = ts.normalizePathAndParts(ts.combinePaths(containingDirectory, moduleName)), candidate = _a.path, parts = _a.parts;
-                var resolved_2 = nodeLoadModuleByRelativeName(extensions, candidate, /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true);
+                var resolved_2 = nodeLoadModuleByRelativeName(parentFileExtension, extensions, candidate, /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true);
                 // Treat explicit "node_modules" import as an external library import.
                 return resolved_2 && toSearchResult({ resolved: resolved_2, isExternalLibraryImport: ts.contains(parts, "node_modules") });
             }
@@ -26860,7 +26962,7 @@ var ts;
         ts.Debug.assert(host.fileExists(real), path + " linked to nonexistent file " + real); // tslint:disable-line
         return real;
     }
-    function nodeLoadModuleByRelativeName(extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
+    function nodeLoadModuleByRelativeName(parentFileExtension, extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
         if (state.traceEnabled) {
             trace(state.host, ts.Diagnostics.Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1, candidate, Extensions[extensions]);
         }
@@ -26874,10 +26976,10 @@ var ts;
                     onlyRecordFailures = true;
                 }
             }
-            var resolvedFromFile = loadModuleFromFile(extensions, candidate, onlyRecordFailures, state);
+            var resolvedFromFile = loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state);
             if (resolvedFromFile) {
                 var nm = considerPackageJson ? parseNodeModuleFromPath(resolvedFromFile) : undefined;
-                var packageInfo = nm && getPackageJsonInfo(nm.packageDirectory, nm.subModuleName, /*onlyRecordFailures*/ false, state);
+                var packageInfo = nm && getPackageJsonInfo(parentFileExtension, nm.packageDirectory, nm.subModuleName, /*onlyRecordFailures*/ false, state);
                 var packageId = packageInfo && packageInfo.packageId;
                 return withPackageId(packageId, resolvedFromFile);
             }
@@ -26891,7 +26993,7 @@ var ts;
                 onlyRecordFailures = true;
             }
         }
-        return loadNodeModuleFromDirectory(extensions, candidate, onlyRecordFailures, state, considerPackageJson);
+        return loadNodeModuleFromDirectory(parentFileExtension, extensions, candidate, onlyRecordFailures, state, considerPackageJson);
     }
     /*@internal*/
     ts.nodeModulesPathPart = "/node_modules/";
@@ -26942,20 +27044,20 @@ var ts;
         }
         return path + "/index.d.ts";
     }
-    function loadModuleFromFileNoPackageId(extensions, candidate, onlyRecordFailures, state) {
-        return noPackageId(loadModuleFromFile(extensions, candidate, onlyRecordFailures, state));
+    function loadModuleFromFileNoPackageId(parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
+        return noPackageId(loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state));
     }
     /**
      * @param {boolean} onlyRecordFailures - if true then function won't try to actually load files but instead record all attempts as failures. This flag is necessary
      * in cases when we know upfront that all load attempts will fail (because containing folder does not exists) however we still need to record all failed lookup locations.
      */
-    function loadModuleFromFile(extensions, candidate, onlyRecordFailures, state) {
+    function loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
         if (extensions === Extensions.Json || extensions === Extensions.TSConfig) {
             var extensionLess = ts.tryRemoveExtension(candidate, ".json" /* Json */);
-            return (extensionLess === undefined && extensions === Extensions.Json) ? undefined : tryAddingExtensions(extensionLess || candidate, extensions, onlyRecordFailures, state);
+            return (extensionLess === undefined && extensions === Extensions.Json) ? undefined : tryAddingExtensions(parentFileExtension, extensionLess || candidate, extensions, onlyRecordFailures, state);
         }
         // First, try adding an extension. An import of "foo" could be matched by a file "foo.ts", or "foo.js" by "foo.js.ts"
-        var resolvedByAddingExtension = tryAddingExtensions(candidate, extensions, onlyRecordFailures, state);
+        var resolvedByAddingExtension = tryAddingExtensions(parentFileExtension, candidate, extensions, onlyRecordFailures, state);
         if (resolvedByAddingExtension) {
             return resolvedByAddingExtension;
         }
@@ -26967,11 +27069,11 @@ var ts;
                 var extension = candidate.substring(extensionless.length);
                 trace(state.host, ts.Diagnostics.File_name_0_has_a_1_extension_stripping_it, candidate, extension);
             }
-            return tryAddingExtensions(extensionless, extensions, onlyRecordFailures, state);
+            return tryAddingExtensions(parentFileExtension, extensionless, extensions, onlyRecordFailures, state);
         }
     }
     /** Try to return an existing file that adds one of the `extensions` to `candidate`. */
-    function tryAddingExtensions(candidate, extensions, onlyRecordFailures, state) {
+    function tryAddingExtensions(parentFileExtension, candidate, extensions, onlyRecordFailures, state) {
         if (!onlyRecordFailures) {
             // check if containing folder exists - if it doesn't then just record failures for all supported extensions without disk probing
             var directory = ts.getDirectoryPath(candidate);
@@ -26979,16 +27081,212 @@ var ts;
                 onlyRecordFailures = !ts.directoryProbablyExists(directory, state.host);
             }
         }
-        switch (extensions) {
-            case Extensions.DtsOnly:
-                return tryExtension(".d.ts" /* Dts */);
-            case Extensions.TypeScript:
-                return tryExtension(".ts" /* Ts */) || tryExtension(".tsx" /* Tsx */) || tryExtension(".d.ts" /* Dts */);
-            case Extensions.JavaScript:
-                return tryExtension(".js" /* Js */) || tryExtension(".jsx" /* Jsx */);
-            case Extensions.TSConfig:
-            case Extensions.Json:
-                return tryExtension(".json" /* Json */);
+        switch (parentFileExtension) {
+            case ".web.ts" /* WebTs */:
+            case ".web.tsx" /* WebTsx */:
+            case ".web.js" /* WebJs */:
+            case ".web.jsx" /* WebJsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".web.json" /* WebJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".web.js" /* WebJs */) ||
+                            tryExtension(".web.jsx" /* WebJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".web.ts" /* WebTs */) ||
+                            tryExtension(".web.tsx" /* WebTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".native.js" /* NativeJs */:
+            case ".native.jsx" /* NativeJsx */:
+            case ".native.ts" /* NativeTs */:
+            case ".native.tsx" /* NativeTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".json" /* Json */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".ios.json" /* IosJson */) ||
+                            tryExtension(".android.json" /* AndroidJson */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".ios.js" /* IosJs */) ||
+                            tryExtension(".ios.jsx" /* IosJsx */) ||
+                            tryExtension(".android.js" /* AndroidJs */) ||
+                            tryExtension(".android.jsx" /* AndroidJsx */));
+                    }
+                    default: {
+                        return (tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ios.ts" /* IosTs */) ||
+                            tryExtension(".ios.tsx" /* IosTsx */) ||
+                            tryExtension(".android.ts" /* AndroidTs */) ||
+                            tryExtension(".android.tsx" /* AndroidTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".ios.js" /* IosJs */:
+            case ".ios.jsx" /* IosJsx */:
+            case ".ios.ts" /* IosTs */:
+            case ".ios.tsx" /* IosTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".ios.json" /* IosJson */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".ios.js" /* IosJs */) ||
+                            tryExtension(".ios.jsx" /* IosJsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".ios.ts" /* IosTs */) ||
+                            tryExtension(".ios.tsx" /* IosTsx */) ||
+                            tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".android.js" /* AndroidJs */:
+            case ".android.jsx" /* AndroidJsx */:
+            case ".android.ts" /* AndroidTs */:
+            case ".android.tsx" /* AndroidTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".android.json" /* AndroidJson */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".android.js" /* AndroidJs */) ||
+                            tryExtension(".android.jsx" /* AndroidJsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".android.ts" /* AndroidTs */) ||
+                            tryExtension(".android.tsx" /* AndroidTsx */) ||
+                            tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            case ".node.js" /* NodeJs */:
+            case ".node.jsx" /* NodeJsx */:
+            case ".node.ts" /* NodeTs */:
+            case ".node.tsx" /* NodeTsx */: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".node.json" /* NodeJson */) ||
+                            tryExtension(".json" /* Json */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".node.js" /* NodeJs */) ||
+                            tryExtension(".node.jsx" /* NodeJsx */) ||
+                            tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */));
+                    }
+                    default: {
+                        return (tryExtension(".node.ts" /* NodeTs */) ||
+                            tryExtension(".node.tsx" /* NodeTsx */) ||
+                            tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */));
+                    }
+                }
+            }
+            default: {
+                switch (extensions) {
+                    case Extensions.DtsOnly: {
+                        return tryExtension(".d.ts" /* Dts */);
+                    }
+                    case Extensions.TSConfig:
+                    case Extensions.Json: {
+                        return (tryExtension(".json" /* Json */) ||
+                            tryExtension(".node.json" /* NodeJson */) ||
+                            tryExtension(".web.json" /* WebJson */) ||
+                            tryExtension(".native.json" /* NativeJson */) ||
+                            tryExtension(".ios.json" /* IosJson */) ||
+                            tryExtension(".android.json" /* AndroidJson */));
+                    }
+                    case Extensions.JavaScript: {
+                        return (tryExtension(".js" /* Js */) ||
+                            tryExtension(".jsx" /* Jsx */) ||
+                            tryExtension(".node.js" /* NodeJs */) ||
+                            tryExtension(".node.jsx" /* NodeJsx */) ||
+                            tryExtension(".web.js" /* WebJs */) ||
+                            tryExtension(".web.jsx" /* WebJsx */) ||
+                            tryExtension(".native.js" /* NativeJs */) ||
+                            tryExtension(".native.jsx" /* NativeJsx */) ||
+                            tryExtension(".ios.js" /* IosJs */) ||
+                            tryExtension(".ios.jsx" /* IosJsx */) ||
+                            tryExtension(".android.js" /* AndroidJs */) ||
+                            tryExtension(".android.jsx" /* AndroidJsx */));
+                    }
+                    default: {
+                        return (tryExtension(".ts" /* Ts */) ||
+                            tryExtension(".tsx" /* Tsx */) ||
+                            tryExtension(".d.ts" /* Dts */) ||
+                            tryExtension(".node.ts" /* NodeTs */) ||
+                            tryExtension(".node.tsx" /* NodeTsx */) ||
+                            tryExtension(".web.ts" /* WebTs */) ||
+                            tryExtension(".web.tsx" /* WebTsx */) ||
+                            tryExtension(".native.ts" /* NativeTs */) ||
+                            tryExtension(".native.tsx" /* NativeTsx */) ||
+                            tryExtension(".ios.ts" /* IosTs */) ||
+                            tryExtension(".ios.tsx" /* IosTsx */) ||
+                            tryExtension(".android.ts" /* AndroidTs */) ||
+                            tryExtension(".android.tsx" /* AndroidTsx */));
+                    }
+                }
+            }
         }
         function tryExtension(ext) {
             var path = tryFile(candidate + ext, onlyRecordFailures, state);
@@ -27013,15 +27311,15 @@ var ts;
         state.failedLookupLocations.push(fileName);
         return undefined;
     }
-    function loadNodeModuleFromDirectory(extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
+    function loadNodeModuleFromDirectory(parentFileExtension, extensions, candidate, onlyRecordFailures, state, considerPackageJson) {
         if (considerPackageJson === void 0) { considerPackageJson = true; }
-        var packageInfo = considerPackageJson ? getPackageJsonInfo(candidate, "", onlyRecordFailures, state) : undefined;
+        var packageInfo = considerPackageJson ? getPackageJsonInfo(parentFileExtension, candidate, "", onlyRecordFailures, state) : undefined;
         var packageId = packageInfo && packageInfo.packageId;
         var packageJsonContent = packageInfo && packageInfo.packageJsonContent;
         var versionPaths = packageJsonContent && readPackageJsonTypesVersionPaths(packageJsonContent, state);
-        return withPackageId(packageId, loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths));
+        return withPackageId(packageId, loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths));
     }
-    function getPackageJsonInfo(packageDirectory, subModuleName, onlyRecordFailures, state) {
+    function getPackageJsonInfo(parentFileExtension, packageDirectory, subModuleName, onlyRecordFailures, state) {
         var host = state.host, traceEnabled = state.traceEnabled;
         var directoryExists = !onlyRecordFailures && ts.directoryProbablyExists(packageDirectory, host);
         var packageJsonPath = ts.combinePaths(packageDirectory, "package.json");
@@ -27033,7 +27331,34 @@ var ts;
                     subModuleName = addExtensionAndIndex(path.substring(packageDirectory.length + 1));
                 }
                 else {
-                    var jsPath = readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                    var jsPath = void 0;
+                    switch (parentFileExtension) {
+                        case ".android.js" /* AndroidJs */:
+                        case ".ios.js" /* IosJs */:
+                        case ".native.js" /* NativeJs */:
+                        case ".android.jsx" /* AndroidJsx */:
+                        case ".ios.jsx" /* IosJsx */:
+                        case ".native.jsx" /* NativeJsx */:
+                        case ".android.ts" /* AndroidTs */:
+                        case ".ios.ts" /* IosTs */:
+                        case ".native.ts" /* NativeTs */:
+                        case ".android.tsx" /* AndroidTsx */:
+                        case ".ios.tsx" /* IosTsx */:
+                        case ".native.tsx" /* NativeTsx */: {
+                            jsPath = readPackageJsonReactNativeField(packageJsonContent, packageDirectory, state) || readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                            break;
+                        }
+                        case ".web.js" /* WebJs */:
+                        case ".web.jsx" /* WebJsx */:
+                        case ".web.ts" /* WebTs */:
+                        case ".web.tsx" /* WebTsx */: {
+                            jsPath = readPackageJsonBrowserField(packageJsonContent, packageDirectory, state) || readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                            break;
+                        }
+                        default: {
+                            jsPath = readPackageJsonMainField(packageJsonContent, packageDirectory, state);
+                        }
+                    }
                     if (typeof jsPath === "string" && jsPath.length > packageDirectory.length) {
                         var potentialSubModule_1 = jsPath.substring(packageDirectory.length + 1);
                         subModuleName = (ts.forEach(ts.supportedJSExtensions, function (extension) {
@@ -27050,7 +27375,7 @@ var ts;
             }
             var versionPaths = readPackageJsonTypesVersionPaths(packageJsonContent, state);
             var packageId = typeof packageJsonContent.name === "string" && typeof packageJsonContent.version === "string"
-                ? { name: packageJsonContent.name, subModuleName: subModuleName, version: packageJsonContent.version }
+                ? { name: packageJsonContent.name + "|" + parentFileExtension, subModuleName: subModuleName, version: packageJsonContent.version }
                 : undefined;
             if (traceEnabled) {
                 if (packageId) {
@@ -27070,18 +27395,79 @@ var ts;
             state.failedLookupLocations.push(packageJsonPath);
         }
     }
-    function loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, jsonContent, versionPaths) {
+    function loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, onlyRecordFailures, state, jsonContent, versionPaths) {
         var packageFile;
         if (jsonContent) {
             switch (extensions) {
                 case Extensions.JavaScript:
-                case Extensions.Json:
-                    packageFile = readPackageJsonMainField(jsonContent, candidate, state);
+                case Extensions.Json: {
+                    switch (parentFileExtension) {
+                        case ".android.js" /* AndroidJs */:
+                        case ".ios.js" /* IosJs */:
+                        case ".native.js" /* NativeJs */:
+                        case ".android.jsx" /* AndroidJsx */:
+                        case ".ios.jsx" /* IosJsx */:
+                        case ".native.jsx" /* NativeJsx */:
+                        case ".android.ts" /* AndroidTs */:
+                        case ".ios.ts" /* IosTs */:
+                        case ".native.ts" /* NativeTs */:
+                        case ".android.tsx" /* AndroidTsx */:
+                        case ".ios.tsx" /* IosTsx */:
+                        case ".native.tsx" /* NativeTsx */: {
+                            packageFile = readPackageJsonReactNativeField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        case ".web.js" /* WebJs */:
+                        case ".web.jsx" /* WebJsx */:
+                        case ".web.ts" /* WebTs */:
+                        case ".web.tsx" /* WebTsx */: {
+                            packageFile = readPackageJsonBrowserField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        default: {
+                            packageFile = readPackageJsonMainField(jsonContent, candidate, state);
+                        }
+                    }
                     break;
-                case Extensions.TypeScript:
-                    // When resolving typescript modules, try resolving using main field as well
-                    packageFile = readPackageJsonTypesFields(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                }
+                case Extensions.TypeScript: {
+                    switch (parentFileExtension) {
+                        case ".android.js" /* AndroidJs */:
+                        case ".ios.js" /* IosJs */:
+                        case ".native.js" /* NativeJs */:
+                        case ".android.jsx" /* AndroidJsx */:
+                        case ".ios.jsx" /* IosJsx */:
+                        case ".native.jsx" /* NativeJsx */:
+                        case ".android.ts" /* AndroidTs */:
+                        case ".ios.ts" /* IosTs */:
+                        case ".native.ts" /* NativeTs */:
+                        case ".android.tsx" /* AndroidTsx */:
+                        case ".ios.tsx" /* IosTsx */:
+                        case ".native.tsx" /* NativeTsx */: {
+                            packageFile = readPackageJsonReactNativeField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        case ".web.js" /* WebJs */:
+                        case ".web.jsx" /* WebJsx */:
+                        case ".web.ts" /* WebTs */:
+                        case ".web.tsx" /* WebTsx */: {
+                            packageFile = readPackageJsonBrowserField(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        case ".node.js" /* NodeJs */:
+                        case ".node.jsx" /* NodeJsx */:
+                        case ".node.ts" /* NodeTs */:
+                        case ".node.tsx" /* NodeTsx */: {
+                            packageFile = readPackageJsonMainField(jsonContent, candidate, state);
+                            break;
+                        }
+                        default: {
+                            // When resolving typescript modules, try resolving using main field as well
+                            packageFile = readPackageJsonTypesFields(jsonContent, candidate, state) || readPackageJsonMainField(jsonContent, candidate, state);
+                        }
+                    }
                     break;
+                }
                 case Extensions.DtsOnly:
                     packageFile = readPackageJsonTypesFields(jsonContent, candidate, state);
                     break;
@@ -27092,7 +27478,7 @@ var ts;
                     return ts.Debug.assertNever(extensions);
             }
         }
-        var loader = function (extensions, candidate, onlyRecordFailures, state) {
+        var loader = function (parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
             var fromFile = tryFile(candidate, onlyRecordFailures, state);
             if (fromFile) {
                 var resolved = resolvedIfExtensionMatches(extensions, fromFile);
@@ -27106,7 +27492,7 @@ var ts;
             // Even if extensions is DtsOnly, we can still look up a .ts file as a result of package.json "types"
             var nextExtensions = extensions === Extensions.DtsOnly ? Extensions.TypeScript : extensions;
             // Don't do package.json lookup recursively, because Node.js' package lookup doesn't.
-            return nodeLoadModuleByRelativeName(nextExtensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ false);
+            return nodeLoadModuleByRelativeName(parentFileExtension, nextExtensions, candidate, onlyRecordFailures, state, /*considerPackageJson*/ false);
         };
         var onlyRecordFailuresForPackageFile = packageFile ? !ts.directoryProbablyExists(ts.getDirectoryPath(packageFile), state.host) : undefined;
         var onlyRecordFailuresForIndex = onlyRecordFailures || !ts.directoryProbablyExists(candidate, state.host);
@@ -27116,16 +27502,16 @@ var ts;
             if (state.traceEnabled) {
                 trace(state.host, ts.Diagnostics.package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2, versionPaths.version, ts.version, moduleName);
             }
-            var result = tryLoadModuleUsingPaths(extensions, moduleName, candidate, versionPaths.paths, loader, onlyRecordFailuresForPackageFile || onlyRecordFailuresForIndex, state);
+            var result = tryLoadModuleUsingPaths(parentFileExtension, extensions, moduleName, candidate, versionPaths.paths, loader, onlyRecordFailuresForPackageFile || onlyRecordFailuresForIndex, state);
             if (result) {
                 return removeIgnoredPackageId(result.value);
             }
         }
         // It won't have a `packageId` set, because we disabled `considerPackageJson`.
-        var packageFileResult = packageFile && removeIgnoredPackageId(loader(extensions, packageFile, onlyRecordFailuresForPackageFile, state));
+        var packageFileResult = packageFile && removeIgnoredPackageId(loader(parentFileExtension, extensions, packageFile, onlyRecordFailuresForPackageFile, state));
         if (packageFileResult)
             return packageFileResult;
-        return loadModuleFromFile(extensions, indexPath, onlyRecordFailuresForIndex, state);
+        return loadModuleFromFile(parentFileExtension, extensions, indexPath, onlyRecordFailuresForIndex, state);
     }
     /** Resolve from an arbitrarily specified file. Return `undefined` if it has an unsupported extension. */
     function resolvedIfExtensionMatches(extensions, path) {
@@ -27136,12 +27522,40 @@ var ts;
     function extensionIsOk(extensions, extension) {
         switch (extensions) {
             case Extensions.JavaScript:
-                return extension === ".js" /* Js */ || extension === ".jsx" /* Jsx */;
+                return (extension === ".js" /* Js */ ||
+                    extension === ".jsx" /* Jsx */ ||
+                    extension === ".node.js" /* NodeJs */ ||
+                    extension === ".node.jsx" /* NodeJsx */ ||
+                    extension === ".web.js" /* WebJs */ ||
+                    extension === ".web.jsx" /* WebJsx */ ||
+                    extension === ".native.js" /* NativeJs */ ||
+                    extension === ".native.jsx" /* NativeJsx */ ||
+                    extension === ".ios.js" /* IosJs */ ||
+                    extension === ".ios.jsx" /* IosJsx */ ||
+                    extension === ".android.js" /* AndroidJs */ ||
+                    extension === ".android.jsx" /* AndroidJsx */);
             case Extensions.TSConfig:
             case Extensions.Json:
-                return extension === ".json" /* Json */;
+                return (extension === ".json" /* Json */ ||
+                    extension === ".node.json" /* NodeJson */ ||
+                    extension === ".web.json" /* WebJson */ ||
+                    extension === ".native.json" /* NativeJson */ ||
+                    extension === ".ios.json" /* IosJson */ ||
+                    extension === ".android.json" /* AndroidJson */);
             case Extensions.TypeScript:
-                return extension === ".ts" /* Ts */ || extension === ".tsx" /* Tsx */ || extension === ".d.ts" /* Dts */;
+                return (extension === ".ts" /* Ts */ ||
+                    extension === ".tsx" /* Tsx */ ||
+                    extension === ".d.ts" /* Dts */ ||
+                    extension === ".node.ts" /* NodeTs */ ||
+                    extension === ".node.tsx" /* NodeTsx */ ||
+                    extension === ".web.ts" /* WebTs */ ||
+                    extension === ".web.tsx" /* WebTsx */ ||
+                    extension === ".native.ts" /* NativeTs */ ||
+                    extension === ".native.tsx" /* NativeTsx */ ||
+                    extension === ".ios.ts" /* IosTs */ ||
+                    extension === ".ios.tsx" /* IosTsx */ ||
+                    extension === ".android.ts" /* AndroidTs */ ||
+                    extension === ".android.tsx" /* AndroidTsx */);
             case Extensions.DtsOnly:
                 return extension === ".d.ts" /* Dts */;
         }
@@ -27155,32 +27569,33 @@ var ts;
         return idx === -1 ? { packageName: moduleName, rest: "" } : { packageName: moduleName.slice(0, idx), rest: moduleName.slice(idx + 1) };
     }
     ts.parsePackageName = parsePackageName;
-    function loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, directory, state, cache, redirectedReference) {
-        return loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName, directory, state, /*typesScopeOnly*/ false, cache, redirectedReference);
+    function loadModuleFromNearestNodeModulesDirectory(parentFileExtension, extensions, moduleName, directory, state, cache, redirectedReference) {
+        return loadModuleFromNearestNodeModulesDirectoryWorker(parentFileExtension, extensions, moduleName, directory, state, /*typesScopeOnly*/ false, cache, redirectedReference);
     }
     function loadModuleFromNearestNodeModulesDirectoryTypesScope(moduleName, directory, state) {
         // Extensions parameter here doesn't actually matter, because typesOnly ensures we're just doing @types lookup, which is always DtsOnly.
-        return loadModuleFromNearestNodeModulesDirectoryWorker(Extensions.DtsOnly, moduleName, directory, state, /*typesScopeOnly*/ true, /*cache*/ undefined, /*redirectedReference*/ undefined);
+        return loadModuleFromNearestNodeModulesDirectoryWorker(".ts" /* Ts */, Extensions.DtsOnly, moduleName, directory, state, /*typesScopeOnly*/ true, /*cache*/ undefined, /*redirectedReference*/ undefined);
     }
-    function loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
-        var perModuleNameCache = cache && cache.getOrCreateCacheForModuleName(moduleName, redirectedReference);
+    function loadModuleFromNearestNodeModulesDirectoryWorker(parentFileExtension, extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
+        var moduleNameKey = moduleName + "|" + parentFileExtension;
+        var perModuleNameCache = cache && cache.getOrCreateCacheForModuleName(moduleNameKey, redirectedReference);
         return ts.forEachAncestorDirectory(ts.normalizeSlashes(directory), function (ancestorDirectory) {
             if (ts.getBaseFileName(ancestorDirectory) !== "node_modules") {
                 var resolutionFromCache = tryFindNonRelativeModuleNameInCache(perModuleNameCache, moduleName, ancestorDirectory, state);
                 if (resolutionFromCache) {
                     return resolutionFromCache;
                 }
-                return toSearchResult(loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, ancestorDirectory, state, typesScopeOnly));
+                return toSearchResult(loadModuleFromImmediateNodeModulesDirectory(parentFileExtension, extensions, moduleName, ancestorDirectory, state, typesScopeOnly));
             }
         });
     }
-    function loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, directory, state, typesScopeOnly) {
+    function loadModuleFromImmediateNodeModulesDirectory(parentFileExtension, extensions, moduleName, directory, state, typesScopeOnly) {
         var nodeModulesFolder = ts.combinePaths(directory, "node_modules");
         var nodeModulesFolderExists = ts.directoryProbablyExists(nodeModulesFolder, state.host);
         if (!nodeModulesFolderExists && state.traceEnabled) {
             trace(state.host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, nodeModulesFolder);
         }
-        var packageResult = typesScopeOnly ? undefined : loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesFolder, nodeModulesFolderExists, state);
+        var packageResult = typesScopeOnly ? undefined : loadModuleFromSpecificNodeModulesDirectory(parentFileExtension, extensions, moduleName, nodeModulesFolder, nodeModulesFolderExists, state);
         if (packageResult) {
             return packageResult;
         }
@@ -27193,35 +27608,35 @@ var ts;
                 }
                 nodeModulesAtTypesExists = false;
             }
-            return loadModuleFromSpecificNodeModulesDirectory(Extensions.DtsOnly, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes_1, nodeModulesAtTypesExists, state);
+            return loadModuleFromSpecificNodeModulesDirectory(parentFileExtension, Extensions.DtsOnly, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes_1, nodeModulesAtTypesExists, state);
         }
     }
-    function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state) {
+    function loadModuleFromSpecificNodeModulesDirectory(parentFileExtension, extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state) {
         var candidate = ts.normalizePath(ts.combinePaths(nodeModulesDirectory, moduleName));
         // First look for a nested package.json, as in `node_modules/foo/bar/package.json`.
         var packageJsonContent;
         var packageId;
         var versionPaths;
-        var packageInfo = getPackageJsonInfo(candidate, "", !nodeModulesDirectoryExists, state);
+        var packageInfo = getPackageJsonInfo(parentFileExtension, candidate, "", !nodeModulesDirectoryExists, state);
         if (packageInfo) {
             (packageJsonContent = packageInfo.packageJsonContent, packageId = packageInfo.packageId, versionPaths = packageInfo.versionPaths);
-            var fromFile = loadModuleFromFile(extensions, candidate, !nodeModulesDirectoryExists, state);
+            var fromFile = loadModuleFromFile(parentFileExtension, extensions, candidate, !nodeModulesDirectoryExists, state);
             if (fromFile) {
                 return noPackageId(fromFile);
             }
-            var fromDirectory = loadNodeModuleFromDirectoryWorker(extensions, candidate, !nodeModulesDirectoryExists, state, packageJsonContent, versionPaths);
+            var fromDirectory = loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, !nodeModulesDirectoryExists, state, packageJsonContent, versionPaths);
             return withPackageId(packageId, fromDirectory);
         }
-        var loader = function (extensions, candidate, onlyRecordFailures, state) {
-            var pathAndExtension = loadModuleFromFile(extensions, candidate, onlyRecordFailures, state) ||
-                loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths);
+        var loader = function (parentFileExtension, extensions, candidate, onlyRecordFailures, state) {
+            var pathAndExtension = loadModuleFromFile(parentFileExtension, extensions, candidate, onlyRecordFailures, state) ||
+                loadNodeModuleFromDirectoryWorker(parentFileExtension, extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths);
             return withPackageId(packageId, pathAndExtension);
         };
         var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;
         if (rest !== "") { // If "rest" is empty, we just did this search above.
             var packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
             // Don't use a "types" or "main" from here because we're not loading the root, but a subdirectory -- just here for the packageId and path mappings.
-            var packageInfo_1 = getPackageJsonInfo(packageDirectory, rest, !nodeModulesDirectoryExists, state);
+            var packageInfo_1 = getPackageJsonInfo(parentFileExtension, packageDirectory, rest, !nodeModulesDirectoryExists, state);
             if (packageInfo_1)
                 (packageId = packageInfo_1.packageId, versionPaths = packageInfo_1.versionPaths);
             if (versionPaths) {
@@ -27229,15 +27644,15 @@ var ts;
                     trace(state.host, ts.Diagnostics.package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2, versionPaths.version, ts.version, rest);
                 }
                 var packageDirectoryExists = nodeModulesDirectoryExists && ts.directoryProbablyExists(packageDirectory, state.host);
-                var fromPaths = tryLoadModuleUsingPaths(extensions, rest, packageDirectory, versionPaths.paths, loader, !packageDirectoryExists, state);
+                var fromPaths = tryLoadModuleUsingPaths(parentFileExtension, extensions, rest, packageDirectory, versionPaths.paths, loader, !packageDirectoryExists, state);
                 if (fromPaths) {
                     return fromPaths.value;
                 }
             }
         }
-        return loader(extensions, candidate, !nodeModulesDirectoryExists, state);
+        return loader(parentFileExtension, extensions, candidate, !nodeModulesDirectoryExists, state);
     }
-    function tryLoadModuleUsingPaths(extensions, moduleName, baseDirectory, paths, loader, onlyRecordFailures, state) {
+    function tryLoadModuleUsingPaths(parentFileExtension, extensions, moduleName, baseDirectory, paths, loader, onlyRecordFailures, state) {
         var matchedPattern = ts.matchPatternOrExact(ts.getOwnKeys(paths), moduleName);
         if (matchedPattern) {
             var matchedStar_1 = ts.isString(matchedPattern) ? undefined : ts.matchedText(matchedPattern, moduleName);
@@ -27259,7 +27674,7 @@ var ts;
                         return noPackageId({ path: path_1, ext: extension });
                     }
                 }
-                return loader(extensions, candidate, onlyRecordFailures || !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
+                return loader(parentFileExtension, extensions, candidate, onlyRecordFailures || !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
             });
             return { value: resolved };
         }
@@ -27317,7 +27732,7 @@ var ts;
             return { value: result.resolvedModule && { path: result.resolvedModule.resolvedFileName, originalPath: result.resolvedModule.originalPath || true, extension: result.resolvedModule.extension, packageId: result.resolvedModule.packageId } };
         }
     }
-    function classicNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
+    function classicNameResolver(parentFileExtension, moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
         var traceEnabled = isTraceEnabled(compilerOptions, host);
         var failedLookupLocations = [];
         var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations };
@@ -27326,7 +27741,7 @@ var ts;
         // No originalPath because classic resolution doesn't resolve realPath
         return createResolvedModuleWithFailedLookupLocations(resolved && resolved.value, /*isExternalLibraryImport*/ false, failedLookupLocations);
         function tryResolve(extensions) {
-            var resolvedUsingSettings = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loadModuleFromFileNoPackageId, state);
+            var resolvedUsingSettings = tryLoadModuleUsingOptionalResolutionSettings(parentFileExtension, extensions, moduleName, containingDirectory, loadModuleFromFileNoPackageId, state);
             if (resolvedUsingSettings) {
                 return { value: resolvedUsingSettings };
             }
@@ -27339,7 +27754,7 @@ var ts;
                         return resolutionFromCache;
                     }
                     var searchName = ts.normalizePath(ts.combinePaths(directory, moduleName));
-                    return toSearchResult(loadModuleFromFileNoPackageId(extensions, searchName, /*onlyRecordFailures*/ false, state));
+                    return toSearchResult(loadModuleFromFileNoPackageId(parentFileExtension, extensions, searchName, /*onlyRecordFailures*/ false, state));
                 });
                 if (resolved_3) {
                     return resolved_3;
@@ -27351,7 +27766,7 @@ var ts;
             }
             else {
                 var candidate = ts.normalizePath(ts.combinePaths(containingDirectory, moduleName));
-                return toSearchResult(loadModuleFromFileNoPackageId(extensions, candidate, /*onlyRecordFailures*/ false, state));
+                return toSearchResult(loadModuleFromFileNoPackageId(parentFileExtension, extensions, candidate, /*onlyRecordFailures*/ false, state));
             }
         }
     }
@@ -27361,14 +27776,15 @@ var ts;
      * This is the minumum code needed to expose that functionality; the rest is in LSHost.
      */
     /* @internal */
-    function loadModuleFromGlobalCache(moduleName, projectName, compilerOptions, host, globalCache) {
+    function loadModuleFromGlobalCache(moduleName, containingFile, projectName, compilerOptions, host, globalCache) {
         var traceEnabled = isTraceEnabled(compilerOptions, host);
         if (traceEnabled) {
             trace(host, ts.Diagnostics.Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2, projectName, moduleName, globalCache);
         }
         var failedLookupLocations = [];
         var state = { compilerOptions: compilerOptions, host: host, traceEnabled: traceEnabled, failedLookupLocations: failedLookupLocations };
-        var resolved = loadModuleFromImmediateNodeModulesDirectory(Extensions.DtsOnly, moduleName, globalCache, state, /*typesScopeOnly*/ false);
+        var parentFileContext = ts.getFileExtension(containingFile);
+        var resolved = loadModuleFromImmediateNodeModulesDirectory(parentFileContext, Extensions.DtsOnly, moduleName, globalCache, state, /*typesScopeOnly*/ false);
         return createResolvedModuleWithFailedLookupLocations(resolved, /*isExternalLibraryImport*/ true, failedLookupLocations);
     }
     ts.loadModuleFromGlobalCache = loadModuleFromGlobalCache;
@@ -90435,16 +90851,41 @@ var ts;
         var extension = _a.extension;
         switch (extension) {
             case ".ts" /* Ts */:
+            case ".node.ts" /* NodeTs */:
+            case ".web.ts" /* WebTs */:
+            case ".native.ts" /* NativeTs */:
+            case ".ios.ts" /* IosTs */:
+            case ".android.ts" /* AndroidTs */:
             case ".d.ts" /* Dts */:
                 // These are always allowed.
                 return undefined;
             case ".tsx" /* Tsx */:
+            case ".node.tsx" /* NodeTsx */:
+            case ".web.tsx" /* WebTsx */:
+            case ".native.tsx" /* NativeTsx */:
+            case ".ios.tsx" /* IosTsx */:
+            case ".android.tsx" /* AndroidTsx */:
                 return needJsx();
             case ".jsx" /* Jsx */:
+            case ".node.jsx" /* NodeJsx */:
+            case ".web.jsx" /* WebJsx */:
+            case ".native.jsx" /* NativeJsx */:
+            case ".ios.jsx" /* IosJsx */:
+            case ".android.jsx" /* AndroidJsx */:
                 return needJsx() || needAllowJs();
             case ".js" /* Js */:
+            case ".node.js" /* NodeJs */:
+            case ".web.js" /* WebJs */:
+            case ".native.js" /* NativeJs */:
+            case ".ios.js" /* IosJs */:
+            case ".android.js" /* AndroidJs */:
                 return needAllowJs();
             case ".json" /* Json */:
+            case ".node.json" /* NodeJson */:
+            case ".web.json" /* WebJson */:
+            case ".native.json" /* NativeJson */:
+            case ".ios.json" /* IosJson */:
+            case ".android.json" /* AndroidJson */:
                 return needResolveJsonModule();
         }
         function needJsx() {
@@ -91855,7 +92296,7 @@ var ts;
             if (globalCache !== undefined && !ts.isExternalModuleNameRelative(moduleName) && !(primaryResult.resolvedModule && ts.extensionIsTS(primaryResult.resolvedModule.extension))) {
                 // create different collection of failed lookup locations for second pass
                 // if it will fail and we've already found something during the first pass - we don't want to pollute its results
-                var _a = ts.loadModuleFromGlobalCache(moduleName, resolutionHost.projectName, compilerOptions, host, globalCache), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
+                var _a = ts.loadModuleFromGlobalCache(moduleName, containingFile, resolutionHost.projectName, compilerOptions, host, globalCache), resolvedModule = _a.resolvedModule, failedLookupLocations = _a.failedLookupLocations;
                 if (resolvedModule) {
                     return { resolvedModule: resolvedModule, failedLookupLocations: ts.addRange(primaryResult.failedLookupLocations, failedLookupLocations) };
                 }
@@ -91865,7 +92306,9 @@ var ts;
         }
         function resolveNamesWithLocalCache(names, containingFile, redirectedReference, cache, perDirectoryCacheWithRedirects, loader, getResolutionWithResolvedFileName, shouldRetryResolution, reusedNames, logChanges) {
             var path = resolutionHost.toPath(containingFile);
-            var resolutionsInFile = cache.get(path) || cache.set(path, ts.createMap()).get(path);
+            var context = ts.getFileExtension(containingFile);
+            var pathKey = path + "|" + context;
+            var resolutionsInFile = cache.get(pathKey) || cache.set(pathKey, ts.createMap()).get(pathKey);
             var dirPath = ts.getDirectoryPath(path);
             var perDirectoryCache = perDirectoryCacheWithRedirects.getOrCreateMapOfCacheRedirects(redirectedReference);
             var perDirectoryResolution = perDirectoryCache.get(dirPath);
@@ -91885,22 +92328,23 @@ var ts;
             var seenNamesInFile = ts.createMap();
             for (var _i = 0, names_2 = names; _i < names_2.length; _i++) {
                 var name = names_2[_i];
-                var resolution = resolutionsInFile.get(name);
+                var nameKey = name + "|" + context;
+                var resolution = resolutionsInFile.get(nameKey);
                 // Resolution is valid if it is present and not invalidated
-                if (!seenNamesInFile.has(name) &&
+                if (!seenNamesInFile.has(nameKey) &&
                     allFilesHaveInvalidatedResolution || unmatchedRedirects || !resolution || resolution.isInvalidated ||
                     // If the name is unresolved import that was invalidated, recalculate
                     (hasInvalidatedNonRelativeUnresolvedImport && !ts.isExternalModuleNameRelative(name) && shouldRetryResolution(resolution))) {
                     var existingResolution = resolution;
-                    var resolutionInDirectory = perDirectoryResolution.get(name);
+                    var resolutionInDirectory = perDirectoryResolution.get(nameKey);
                     if (resolutionInDirectory) {
                         resolution = resolutionInDirectory;
                     }
                     else {
                         resolution = loader(name, containingFile, compilerOptions, resolutionHost, redirectedReference);
-                        perDirectoryResolution.set(name, resolution);
+                        perDirectoryResolution.set(nameKey, resolution);
                     }
-                    resolutionsInFile.set(name, resolution);
+                    resolutionsInFile.set(nameKey, resolution);
                     watchFailedLookupLocationsOfExternalModuleResolutions(name, resolution);
                     if (existingResolution) {
                         stopWatchFailedLookupLocationOfResolution(existingResolution);
@@ -91912,14 +92356,15 @@ var ts;
                     }
                 }
                 ts.Debug.assert(resolution !== undefined && !resolution.isInvalidated);
-                seenNamesInFile.set(name, true);
+                seenNamesInFile.set(nameKey, true);
                 resolvedModules.push(getResolutionWithResolvedFileName(resolution));
             }
             // Stop watching and remove the unused name
-            resolutionsInFile.forEach(function (resolution, name) {
-                if (!seenNamesInFile.has(name) && !ts.contains(reusedNames, name)) {
+            resolutionsInFile.forEach(function (resolution, nameKey) {
+                var name = nameKey.split('|')[0];
+                if (!seenNamesInFile.has(nameKey) && !ts.contains(reusedNames, name)) {
                     stopWatchFailedLookupLocationOfResolution(resolution);
-                    resolutionsInFile.delete(name);
+                    resolutionsInFile.delete(nameKey);
                 }
             });
             return resolvedModules;
@@ -92717,11 +93162,46 @@ var ts;
                 case ".ts" /* Ts */:
                 case ".d.ts" /* Dts */:
                     return ".js" /* Js */;
+                case ".node.ts" /* NodeTs */:
+                    return ".node.js" /* NodeJs */;
+                case ".web.ts" /* WebTs */:
+                    return ".web.js" /* WebJs */;
+                case ".native.ts" /* NativeTs */:
+                    return ".native.js" /* NativeJs */;
+                case ".ios.ts" /* IosTs */:
+                    return ".ios.js" /* IosJs */;
+                case ".android.ts" /* AndroidTs */:
+                    return ".android.js" /* AndroidJs */;
                 case ".tsx" /* Tsx */:
                     return options.jsx === 1 /* Preserve */ ? ".jsx" /* Jsx */ : ".js" /* Js */;
+                case ".node.tsx" /* NodeTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".node.jsx" /* NodeJsx */ : ".node.js" /* NodeJs */;
+                case ".web.tsx" /* WebTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".web.jsx" /* WebJsx */ : ".web.js" /* WebJs */;
+                case ".native.tsx" /* NativeTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".native.jsx" /* NativeJsx */ : ".native.js" /* NativeJs */;
+                case ".ios.tsx" /* IosTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".ios.jsx" /* IosJsx */ : ".ios.js" /* IosJs */;
+                case ".android.tsx" /* AndroidTsx */:
+                    return options.jsx === 1 /* Preserve */ ? ".android.jsx" /* AndroidJsx */ : ".android.js" /* AndroidJs */;
                 case ".js" /* Js */:
                 case ".jsx" /* Jsx */:
+                case ".node.js" /* NodeJs */:
+                case ".node.jsx" /* NodeJsx */:
+                case ".web.js" /* WebJs */:
+                case ".web.jsx" /* WebJsx */:
+                case ".native.js" /* NativeJs */:
+                case ".native.jsx" /* NativeJsx */:
+                case ".ios.js" /* IosJs */:
+                case ".ios.jsx" /* IosJsx */:
+                case ".android.js" /* AndroidJs */:
+                case ".android.jsx" /* AndroidJsx */:
                 case ".json" /* Json */:
+                case ".node.json" /* NodeJson */:
+                case ".web.json" /* WebJson */:
+                case ".native.json" /* NativeJson */:
+                case ".ios.json" /* IosJson */:
+                case ".android.json" /* AndroidJson */:
                     return ext;
                 case ".tsbuildinfo" /* TsBuildInfo */:
                     return ts.Debug.fail("Extension " + ".tsbuildinfo" /* TsBuildInfo */ + " is unsupported:: FileName:: " + fileName);
