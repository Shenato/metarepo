import React from 'react'
import TestRenderer from 'react-test-renderer'
import test from 'blue-tape'
import { createSpy, getSpyCalls } from 'spyfn'
import { createTimeoutSpy } from 'spyt'
import { component, mapDebouncedHandlerFactory, startWithType } from '../src'

test('mapDebouncedHandler: initial', async (t) => {
  const spy = createSpy(() => null)
  const timeout = createTimeoutSpy()
  const mapDebouncedHandler = mapDebouncedHandlerFactory(timeout.setTimeout, timeout.clearTimeout)

  const MyComp = component(
    startWithType<{ handler: () => void, delay: number }>(), // eslint-disable-line func-call-spacing
    mapDebouncedHandler('handler', ({ delay }) => delay)
  )('Name', (props) => <span {...props}/>)

  const testRenderer = TestRenderer.create(
    <MyComp
      handler={spy}
      delay={100}
    />
  )

  const props = testRenderer.root.findByType('span').props

  // first call
  props.handler(42, 'foo')

  t.deepEquals(
    timeout.getSetTimeoutCalls(),
    [
      [100],
    ],
    'should set proper delay'
  )

  t.deepEquals(
    timeout.getClearTimeoutCalls(),
    [],
    'should call clearTimeout'
  )

  t.deepEquals(
    getSpyCalls(spy),
    [],
    'should not call spy immediately'
  )

  // second call
  props.handler(43, 'bar')

  t.deepEquals(
    timeout.getClearTimeoutCalls(),
    [
      [0],
    ],
    'should clear previous timeout'
  )

  t.deepEquals(
    timeout.getSetTimeoutCalls(),
    [
      [100],
      [100],
    ],
    'should set proper delay'
  )

  t.deepEquals(
    getSpyCalls(spy),
    [],
    'should not call spy immediately'
  )

  // timeout tick
  timeout.tick()

  t.deepEquals(
    getSpyCalls(spy),
    [
      [43, 'bar'],
    ],
    'should call spy after delay'
  )

  t.deepEquals(
    timeout.getClearTimeoutCalls(),
    [
      [0],
    ],
    'should not call clearTimeout'
  )

  t.deepEquals(
    timeout.getSetTimeoutCalls(),
    [
      [100],
      [100],
    ],
    'should not call new setTimeout'
  )

  props.handler('next call')

  t.deepEquals(
    getSpyCalls(spy),
    [
      [43, 'bar'],
    ],
    'should not call spy immediately'
  )

  t.deepEquals(
    timeout.getClearTimeoutCalls(),
    [
      [0],
    ],
    'should not call clearTimeout'
  )

  t.deepEquals(
    timeout.getSetTimeoutCalls(),
    [
      [100],
      [100],
      [100],
    ],
    'should call new setTimeout'
  )
})

test('mapDebouncedHandler: rerender', async (t) => {
  const spy = createSpy(() => null)
  const timeout = createTimeoutSpy()
  const mapDebouncedHandler = mapDebouncedHandlerFactory(timeout.setTimeout, timeout.clearTimeout)

  const MyComp = component(
    startWithType<{ handler: () => void, delay: number }>(), // eslint-disable-line func-call-spacing
    mapDebouncedHandler('handler', ({ delay }) => delay)
  )('Name', (props) => <span {...props}/>)

  const testRenderer = TestRenderer.create(
    <MyComp
      handler={spy}
      delay={100}
    />
  )

  const prevProps = testRenderer.root.findByType('span').props

  testRenderer.update(
    <MyComp
      handler={spy}
      delay={100}
    />
  )

  const nextProps = testRenderer.root.findByType('span').props

  t.equals(
    prevProps.handler,
    nextProps.handler,
    'should return same handler'
  )
})

test('mapDebouncedHandler: invalid handler', async (t) => {
  const timeout = createTimeoutSpy()
  const mapDebouncedHandler = mapDebouncedHandlerFactory(timeout.setTimeout, timeout.clearTimeout)

  const MyComp = component(
    startWithType<{ handler: () => void, delay: number }>(), // eslint-disable-line func-call-spacing
    mapDebouncedHandler('handler', ({ delay }) => delay)
  )('Name', (props) => <span {...props}/>)

  const testRenderer = TestRenderer.create(
    <MyComp
      handler={null!}
      delay={50}
    />
  )

  const props = testRenderer.root.findByType('span').props

  props.handler()

  timeout.tick()

  t.pass('should not fail')
})

test('mapDebouncedHandler: update', async (t) => {
  const spy1 = createSpy(() => null)
  const spy2 = createSpy(() => null)
  const timeout = createTimeoutSpy()
  const mapDebouncedHandler = mapDebouncedHandlerFactory(timeout.setTimeout, timeout.clearTimeout)

  const MyComp = component(
    startWithType<{ handler: () => void, delay: number }>(), // eslint-disable-line func-call-spacing
    mapDebouncedHandler('handler', ({ delay }) => delay)
  )('Name', (props) => <span {...props}/>)

  const testRenderer = TestRenderer.create(
    <MyComp
      handler={spy1}
      delay={100}
    />
  )

  let props = testRenderer.root.findByType('span').props

  // first call
  props.handler(42, 'foo')

  t.deepEquals(
    getSpyCalls(spy1),
    [],
    'should not call spy1 immediately'
  )

  testRenderer.update(<MyComp
    handler={spy2}
    delay={100}
  />)

  props = testRenderer.root.findByType('span').props

  // second call
  props.handler(43, 'bar')

  t.deepEquals(
    getSpyCalls(spy1),
    [],
    'should not call spy1 after delay'
  )

  timeout.tick()

  t.deepEquals(
    getSpyCalls(spy2),
    [
      [43, 'bar'],
    ],
    'should call spy2 after delay'
  )
})

test('mapDebouncedHandler: unmount', async (t) => {
  const spy = createSpy(() => null)
  const timeout = createTimeoutSpy()
  const mapDebouncedHandler = mapDebouncedHandlerFactory(timeout.setTimeout, timeout.clearTimeout)

  const MyComp = component(
    startWithType<{ handler: () => void, delay: number }>(), // eslint-disable-line func-call-spacing
    mapDebouncedHandler('handler', ({ delay }) => delay)
  )('Name', (props) => <span {...props}/>)

  const testRenderer = TestRenderer.create(
    <MyComp
      handler={spy}
      delay={100}
    />
  )

  const props = testRenderer.root.findByType('span').props

  // first call
  props.handler(1, 'foo')

  t.deepEquals(
    getSpyCalls(spy),
    [],
    'should not call spy immediately'
  )

  testRenderer.unmount()

  // tick
  timeout.tick()

  t.deepEquals(
    getSpyCalls(spy),
    [],
    'should not call spy after delay'
  )

  t.deepEquals(
    timeout.getClearTimeoutCalls(),
    [
      [0],
    ],
    'should clear'
  )
})

test('mapDebouncedHandler: unmount not existing', async (t) => {
  const spy = createSpy(() => null)
  const timeout = createTimeoutSpy()
  const mapDebouncedHandler = mapDebouncedHandlerFactory(timeout.setTimeout, timeout.clearTimeout)

  const MyComp = component(
    startWithType<{ handler: () => void, delay: number }>(), // eslint-disable-line func-call-spacing
    mapDebouncedHandler('handler', ({ delay }) => delay)
  )('Name', (props) => <span {...props}/>)

  const testRenderer = TestRenderer.create(
    <MyComp
      handler={spy}
      delay={100}
    />
  )

  testRenderer.unmount()

  t.deepEquals(
    getSpyCalls(spy),
    [],
    'should not call spy'
  )

  t.deepEquals(
    timeout.getClearTimeoutCalls(),
    [],
    'should not call clear'
  )
})
